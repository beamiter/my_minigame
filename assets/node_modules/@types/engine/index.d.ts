/// <reference lib="dom" />
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface' {
	 global {
	    const MAIN_CANVAS: HTMLCanvasElement;
	    const ENGINE_SETTINGS: any;
	    const ENGINE_MODE: 'Game' | 'Editor';
	    const IS_SUB_CONTEXT: boolean;
	    const HOST: string;
	}
	/**
	 * 顶点数据格式枚举。
	 */
	export enum EVertexFormat {
	    FLOAT = 0,
	    FLOAT2 = 1,
	    FLOAT3 = 2,
	    FLOAT4 = 3,
	    BYTE4 = 4,
	    BYTE4N = 5,
	    UBYTE4 = 6,
	    UBYTE4N = 7,
	    SHORT2 = 8,
	    SHORT2N = 9,
	    SHORT4 = 10,
	    SHORT4N = 11,
	    UINT10_N2 = 12
	}
	/**
	 * 顶点数据步进类型枚举。
	 */
	export enum EVertexStep {
	    /**
	     * 逐顶点。
	     */
	    PER_VERTEX = 0,
	    /**
	     * 在使用Instance的情况下，逐实例。
	     */
	    PER_INSTANCE = 1
	}
	/**
	 * 索引数据类型。
	 */
	export enum EIndexType {
	    /**
	     * 无效值。
	     */
	    NONE = 1,
	    /**
	     * 16位索引。
	     */
	    UINT16 = 2,
	    /**
	     * 32位索引，注意在某些设备上不支持。
	     */
	    UINT32 = 3
	}
	/**
	 * 压缩纹理类型。
	 */
	export type TCompressTexture = 'etc1' | 'etc2' | 'astc' | 'pvrtc' | 's3tc';
	/**
	 * 纹理类型雷剧。
	 */
	export enum ETextureType {
	    /**
	     * 2D纹理。
	     */
	    D2 = 0,
	    /**
	     * 立方体纹理。
	     */
	    Cube = 1,
	    /**
	     * 2D纹理数组。
	     */
	    D2Array = 2,
	    /**
	     * 3D纹理。
	     */
	    D3 = 3
	}
	/**
	 * 纹理格式枚举。
	 */
	export enum ETextureFormat {
	    /** Inputs or Render Target Formats. */
	    RGBA8 = 0,
	    SRGBA8 = 1,
	    RGB10A2 = 2,
	    RG8 = 3,
	    R8 = 4,
	    RGBA32F = 5,
	    RGBA16F = 6,
	    RG11B10F = 7,
	    /** Render Target Only. */
	    Depth_Low = 20,
	    Depth_High = 21,
	    Depth_Stencil = 22,
	    RGBA4 = 23,
	    RGB565 = 24,
	    RGB5A1 = 25,
	    /** Compresseds */
	    ETC1RGB8 = 100,
	    ETC2RGB8 = 110,
	    ETC2RGBA8 = 111,
	    PVRTC2RGBV1 = 120,
	    PVRTC4RGBV1 = 121,
	    PVRTC2RGBAV1 = 122,
	    PVRTC4RGBAV1 = 123,
	    ASTC4x4 = 140,
	    ASTC5x5 = 141,
	    ASTC6x6 = 142,
	    ASTC8x6 = 143,
	    ASTC8x8 = 144,
	    DXT1 = 150,
	    DXT3 = 151,
	    DXT5 = 152
	}
	/**
	 * 纹理寻址模式枚举。
	 */
	export enum EWrapMode {
	    REPEAT = 1,
	    CLAMP_TO_EDGE = 2,
	    MIRRORED_REPEAT = 3
	}
	/**
	 * 纹理过滤模式枚举。
	 */
	export enum EFilterMode {
	    NEAREST = 1,
	    LINEAR = 2,
	    NEAREST_MIPMAP_NEAREST = 3,
	    NEAREST_MIPMAP_LINEAR = 4,
	    LINEAR_MIPMAP_NEAREST = 5,
	    LINEAR_MIPMAP_LINEAR = 6
	}
	/**
	 * Uniform值得类型枚举。
	 */
	export enum EUniformType {
	    FLOAT = 0,
	    FLOAT2 = 1,
	    FLOAT3 = 2,
	    FLOAT4 = 3,
	    MAT2 = 4,
	    MAT3 = 5,
	    MAT4 = 6,
	    SAMPLER = 7
	}
	/**
	 * 背面剔除类型枚举。
	 */
	export enum ECullMode {
	    NONE = 0,
	    FRONT = 1,
	    BACK = 2
	}
	/**
	 * 正面顶点绕序枚举。
	 */
	export enum EFaceWinding {
	    CCW = 1,
	    CW = 2
	}
	/**
	 * 各种测试的比较函数枚举。
	 */
	export enum ECompareFunc {
	    LESS = 1,
	    LEQUAL = 2,
	    EQUAL = 3,
	    GEQUAL = 4,
	    GREATER = 5,
	    NOTEQUAL = 6,
	    NEVER = 7,
	    ALWAYS = 8
	}
	/**
	 * 模板测试操作枚举。
	 */
	export enum EStencilOp {
	    ZERO = 0,
	    KEEP = 1,
	    REPLACE = 2,
	    INCR_WRAP = 3,
	    INCR = 4,
	    DECR_WRAP = 5,
	    DECR = 6,
	    INVERT = 7
	}
	/**
	 * 混合因子枚举。
	 */
	export enum EBlendFactor {
	    ZERO = 0,
	    ONE = 1,
	    SRC_COLOR = 2,
	    ONE_MINUS_SRC_COLOR = 3,
	    SRC_ALPHA = 4,
	    ONE_MINUS_SRC_ALPHA = 5,
	    DST_ALPHA = 6,
	    ONE_MINUS_DST_ALPHA = 7,
	    DST_COLOR = 8,
	    ONE_MINUS_DST_COLOR = 9,
	    SRC_ALPHA_SATURATE = 10,
	    CONSTANT_COLOR = 11,
	    ONE_MINUS_CONSTANT_COLOR = 12
	}
	/**
	 * 混合方式枚举。
	 */
	export enum EBlendEquation {
	    FUNC_ADD = 0,
	    FUNC_SUBTRACT = 1,
	    FUNC_REVERSE_SUBTRACT = 2,
	    MIN = 3,
	    MAX = 4
	}
	/**
	 * 颜色通道掩码枚举。
	 */
	export enum EColorMask {
	    /**
	     * 将会禁掉所有通道的输出。
	     */
	    NONE = 16,
	    R = 1,
	    G = 2,
	    B = 4,
	    A = 8,
	    RGB = 7,
	    RGBA = 15
	}
	/**
	 * 像素数据类型枚举。
	 */
	export enum EPixelType {
	    UNSIGNED_BYTE = 5121,
	    FLOAT = 5126,
	    UNSIGNED_SHORT_5_6_5 = 33635,
	    UNSIGNED_SHORT_4_4_4_4 = 32819,
	    UNSIGNED_SHORT_5_5_5_1 = 32820
	}
	/**
	 * 清屏操作枚举。
	 */
	export enum ELoadAction {
	    /**
	     * 清除屏幕颜色。
	     */
	    CLEAR = 0,
	    /**
	     * 不清屏，但依赖前面渲染的结果。
	     */
	    LOAD = 1,
	    /**
	     * 完全不关心是否清屏。
	     */
	    DONTCARE = 2
	}
	export enum EDataModelType {
	    AnimationClip = 1,
	    SkeletonBoneInverse = 2
	}
	/**
	 * 渲染组件类型枚举。
	 */
	export enum EMeshRenderType {
	    /**
	     * 未知类型。
	     */
	    UnKnown = 0,
	    /**
	     * 静态3D类型。
	     */
	    Static3D = 1,
	    /**
	     * 蒙皮3D类型。
	     */
	    Skinned3D = 2,
	    /**
	     * UI类型。
	     */
	    UI = 3
	}
	/**
	 * 图元渲染类型枚举。
	 */
	export enum EPrimitiveType {
	    TRIANGLES = 0,
	    TRIANGLE_STRIP = 1,
	    LINES = 2,
	    LINE_STRIP = 3,
	    POINTS = 4,
	    ZERO = 5
	}
	/**
	 * 阴影类型枚举。
	 */
	export enum EShadowMode {
	    /**
	     * 关闭阴影。
	     */
	    None = 0,
	    /**
	     * 开启单级联阴影，并开启PCF。
	     */
	    OneCascade_PCF = 1,
	    /**
	     * 开启二级联阴影，并开启PCF。
	     */
	    TwoCascade_PCF = 2,
	    /**
	     * 开启四级联阴影，并开启PCF。
	     */
	    FourCascade_PCF = 4
	}
	/**
	 * 阴影匹配类型枚举。
	 */
	export enum EShadowFitMode {
	    /**
	     * 阴影范围适配视锥体。
	     * 更稳定，可能降低阴影精度。
	     */
	    FitFrustum = 0,
	    /**
	     * 阴影范围适配物体。
	     * 能提高阴影精度，但可能会导致阴影不稳定。
	     */
	    FitObjects = 1
	}
	/**
	 * 顶点数据布局用途枚举。
	 */
	export enum EVertexLayoutUsage {
	    CUSTOM = 0,
	    POSITION = 1,
	    NORMAL = 2,
	    TANGENT = 3,
	    UV0 = 4,
	    UV1 = 5,
	    UV2 = 6,
	    COLOR = 7,
	    BONEINDEX = 8,
	    BONEWEIGHT = 9
	}
	/**
	 * 动态合批操作符枚举。
	 */
	export enum EVertexBatchOperator {
	    /**
	     * 矩阵乘法。
	     */
	    MatrixMultiple = 0,
	    /**
	     * Scale offset。
	     */
	    UVST = 1
	}
	export enum EAnimationBlendType {
	    Override = 0,
	    Additive = 1
	}
	export enum EUseDefaultAddedAction {
	    Ignore = 0,
	    Refresh = 1
	}
	export enum EUseDefaultRetainedAction {
	    Keep = 0,
	    Refresh = 1,
	    WriteBack = 2
	}
	export enum EUseDefaultRemovedAction {
	    Keep = 0,
	    Clear = 1,
	    WriteBack = 2
	}
	export const RENDER_ENV_OFFSETS: {
	    size: number;
	    resetFlag: number;
	    renderPass: number;
	    canvasWidth: number;
	    canvasHeight: number;
	    uniforms: number;
	    useInstanceOrNeverTranspose: number;
	};
	export const POOL_SUB_ID_MASK = 65472;
	export const POOL_SUB_ID_SHIT = 6;
	export const ENTITY2D_OFFSETS: {
	    size: number;
	    rotation: number;
	    position: number;
	    scale: number;
	    worldMatrix: number;
	};
	export const ENTITY3D_OFFSETS: {
	    size: number;
	    dfRotationType: number;
	    rotationType: number;
	    rotation: number;
	    position: number;
	    scale: number;
	    worldOffset: number;
	    worldMatrix: number;
	};
	export const CULLING_OFFSETS: {
	    size: number;
	    active: number;
	    dfActive: number;
	    layer: number;
	    boundingBallCenter: number;
	    boundingBallRadius: number;
	    entityId: number;
	};
	export const CAMERA_OFFSETS: {
	    size: number;
	    view: number;
	    depth: number;
	    active: number;
	    fov: number;
	    aspect: number;
	    near: number;
	    far: number;
	    up: number;
	    eye: number;
	    orthoSize: number;
	    isProjection: number;
	    cullingMask: number;
	    canvasSizeY: number;
	    targetTransform: number;
	    viewMatrix: number;
	    projectionMatrix: number;
	    viewMatrixInverse: number;
	    viewMatrix2D: number;
	    projectionMatrix2D: number;
	    viewMatrixInverse2D: number;
	    manualMatrix: number;
	    layerCullDistances: number;
	};
	export const LIGHT_OFFSETS: {
	    size: number;
	    view: number;
	    depth: number;
	    active: number;
	    shadowDistance: number;
	    shadowMode: number;
	    shadowFilterMode: number;
	    lightDir: number;
	    bounds: number;
	    lightSpaceMatrices: number;
	};
	export const MESH_OFFSETS: {
	    dynamicBatch: number;
	    skinHandle: number;
	    castShadow: number;
	    bindTarget: number;
	    start: number;
	    size: number;
	    materialId: number;
	    vertexBufferId: number;
	    indexBufferId: number;
	    startIndex: number;
	    numIndices: number;
	};
	export const EFFECT_OFFSETS: {
	    size: number;
	    useMaterialStates: number;
	    fstencil: number;
	    bstencil: number;
	    blendRGBA: number;
	    colorDepth: number;
	    state: number;
	};
	export const MATERIAL_OFFSETS: {
	    size: number;
	    renderQueue: number;
	    effect: number;
	    uniformBlock: number;
	    fstencilMask: number;
	    bstencilMask: number;
	    blendRGBAMask: number;
	    colorDepthMask: number;
	    stateMask: number;
	    fstencil: number;
	    bstencil: number;
	    blendRGBA: number;
	    colorDepth: number;
	    state: number;
	    useInstance: number;
	};
	export const SKINNED_SKELETON_OFFSETS: {
	    boneInverseModelId: number;
	    boneIndices: number;
	    perBoneIndices: number;
	    perBoneEntityId: number;
	    perBoneMatrixOld: number;
	    perBoneMatrixNew: number;
	};
	export const DYNAMIC_BONES_OFFSETS: {
	    stiffness: number;
	    elasticity: number;
	    damping: number;
	};
	export interface IHandle {
	    id: number;
	    data?: ArrayBuffer;
	    destroy?: Function;
	}
	/**
	 * 顶点布局解构初始化参数。
	 */
	export interface IVertexLayoutOptions {
	    /**
	     * 顶点属性列表。
	     */
	    attributes: {
	        /**
	         * 属性名字。
	         */
	        name: string;
	        /**
	         * 属性名格式。
	         */
	        format: EVertexFormat;
	        /**
	         * 属性在Buffer中的偏移量（字节）。
	         */
	        offset: number;
	        /**
	         * 属性的用途。
	         */
	        usage: EVertexLayoutUsage;
	    }[];
	    /**
	     * 步进类型。
	     *
	     * @default EVertexStep.PER_VERTEX
	     */
	    step?: EVertexStep;
	    /**
	     * 步长，不设定会自动计算。
	     */
	    stride?: number;
	    /**
	     * 步进单位。
	     *
	     * @default 1
	     */
	    stepRate?: number;
	}
	/**
	 * 动态合批描述符创建参数。
	 */
	export interface IVertexDataDescriptorOptions {
	    vuMap: [string, string, EVertexBatchOperator?][];
	    ignored?: string[];
	    ubIndex?: number;
	}
	/**
	 * UniformBlock描述符创建参数。
	 */
	export interface IUniformDescriptorOptions {
	    /**
	     * 名字。
	     */
	    name?: string;
	    /**
	     * Uniform描述列表。
	     */
	    uniforms: {
	        /**
	         * 名字。
	         */
	        name: string;
	        /**
	         * 类型。
	         */
	        type: EUniformType;
	        /**
	         * 长度。
	         */
	        num?: number;
	        /**
	         * @deprecated
	         */
	        needTranspose?: boolean;
	    }[];
	}
	/**
	 * 引擎原生图片接口。
	 */
	export interface IImage {
	    /**
	     * 是否要预乘Alpha。
	     */
	    premultiplyAlpha: boolean;
	    /**
	     * 加载完成的回调。
	     */
	    onload: (() => void) | null;
	    /**
	     * 出错的回调。
	     */
	    onerror: ((error: Error) => void) | null;
	    /**
	     * 图片地址。
	     */
	    src: string;
	    /**
	     * 图片宽度。
	     */
	    width: number;
	    /**
	     * 图片高度。
	     */
	    height: number;
	    /**
	     * 解码数据，视不同Backend而定。
	     */
	    readonly data?: ArrayBuffer;
	}
	/**
	 * 可用于纹理的资源。
	 */
	export type TTextureSource = ArrayBuffer | ArrayBufferView | IImage;
	/**
	 * 外部需要注入的下载器接口。
	 */
	export interface IRealDownloader {
	    load: (options: {
	        src: string;
	        encoding: 'binary' | 'utf-8' | undefined;
	        onLoad: (res: {
	            data: ArrayBuffer;
	            filePath: string;
	        }) => void;
	        onError: (error: Error) => void;
	    }) => void;
	}
	/**
	 * 下载器。
	 */
	export interface IDownloader {
	    REAL_DOWNLOADER: IRealDownloader;
	    LOAD(options: Parameters<IRealDownloader['load']>[0]): void;
	}
	/**
	 * 字体配置。
	 */
	export interface IFontSetting {
	    fontFamily: string;
	    bold?: string;
	    italic?: string;
	    size?: number;
	}
	/**
	 * 渲染层提供的特性列表。
	 */
	export interface IFeatures {
	    /**
	     * 是否支持GPU实例化。
	     */
	    gpuInstance: boolean;
	    /**
	     * 是否支持3D动态合批。
	     */
	    dynamicBatch3D: boolean;
	    /**
	     * 是否支持硬件SRGB解码。
	     */
	    srgb: boolean;
	    /**
	     * 是否支持各向异性滤波。
	     */
	    textureAnisotropic: boolean;
	    /**
	     * 是否支持浮点纹理。
	     */
	    textureFloat: boolean;
	    /**
	     * 是否支持半精度浮点纹理。
	     */
	    textureHalfFloat: boolean;
	    /**
	     * 是否支持浮点类型的颜色缓冲。
	     */
	    colorBufferFloat: boolean;
	    /**
	     * 是否支持深度纹理。
	     */
	    depthTexture: boolean;
	    /**
	     * 是否支持在片段着色器采样深度。
	     */
	    fragDepth: boolean;
	}
	export interface IRect {
	    x: number;
	    y: number;
	    w: number;
	    h: number;
	}
	/**
	 * 对一个View进行清屏的操作。
	 */
	export interface IViewAction {
	    /**
	     * 颜色操作。
	     */
	    colorAction?: ELoadAction;
	    /**
	     * 深度操作。
	     */
	    depthAction?: ELoadAction;
	    /**
	     * 模板操作。
	     */
	    stencilAction?: ELoadAction;
	    /**
	     * 用于清屏的颜色值。
	     *
	     * @default [0,0,0,0]
	     */
	    clearColor?: [number, number, number, number];
	    /**
	     * 用于清屏的深度值。
	     *
	     * @default 1
	     */
	    clearDepth?: number;
	    /**
	     * 用于清屏的模板值。
	     *
	     * @default 0
	     */
	    clearStencil?: number;
	}
	/**
	 * 视图接口。
	 */
	export interface IView {
	    /**
	     * 视图清屏操作。
	     */
	    passAction: IViewAction;
	    /**
	     * 视图区域。
	     */
	    viewport: IRect;
	    /**
	     * 裁剪区域。
	     */
	    scissor: IRect;
	}
	/**
	 * 附件接口。
	 */
	export interface IAttachment {
	    texture: IHandle;
	    level?: number;
	    slice?: number;
	}
	/**
	 * 渲染通道描述符。
	 */
	export interface IRenderPassDescriptor {
	    colors: IAttachment[];
	    depth: IAttachment;
	    stencil: IAttachment;
	}
	export enum EEventType {
	    SetRootEntity = 1,
	    AddChild = 2,
	    AddChildAtIndex = 3,
	    RemoveFromParent = 4,
	    DisperseSubTree = 5,
	    BindToBone = 6,
	    BindToBones = 7,
	    UnBindFromBone = 8,
	    UnBindFromBones = 9,
	    EntityCommandActive = 10,
	    EntityCommandInActive = 11
	}
	export interface IGlyphInfo {
	    code: number;
	    tex: number;
	    uv_x: number;
	    uv_y: number;
	    uv_w: number;
	    uv_h: number;
	    advance: number;
	    bearing_x: number;
	    bearing_y: number;
	    width: number;
	    height: number;
	}
	export interface IEventBridge {
	    entityAddChild(entity: number, child: number): void;
	    entityAddChildAtIndex(entity: number, child: number, index: number): void;
	    entityRemoveFromParent(entity: number): void;
	    entityClear(entity: number): void;
	    entitySetActive(entity: number, active: boolean): void;
	    entitySetLocalMatrixDirty(entity: number): void;
	    setRootEntity(entity: number): void;
	    refreshWorldTransform(): void;
	    bindEntityToBone(entity: {
	        id: number;
	    }, boneEntity: {
	        id: number;
	    }): void;
	    unbindEntityFromBone(entity: {
	        id: number;
	    }): void;
	    bindEntitiesToBones(entities: Array<{
	        id: number;
	    }>, boneEntities: Array<{
	        id: number;
	    }>): void;
	    unbindEntitiesFromBones(entities: Array<{
	        id: number;
	    }>): void;
	}
	export interface IRenderEnv extends IHandle {
	    version?: string;
	    backendType: string;
	    registerFallbackEffect(lightMode: string, handle?: IHandle): void;
	    changeMacros(macros: {
	        [name: string]: string | number | boolean;
	    }): void;
	    changeVirtualMacros(macros: {
	        [name: string]: boolean;
	    }): void;
	    setInternalInstanceInfo(type: EMeshRenderType, info: {
	        uniformKey: string;
	        attributeName: string;
	        type: EUniformType;
	    }[], ignored: string[]): void;
	    supportCompressTextures: TCompressTexture[];
	    features: IFeatures;
	}
	export interface INativeMap<T> {
	    set(key: T, value: number): void;
	    get(key: T): number | undefined;
	    del(key: T): void;
	}
	export interface ILongIntNativeMap {
	    set(key1: number, key2: number, value: number): void;
	    get(key1: number, key2: number): number | undefined;
	    del(key1: number, key2: number): void;
	}
	export type WeakRef = any;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface/IWorker' {
	/**
	 * IWorker.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/3/2020, 4:45:58 PM
	 */
	import { IHandle, ETextureType, ETextureFormat, IRect, EMeshRenderType, INativeMap, ILongIntNativeMap, IGlyphInfo, IVertexLayoutOptions, IView, IRenderPassDescriptor, IEventBridge, IDownloader, IUniformDescriptorOptions, IFontSetting, TTextureSource, IImage, IVertexDataDescriptorOptions, IRenderEnv } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export interface IWorker {
	    createVertexLayout(options: IVertexLayoutOptions): IHandle;
	    createVertexDataDescriptor(options: IVertexDataDescriptorOptions): IHandle;
	    createVertexBuffer(buffer: ArrayBuffer | ArrayBufferView, layout: IHandle): IHandle;
	    updateVertexBuffer(bufferHandle: IHandle, buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	    createIndexBuffer(buffer: ArrayBuffer | ArrayBufferView, is32bits?: boolean): IHandle;
	    updateIndexBuffer(bufferHandle: IHandle, buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	    createVertexData(layout: IHandle, size: number, batchDesc: IHandle): IHandle;
	    createIndexData(size: number): IHandle;
	    createTexture(type: ETextureType, width: number, height: number, slice: number, mips: number, format: ETextureFormat, flags: number, source: TTextureSource[], offsets: Uint32Array): IHandle;
	    createAutoUpdateTextureFromCanvas(canvas: HTMLCanvasElement): IHandle;
	    updateTexture(handle: IHandle, level: number, slice: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, buffer: ArrayBuffer | ArrayBufferView | IImage | HTMLCanvasElement | ImageData): void;
	    updateTextureFlags(texture: IHandle, flags: number): void;
	    createUniformBlockDescriptor(descriptor: IUniformDescriptorOptions): IHandle;
	    createUniformBlock(descriptor: IHandle): IHandle;
	    createEffect(name: string, passCount: number, keyIndexMap: string[], passes: {
	        lightMode: string;
	        variants: {
	            [key: number]: number;
	        };
	        macros: {
	            [key: string]: number;
	        };
	    }[], shaders: string[], variants: number[][]): IHandle & {
	        warmUp(): void;
	    };
	    createMaterial(macros?: {
	        [name: string]: string | number | boolean;
	    }, uniformBlock?: IHandle): IHandle;
	    changeMaterialMacros(material: IHandle, macros: {
	        [name: string]: string | number | boolean;
	    }, reset?: boolean): void;
	}
	export interface IWorker {
	    createView(view: IView): IHandle;
	    updateViewRect(view: IHandle, rect: IRect): void;
	    updateViewScissor(view: IHandle, rect: IRect): void;
	}
	export interface IWorker {
	    createRenderPass(descriptor: IRenderPassDescriptor): IHandle;
	}
	export interface IWorker {
	    createNodePool(count: number, is3d: boolean): IHandle;
	    createNodeTree(length: number, ids: ArrayBuffer, buffer: ArrayBuffer, calculateWordMatrix: boolean, is3d: boolean): boolean;
	}
	export interface IWorker {
	    createCullingComponentPool(count: number): IHandle;
	    createRenderComponent(meshCount: number, uniformBlock: IHandle, attachedNodeId: number, cullingCompId: number, meshRenderType: EMeshRenderType, macros?: {
	        [name: string]: string | number | boolean;
	    }): IHandle & {
	        setSharedDirty(): void;
	    };
	    changeMeshMacros(mesh: IHandle, macros: {
	        [name: string]: string | number | boolean;
	    }, reset?: boolean): void;
	    createAnimator(clipCount: number, nodeCount: number): IHandle;
	    updateAnimators(feObjects: {
	        id: number;
	    }[], size: number): void;
	    createAnimationClipBinding(clipArray: {
	        id: number;
	    }[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<number | {
	        id: number;
	    } | null>, entityArrayOffset: number, entityArrayLength: number, useDefaultAddedNodesAction: number, rootEntity: {
	        id: number;
	    }): IHandle;
	    rebindAnimationClipBinding(binding: IHandle, clipArray: {
	        id: number;
	    }[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<number | {
	        id: number;
	    } | null>, entityArrayOffset: number, entityArrayLength: number, removeAction: number, retainedAction: number, addedAction: number, rootEntity: {
	        id: number;
	    }): boolean;
	    updateAnimationClipBinding(binding: IHandle, clipArray: {
	        id: number;
	    }[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<number | {
	        id: number;
	    } | null>, entityArrayOffset: number, entityArrayLength: number, removeAction: number, retainedAction: number, addedAction: number): boolean;
	    writeAnimationClipBindingDefaultValues(binding: IHandle): void;
	    createAnimatorControllerModel(layerCount: number): IHandle;
	    setAnimatorControllerModelMaskAtIndex(model: IHandle, index: number, mask: {
	        buffer: null | ArrayBuffer;
	        offset: number;
	        length: number;
	    }): void;
	    updateAnimatorControllerModel(model: IHandle): void;
	    createAnimatorControllerStateModel(clipCount: number): IHandle;
	    updateAnimatorControllers(// for performance
	    feObjects: {
	        id: number;
	    }[], size: number): void;
	    createSkinning(boneCount: number, flag: number): IHandle;
	    updateSkinnings(feObjects: {
	        id: number;
	    }[], size: number): void;
	    createDynamicBones(rootNodeId: number): IHandle & {
	        preUpdate(): void;
	        update(dt: number, rootMotionX?: number, rootMotionY?: number, rootMotionZ?: number): void;
	        rebuild(): void;
	        resetRoot(rootId: number): void;
	    };
	}
	export interface IWorker {
	    createRenderCamera(attachedNodeId: number, isUI?: boolean): IHandle & {
	        setSharedDirty(): void;
	        updateMatrices(): void;
	    };
	    createLightCamera(): IHandle;
	}
	export interface IWorker {
	    createAnimationClipModel(buffer: ArrayBuffer): IHandle;
	    createBoneInverseModel(buffer: ArrayBuffer): IHandle;
	    createScalableList(initSize: number, onBackendEnlarge: () => void): IHandle & {
	        enlarge(size: number): void;
	    };
	}
	export interface IWorker {
	    eventBridge: IEventBridge;
	}
	export interface IWorker {
	    loadTTFFont(url: string, callback: (font: string) => void): void;
	    getGlyphInfo(fontSetting: IFontSetting, charCode: number): IGlyphInfo;
	}
	export interface IWorker {
	    downloader: IDownloader;
	    update(delta: number): void;
	    refreshNodesWorldTransform(): void;
	    getRenderEnv(): IRenderEnv;
	    clearView(view: IHandle): void;
	    cullCamera(camera: IHandle, cullResult: IHandle, lightMode: string): void;
	    drawCamera(camera: IHandle, renderList: IHandle, lightMode: string): void;
	    drawLight(light: IHandle, camera: IHandle, renderList: IHandle, lightMode: string): void;
	    submit(): void;
	    createWeakRef<T>(wrapper: T): {
	        deref: () => T;
	    };
	    createWeakRefSentry(): any;
	    createNativeUUMap(): INativeMap<number>;
	    createNativeSUMap(): INativeMap<string>;
	    createNativeULUMap(): ILongIntNativeMap;
	    setNodeName(id: number, name: string): void;
	    setRenderComponentName(handle: IHandle, name: string): void;
	    debugPrint(msg: string): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend' {
	/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/3/2020, 8:45:18 PM
	 */
	export * from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import { IImage } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import { IWorker } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface/IWorker';
	export interface IBackend {
	    IS_VALID: () => boolean;
	    GET_MAIN_CANVAS(): HTMLCanvasElement;
	    worker: IWorker;
	    Image: {
	        new (): IImage;
	        IS(obj: any): obj is IImage;
	    };
	} const backend: IBackend;
	export default backend;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject' {
	/**
	 * NativeObject.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/3/2020, 9:17:03 PM
	 */
	import { IHandle } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	export default class NativeObject {
	    id: number;
	    get __handle(): IHandle;
	    setRawBuffer(data: Float32Array): void;
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/Pool' {
	/**
	 * Pool.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/3/2020, 9:18:35 PM
	 */
	import { IHandle } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	export default class Pool extends NativeObject {
	    constructor(nativeObj: IHandle);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolObject' {
	import Pool from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/Pool';
	export interface INativePools {
	    [poolId: number]: Pool;
	}
	export default class PoolObject {
	    entityOffset: number;
	    get float32View(): Float32Array;
	    get uint32View(): Uint32Array;
	    get id(): number;
	    get poolId(): number;
	    get poolIndex(): number;
	    get isUsing(): boolean;
	    set isUsing(value: boolean);
	    setRawBuffer(data: Float32Array): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/ScalableNumberArray' {
	/**
	 * ScalableNumberArray.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/3/2020, 9:23:34 PM
	 */
	export default class scaleNumberArray {
	    constructor(len?: number);
	    push(val: number): void;
	    pop(): number;
	    getByIndex(index: number): number;
	    size(): number;
	    clear(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolManager' {
	/**
	 * PoolManager.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/3/2020, 9:19:34 PM
	 */
	import { IHandle } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PoolObject, { INativePools } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolObject';
	export default class PoolManager {
	    pools: INativePools;
	    constructor(template: ArrayBuffer, templateView: Float32Array, allocateFunc: (size: number) => IHandle);
	    allocateOne(): number;
	    dispose(obj: PoolObject): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/ScalableTypedArray' {
	 type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;
	export default class ScalableTypedArray<T extends TypedArray> {
	    constructor(ctor: {
	        new (size: number): T;
	    }, len?: number);
	    push(val: number): void;
	    pop(): number;
	    getByIndex(index: number): number;
	    size(): number;
	    clear(): void;
	    get buffer(): ArrayBufferLike;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D' {
	import PoolObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolObject';
	import PoolManager from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolManager';
	export default class Entity3D extends PoolObject {
	    static POLL_MANAGER: PoolManager;
	    static OFFSETS: {
	        size: number;
	        dfRotationType: number;
	        rotationType: number;
	        rotation: number;
	        position: number;
	        scale: number;
	        worldOffset: number;
	        worldMatrix: number;
	    };
	    static CREATE_TREE(length: number, buffer: ArrayBuffer, out: Array<any>, calculateWordMatrix?: boolean): boolean;
	    localRotationTypeOffset: number;
	    localQuaternionOffset: number;
	    localPositionOffset: number;
	    localScaleOffset: number;
	    worldMatrixOffset: number;
	    constructor();
	    setUsingEuler(on: boolean): void;
	    isUsingEuler(): boolean;
	    addChild(child: Entity3D): void;
	    addChildAtIndex(child: Entity3D, index: number): void;
	    removeFromParent(): void;
	    setAsRoot(): void;
	    destroy(): void;
	    /**
	     * 如果只调用entityClear指令，那么Kanata就无法回收根节点下面的子节点了。
	     * 目前Kanata的frontend没有父子关系信息只能这么做了。
	     * 这个方法目前只能减少eventBridge的指令量，避免在大规模节点销毁的时候频繁触发eventBridge的溢出提交。
	     * @param entities
	     * @param length
	     */
	    clear(entities: Entity3D[], length: number): void;
	    setLocalMatrixDirty(): void;
	    set active(val: boolean);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity2D' {
	import PoolObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolObject';
	import PoolManager from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolManager';
	export default class Entity2D extends PoolObject {
	    static POLL_MANAGER: PoolManager;
	    static OFFSETS: {
	        size: number;
	        rotation: number;
	        position: number;
	        scale: number;
	        worldMatrix: number;
	    };
	    localPositionOffset: number;
	    localRotationOffset: number;
	    localScaleOffset: number;
	    worldMatrixOffset: number;
	    constructor();
	    addChild(child: Entity2D): void;
	    addChildAtIndex(child: Entity2D, index: number): void;
	    removeFromParent(): void;
	    setAsRoot(): void;
	    destroy(): void;
	    clear(): void;
	    setLocalMatrixDirty(): void;
	    set active(val: boolean);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource' {
	/**
	 * PureResource.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/8/2020, 9:04:32 PM
	 */
	import { IHandle } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	export default class PureResource {
	    id: number;
	    protected get _handle(): IHandle;
	    protected set _handle(value: IHandle);
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface/stateBuilder' {
	export const PT_SAMPLER_WRAP_S_MASK = 7;
	export const PT_SAMPLER_WRAP_T_MASK = 56;
	export const PT_SAMPLER_WRAP_R_MASK = 448;
	export const PT_SAMPLER_FILTER_MIN_MASK = 3584;
	export const PT_SAMPLER_FILTER_MAG_MASK = 12288;
	export const PT_SAMPLER_MASK_ALL = 16383;
	export const PT_TEXTURE_RT_MSAA_MASK = 393216;
	export const PT_TEXTURE_ANISOTROPY_MASK = 15728640;
	export function PACK_SAMPLER_WRAP_S_INDEX(value: number, v: number): number;
	export function PACK_SAMPLER_WRAP_T_INDEX(value: number, v: number): number;
	export function PACK_SAMPLER_WRAP_R_INDEX(value: number, v: number): number;
	export function PACK_SAMPLER_FILTER_MIN_INDEX(value: number, v: number): number;
	export function PACK_SAMPLER_FILTER_MAG_INDEX(value: number, v: number): number;
	export function PACK_TEXTURE_GENERATE_MIPMAP(value: number, v: boolean): number;
	export function PACK_TEXTURE_SAMPLE_COUNT(value: number, v: number): number;
	export function PACK_TEXTURE_ANISO(value: number, v: number): number;
	export function PACK_TEXTURE_IS_RT(value: number, v: boolean): number;
	export function PACK_TEXTURE_IS_RT_WRITE_ONLY(value: number, v: boolean): number;
	export function EXTRACT_SAMPLER_WRAP_S_INDEX(value: number): number;
	export function EXTRACT_SAMPLER_WRAP_T_INDEX(value: number): number;
	export function EXTRACT_SAMPLER_WRAP_R_INDEX(value: number): number;
	export function EXTRACT_SAMPLER_FILTER_MIN_INDEX(value: number): number;
	export function EXTRACT_SAMPLER_FILTER_MAG_INDEX(value: number): number;
	export function EXTRACT_TEXTURE_GENERATE_MIPMAP(value: number): boolean;
	export function EXTRACT_TEXTURE_SAMPLE_COUNT(value: number): number;
	export function EXTRACT_TEXTURE_IS_RT(value: number): boolean;
	export function EXTRACT_TEXTURE_IS_RT_WRITE_ONLY(value: number): boolean;
	export function EXTRACT_TEXTURE_IS_RT_MSAA(value: number): boolean;
	export function EXTRACT_TEXTURE_IS_RT_MSAA_X2(value: number): boolean;
	export function EXTRACT_TEXTURE_IS_RT_MSAA_X4(value: number): boolean;
	export function EXTRACT_TEXTURE_ANISO(value: number): number;
	export const PT_BLEND_COLOR_R_MASK = 255;
	export const PT_BLEND_COLOR_G_MASK = 65280;
	export const PT_BLEND_COLOR_B_MASK = 16711680;
	export const PT_BLEND_COLOR_A_MASK = 4278190080;
	export function PACK_BLEND_COLOR(r: number, g: number, b: number, a: number): number;
	export function EXTRACT_BLEND_COLOR_R(value: number): number;
	export function EXTRACT_BLEND_COLOR_G(value: number): number;
	export function EXTRACT_BLEND_COLOR_B(value: number): number;
	export function EXTRACT_BLEND_COLOR_A(value: number): number;
	export const PT_WRITE_RGBA_MASK = 15;
	export const PT_WRITE_Z = 2147483648;
	export function PACK_ENABLE_WRITE_Z(value: number, v: boolean): number;
	export function PACK_ENABLE_WRITE_RGBA(value: number, v: boolean): number;
	export function EXTRACT_ENABLE_WRITE_R(value: number): boolean;
	export function EXTRACT_ENABLE_WRITE_G(value: number): boolean;
	export function EXTRACT_ENABLE_WRITE_B(value: number): boolean;
	export function EXTRACT_ENABLE_WRITE_A(value: number): boolean;
	export function EXTRACT_ENABLE_WRITE_RGBA(value: number): boolean;
	export function EXTRACT_ENABLE_WRITE_Z(value: number): boolean;
	/**
	 * Blend test state.
	 */
	export const PT_BLEND_ENABLE = 1073741824;
	export const PT_BLEND_MASK_ALL = 2147483392;
	export function PACK_ENABLE_BLEND(value: number, v: boolean): number;
	export function EXTRACT_ENABLE_BLEND(value: number): boolean;
	export const PT_BLEND_FACTOR_MASK = 16776960;
	export function PACK_BLEND_SRC_RGB(value: number, v: number): number;
	export function PACK_BLEND_DST_RGB(value: number, v: number): number;
	export function PACK_BLEND_SRC_A(value: number, v: number): number;
	export function PACK_BLEND_DST_A(value: number, v: number): number;
	export function BLEND_FUNC(src: number, dst: number): number;
	export function BLEND_FUNC_SEPARATE(srcRgb: number, dstRgb: number, srcA: number, dstA: number): number;
	export function EXTRACT_BLEND_FACTOR_SRC_RGB_INDEX(value: number): number;
	export function EXTRACT_BLEND_FACTOR_DST_RGB_INDEX(value: number): number;
	export function EXTRACT_BLEND_FACTOR_SRC_A_INDEX(value: number): number;
	export function EXTRACT_BLEND_FACTOR_DST_A_INDEX(value: number): number;
	export const PT_BLEND_EQUATION_MASK = 1056964608;
	export function PACK_BLEND_EQUATION_RGB(value: number, v: number): number;
	export function PACK_BLEND_EQUATION_A(value: number, v: number): number;
	export function BLEND_EQUATION(mode: number): number;
	export function BLEND_EQUATION_SEPARATE(mode_rgb: number, mode_a: number): number;
	export function EXTRACT_BLEND_EQUATION_RGB_INDEX(value: number): number;
	export function EXTRACT_BLEND_EQUATION_A_INDEX(value: number): number;
	export const PT_DEPTH_TEST_MASK = 240;
	export const PT_DEPTH_MASK_ALL = 2147483888;
	export function PACK_DEPTH_FUNC(value: number, v: number): number;
	export function EXTRACT_ENABLE_DEPTH_TEST(value: number): boolean;
	export function EXTRACT_DEPTH_TEST_FUNC_INDEX(value: number): number;
	export const PT_STENCIL_MASK = 4294967295;
	export const PT_STENCIL_RMASK_SHIFT = 0;
	export const PT_STENCIL_RMASK_MASK = 255;
	export function PACK_STENCIL_RMASK(value: number, v: number): number;
	export function EXTRACT_STENCIL_RMASK(value: number): number;
	export const PT_STENCIL_REF_MASK = 65280;
	export function PACK_STENCIL_REF(value: number, v: number): number;
	export function EXTRACT_STENCIL_REF(value: number): number;
	export const PT_STENCIL_TEST_MASK = 983040;
	export function PACK_STENCIL_TEST(value: number, v: number): number;
	export function EXTRACT_ENABLE_STENCIL_TEST(value: number): boolean;
	export function EXTRACT_STENCIL_TEST_INDEX(value: number): number;
	export const PT_STENCIL_OP_MASK = 4293918720;
	export function PACK_STENCIL_OP_SFAILURE(value: number, v: number): number;
	export function PACK_STENCIL_OP_DFAILURE(value: number, v: number): number;
	export function PACK_STENCIL_OP_PASS(value: number, v: number): number;
	export function STENCIL_OP(fail: number, zfail: number, pass: number): number;
	export function EXTRACT_STENCIL_OP_SFAILURE_INDEX(value: number): number;
	export function EXTRACT_STENCIL_OP_DFAILURE_INDEX(value: number): number;
	export function EXTRACT_STENCIL_OP_PASS_INDEX(value: number): number;
	/**
	 * Set Other States.
	 *
	 */
	/**
	 * Set Stencil Write Mask.
	 */
	export const PT_STATE_STENCIL_WMASK_SHIFT = 0;
	export const PT_STATE_STENCIL_WMASK_MASK = 255;
	export function PACK_STENCIL_WMASK(value: number, v: number): number;
	export function EXTRACT_STENCIL_WMASK(value: number): number;
	export const PT_STATE_CULL_MASK = 768;
	export function PACK_CULL(value: number, v: number): number;
	export function EXTRACT_CULL(value: number): number;
	export function EXTRACT_ENABLE_CULL(value: number): boolean;
	export function EXTRACT_IS_CULL_FRONT(value: number): boolean;
	export function EXTRACT_IS_FRONT_CCW(value: number): boolean;
	export const PT_STATE_PT_MASK = 14336;
	export function PACK_PRIMITIVE_TYPE(value: number, v: number): number;
	export function EXTRACT_PRIMITIVE_TYPE_INDEX(value: number): number;
	export function PACK_USE_MATERIAL_STATE(value: number, maskFromBit1: number, v: boolean): number;
	export function EXTRACT_USE_MATERIAL_STATE(value: number, maskFromBit1: number): boolean;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Texture' {
	/**
	 * Texture.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 2:35:42 PM
	 */
	import { ETextureFormat, ETextureType, EWrapMode, EFilterMode, TTextureSource } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	export interface ITextureOptions {
	    width?: number;
	    height?: number;
	    isWriteOnly?: boolean;
	    isRenderTarget?: boolean;
	    canvas?: HTMLCanvasElement;
	    source?: TTextureSource[];
	    offsets?: Uint32Array;
	    type?: ETextureType;
	    slices?: number;
	    mips?: number;
	    pixelFormat?: ETextureFormat;
	    minFilter?: EFilterMode;
	    magFilter?: EFilterMode;
	    generateMipmaps?: boolean;
	    wrapU?: EWrapMode;
	    wrapV?: EWrapMode;
	    wrapW?: EWrapMode;
	    anisoLevel?: number;
	    sampleCount?: number;
	}
	export default class Texture extends PureResource {
	    get type(): ETextureType;
	    get width(): number;
	    get height(): number;
	    get slice(): number;
	    get mips(): number;
	    get pixelFormat(): ETextureFormat;
	    get wrapU(): EWrapMode;
	    set wrapU(value: EWrapMode);
	    get wrapV(): EWrapMode;
	    set wrapV(value: EWrapMode);
	    get wrapW(): EWrapMode;
	    set wrapW(value: EWrapMode);
	    get magFilter(): EFilterMode;
	    set magFilter(value: EFilterMode);
	    get minFilter(): EFilterMode;
	    set minFilter(value: EFilterMode);
	    get anisoLevel(): number;
	    set anisoLevel(value: number);
	    get sampleCount(): number;
	    set sampleCount(value: number);
	    get generateMipmaps(): boolean;
	    set generateMipmaps(value: boolean);
	    get isRenderTarget(): boolean;
	    set isRenderTarget(value: boolean);
	    constructor(options: ITextureOptions);
	    update(options: {
	        level?: number;
	        slice?: number;
	        xoffset?: number;
	        yoffset?: number;
	        zoffset?: number;
	        width?: number;
	        height?: number;
	        buffer: TTextureSource;
	    }): void;
	    showDebugInfo(): string;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/RenderPass' {
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Texture';
	export interface IRenderPassOptions {
	    colors: {
	        texture: Texture;
	        slice?: number;
	        level?: number;
	    }[];
	    depth: {
	        texture: Texture;
	        slice?: number;
	        level?: number;
	    };
	    stencil?: {
	        texture: Texture;
	        slice?: number;
	        level?: number;
	    };
	}
	export default class RenderPass extends PureResource {
	    static SCREEN_RENDER_PASS: RenderPass;
	    constructor(options: IRenderPassOptions);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/View' {
	/**
	 * View.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 6:43:18 PM
	 */
	import { IRect, IViewAction } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	/**
	 * 视图，用于控制清屏、视图区域等配置。
	 */
	export default class View extends PureResource {
	    constructor(options: {
	        passAction: IViewAction;
	        viewport: IRect;
	        scissor: IRect;
	    });
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Effect' {
	/**
	 * Effect.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/9/2020, 5:49:54 PM
	 */
	import { EBlendFactor, EBlendEquation, ECullMode, ECompareFunc, EPrimitiveType, EStencilOp } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	export default class Effect extends NativeObject {
	    static OFFSETS: {
	        size: number;
	        useMaterialStates: number;
	        fstencil: number;
	        bstencil: number;
	        blendRGBA: number;
	        colorDepth: number;
	        state: number;
	    };
	    get passCount(): number;
	    constructor(name: string, passCount: number, keyIndexMap: string[], passes: {
	        lightMode: string;
	        variants: {
	            [key: number]: number;
	        };
	        macros: {
	            [key: string]: number;
	        };
	    }[], shaders: string[], variants: number[][]);
	    warmUp(): any;
	    getBlendOn(pass: number): boolean;
	    setBlendOn(pass: number, value: boolean): void;
	    getBlendSrc(pass: number): EBlendFactor;
	    setBlendSrc(pass: number, value: EBlendFactor): void;
	    getBlendDst(pass: number): EBlendFactor;
	    setBlendDst(pass: number, value: EBlendFactor): void;
	    getBlendSrcRGB(pass: number): EBlendFactor;
	    setBlendSrcRGB(pass: number, value: EBlendFactor): void;
	    getBlendSrcAlpha(pass: number): EBlendFactor;
	    setBlendSrcAlpha(pass: number, value: EBlendFactor): void;
	    getBlendDstRGB(pass: number): EBlendFactor;
	    setBlendDstRGB(pass: number, value: EBlendFactor): void;
	    getBlendDstAlpha(pass: number): EBlendFactor;
	    setBlendDstAlpha(pass: number, value: EBlendFactor): void;
	    getBlendFunc(pass: number): EBlendEquation;
	    setBlendFunc(pass: number, value: EBlendEquation): void;
	    getDepthTestOn(pass: number): boolean;
	    setDepthTestOn(pass: number, value: boolean): void;
	    getDepthTestComp(pass: number): ECompareFunc;
	    setDepthTestComp(pass: number, value: ECompareFunc): void;
	    getDepthWrite(pass: number): boolean;
	    setDepthWrite(pass: number, value: boolean): void;
	    getCullFace(pass: number): ECullMode;
	    setCullFace(pass: number, value: ECullMode): void;
	    getCullOn(pass: number): boolean;
	    setCullOn(pass: number, value: boolean): void;
	    getPrimitiveType(pass: number): EPrimitiveType;
	    setPrimitiveType(pass: number, value: EPrimitiveType): void;
	    getStencilTestOn(pass: number): boolean;
	    setStencilTestOn(pass: number, value: boolean): void;
	    getStencilComp(pass: number): ECompareFunc;
	    setStencilComp(pass: number, value: ECompareFunc): void;
	    getStencilPass(pass: number): EStencilOp;
	    setStencilPass(pass: number, value: EStencilOp): void;
	    getStencilFail(pass: number): EStencilOp;
	    setStencilFail(pass: number, value: EStencilOp): void;
	    getStencilZFail(pass: number): EStencilOp;
	    setStencilZFail(pass: number, value: EStencilOp): void;
	    getStencilWriteMask(pass: number): number;
	    setStencilWriteMask(pass: number, value: number): void;
	    getStencilReadMask(pass: number): number;
	    setStencilReadMask(pass: number, value: number): void;
	    getStencilRef(pass: number): number;
	    setStencilRef(pass: number, value: number): void;
	    getUseMaterialStates(pass: number): boolean;
	    setUseMaterialStates(pass: number, value: boolean): void;
	    getUseMaterialStateBlendOn(pass: number): boolean;
	    setUseMaterialStateBlendOn(pass: number, value: boolean): void;
	    getUseMaterialStateBlendSrcRGB(pass: number): boolean;
	    setUseMaterialStateBlendSrcRGB(pass: number, value: boolean): void;
	    getUseMaterialStateBlendSrcAlpha(pass: number): boolean;
	    setUseMaterialStateBlendSrcAlpha(pass: number, value: boolean): void;
	    getUseMaterialStateBlendDstRGB(pass: number): boolean;
	    setUseMaterialStateBlendDstRGB(pass: number, value: boolean): void;
	    getUseMaterialStateBlendDstAlpha(pass: number): boolean;
	    setUseMaterialStateBlendDstAlpha(pass: number, value: boolean): void;
	    getUseMaterialStateBlendFunc(pass: number): boolean;
	    setUseMaterialStateBlendFunc(pass: number, value: boolean): void;
	    getUseMaterialStateDepthTestOn(pass: number): boolean;
	    setUseMaterialStateDepthTestOn(pass: number, value: boolean): void;
	    getUseMaterialStateDepthTestComp(pass: number): boolean;
	    setUseMaterialStateDepthTestComp(pass: number, value: boolean): void;
	    getUseMaterialStateDepthWrite(pass: number): boolean;
	    setUseMaterialStateDepthWrite(pass: number, value: boolean): void;
	    getUseMaterialStateCullOn(pass: number): boolean;
	    setUseMaterialStateCullOn(pass: number, value: boolean): void;
	    getUseMaterialStateCullFace(pass: number): boolean;
	    setUseMaterialStateCullFace(pass: number, value: boolean): void;
	    getUseMaterialStatePrimitiveType(pass: number): boolean;
	    setUseMaterialStatePrimitiveType(pass: number, value: boolean): void;
	    getUseMaterialStateStencilTestOn(pass: number): boolean;
	    setUseMaterialStateStencilTestOn(pass: number, value: boolean): void;
	    getUseMaterialStateStencilTestComp(pass: number): boolean;
	    setUseMaterialStateStencilTestComp(pass: number, value: boolean): void;
	    getUseMaterialStateStencilTestPass(pass: number): boolean;
	    setUseMaterialStateStencilTestPass(pass: number, value: boolean): void;
	    getUseMaterialStateStencilTestFail(pass: number): boolean;
	    setUseMaterialStateStencilTestFail(pass: number, value: boolean): void;
	    getUseMaterialStateStencilTestZFail(pass: number): boolean;
	    setUseMaterialStateStencilTestZFail(pass: number, value: boolean): void;
	    showDebugInfo(): string;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/renderEnv' {
	/**
	 * renderEnv.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 1/18/2021, 3:53:26 PM
	 */
	import { EMeshRenderType, EUniformType, IFeatures, TCompressTexture } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	import View from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/View';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Effect';
	import RenderPass from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/RenderPass';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformBlock';
	export class RenderEnv extends PureResource {
	    get version(): [number, number];
	    get backendType(): any;
	    get canvasWidth(): number;
	    set canvasWidth(value: number);
	    get canvasHeight(): number;
	    set canvasHeight(value: number);
	    get supportCompressTextures(): TCompressTexture[];
	    get features(): IFeatures;
	    get useInstance(): boolean;
	    set useInstance(value: boolean);
	    get neverTranspose(): boolean;
	    set neverTranspose(value: boolean);
	    get isWrongWrapMapping(): boolean;
	    get isNotWrongEffectSort(): boolean;
	    get isGoodInstance(): boolean;
	    constructor();
	    supportCompressTexture(type: TCompressTexture): boolean;
	    registerFallbackEffect(lightMode: string, effect?: Effect): void;
	    beginFrame(): void;
	    endFrame(): void;
	    clearView(view: View): void;
	    setEnvUniform(index: number, uniforms: UniformBlock): void;
	    setRenderPass(renderPass: RenderPass): void;
	    changeMacros(macros: {
	        [name: string]: string | number | boolean;
	    }): void;
	    getMacro(key: string): string | number | boolean;
	    changeVirtualMacros(macros: {
	        [name: string]: boolean;
	    }): void;
	    getVirtualMacro(key: string): boolean;
	    setInternalInstanceInfo(type: EMeshRenderType, info: {
	        uniformKey: string;
	        attributeName: string;
	        type: EUniformType;
	    }[], ignored: string[]): void;
	} const renderEnv: RenderEnv;
	export default renderEnv;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformDescriptor' {
	/**
	 * UniformDescriptor.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 2:34:50 PM
	*/
	import { IUniformDescriptorOptions } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	/**
	 * UniformBlock描述符。
	 */
	export default class UniformDescriptor extends PureResource {
	    /**
	     * 以Float计的长度。
	     */
	    get size(): number;
	    constructor(options: IUniformDescriptorOptions);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformBlock' {
	/**
	 * UniformBlock.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 2:34:36 PM
	 */
	import { IHandle } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import UniformDescriptor from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformDescriptor';
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Texture';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	/**
	 * 存储Uniform的一个区块。
	 */
	export default class UniformBlock extends PureResource {
	    /**
	     * 描述符。
	     */
	    get descriptor(): UniformDescriptor;
	    /**
	     * @param descriptor 描述符。
	     */
	    constructor(descriptor: UniformDescriptor);
	    /**
	     * 是否包含某个成员uniform。
	     */
	    hasKey(key: string): boolean;
	    /**
	     * 设置某个成员uniform。
	     */
	    setUniform(key: string, value: ArrayLike<number> | Texture | number): boolean;
	    /**
	     * 获取某个成员uniform。
	     * 如果是返回`number`，则是纹理的id。
	     */
	    getUniform(key: string): Float32Array | number;
	    /**
	     * 科隆某个uniform。
	     */
	    clone(): UniformBlock;
	    /**
	     * 复制某个uniform。
	     */
	    copy(ub: UniformBlock): void;
	    showDebugInfo(): string;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexLayout' {
	/**
	 * VertexLayout.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 5:01:51 PM
	 */
	import { IVertexLayoutOptions, EVertexLayoutUsage } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	/**
	 * 顶点布局描述。
	 */
	export default class VertexLayout extends PureResource {
	    /**
	     * 顶点数据单位步长。
	     */
	    get stride(): number;
	    constructor(options: IVertexLayoutOptions);
	    /**
	     * 获取某个属性的配置。
	     */
	    getConfigByName(name: string): {
	        name: string;
	        format: import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').EVertexFormat;
	        offset: number;
	        usage: EVertexLayoutUsage;
	    };
	    /**
	     * 获取某个用途的属性的配置。
	     */
	    getConfigByUsage(usage: EVertexLayoutUsage): {
	        name: string;
	        format: import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').EVertexFormat;
	        offset: number;
	        usage: EVertexLayoutUsage;
	    };
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexBuffer' {
	import VertexLayout from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexLayout';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	export default class VertexBuffer extends PureResource {
	    get byteSize(): number;
	    get layout(): VertexLayout;
	    constructor(buffer: ArrayBuffer | ArrayBufferView, layout: VertexLayout);
	    update(buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/IndexBuffer' {
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	export default class IndexBuffer extends PureResource {
	    get byteSize(): number;
	    constructor(buffer: ArrayBuffer | ArrayBufferView, is32bits?: boolean);
	    update(buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexDataDescriptor' {
	/**
	 * VertexDataDescriptor.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 4/28/2021, 4:38:37 PM
	 */
	import { IVertexDataDescriptorOptions } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	export default class VertexDataDescriptor extends PureResource {
	    constructor(options: IVertexDataDescriptorOptions);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexData' {
	/**
	 * VertexData.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/11/2020, 4:43:52 PM
	 */
	import VertexDataDescriptor from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexDataDescriptor';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	import VertexLayout from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexLayout';
	export default class VertexData extends PureResource {
	    get layout(): VertexLayout;
	    get data(): ArrayBuffer;
	    constructor(layout: VertexLayout, size: number, batchDesc: VertexDataDescriptor);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/IndexData' {
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	export default class IndexData extends PureResource {
	    get data(): ArrayBuffer;
	    constructor(size: number);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Material' {
	/**
	 * Material.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 6:41:13 PM
	 */
	import { EBlendFactor, EBlendEquation, ECompareFunc, ECullMode, EStencilOp, EPrimitiveType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformBlock';
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Effect';
	export default class Material extends NativeObject {
	    static OFFSETS: {
	        size: number;
	        renderQueue: number;
	        effect: number;
	        uniformBlock: number;
	        fstencilMask: number;
	        bstencilMask: number;
	        blendRGBAMask: number;
	        colorDepthMask: number;
	        stateMask: number;
	        fstencil: number;
	        bstencil: number;
	        blendRGBA: number;
	        colorDepth: number;
	        state: number;
	        useInstance: number;
	    };
	    get effect(): Effect;
	    set effect(value: Effect);
	    get uniforms(): UniformBlock;
	    set uniforms(value: UniformBlock);
	    get renderQueue(): number;
	    set renderQueue(value: number);
	    get useInstance(): boolean;
	    set useInstance(value: boolean);
	    get blendOn(): boolean;
	    set blendOn(value: boolean);
	    get blendSrcRGB(): EBlendFactor;
	    set blendSrcRGB(value: EBlendFactor);
	    get blendSrcRGBChanged(): boolean;
	    get blendSrcAlpha(): EBlendFactor;
	    set blendSrcAlpha(value: EBlendFactor);
	    set blendSrc(value: EBlendFactor);
	    get blendDstRGB(): EBlendFactor;
	    set blendDstRGB(value: EBlendFactor);
	    get blendDstRGBChanged(): boolean;
	    get blendDstAlpha(): EBlendFactor;
	    set blendDstAlpha(value: EBlendFactor);
	    set blendDst(value: EBlendFactor);
	    get blendFunc(): EBlendEquation;
	    set blendFunc(value: EBlendEquation);
	    get depthTestOn(): boolean;
	    set depthTestOn(value: boolean);
	    get depthTestComp(): ECompareFunc;
	    set depthTestComp(value: ECompareFunc);
	    get depthWrite(): boolean;
	    set depthWrite(value: boolean);
	    get cullFace(): ECullMode;
	    set cullFace(value: ECullMode);
	    get cullOn(): boolean;
	    set cullOn(value: boolean);
	    get primitiveType(): EPrimitiveType;
	    set primitiveType(value: EPrimitiveType);
	    get stencilTestOn(): boolean;
	    set stencilTestOn(value: boolean);
	    get stencilComp(): ECompareFunc;
	    set stencilComp(value: ECompareFunc);
	    get stencilPass(): EStencilOp;
	    set stencilPass(value: EStencilOp);
	    get stencilFail(): EStencilOp;
	    set stencilFail(value: EStencilOp);
	    get stencilZFail(): EStencilOp;
	    set stencilZFail(value: EStencilOp);
	    get stencilWriteMask(): number;
	    set stencilWriteMask(value: number);
	    get stencilReadMask(): number;
	    set stencilReadMask(value: number);
	    get stencilRef(): number;
	    set stencilRef(value: number);
	    get blendOnMask(): boolean;
	    set blendOnMask(value: boolean);
	    get blendSrcRGBMask(): boolean;
	    set blendSrcRGBMask(value: boolean);
	    get blendSrcAlphaMask(): boolean;
	    set blendSrcAlphaMask(value: boolean);
	    set blendSrcMask(value: boolean);
	    get blendDstRGBMask(): boolean;
	    set blendDstRGBMask(value: boolean);
	    get blendDstAlphaMask(): boolean;
	    set blendDstAlphaMask(value: boolean);
	    set blendDstMask(value: boolean);
	    get blendFuncMask(): boolean;
	    set blendFuncMask(value: boolean);
	    get depthTestOnMask(): boolean;
	    set depthTestOnMask(value: boolean);
	    get depthTestCompMask(): boolean;
	    set depthTestCompMask(value: boolean);
	    get depthWriteMask(): boolean;
	    set depthWriteMask(value: boolean);
	    get cullFaceMask(): boolean;
	    set cullFaceMask(value: boolean);
	    get cullOnMask(): boolean;
	    set cullOnMask(value: boolean);
	    get primitiveTypeMask(): boolean;
	    set primitiveTypeMask(value: boolean);
	    get stencilTestOnMask(): boolean;
	    set stencilTestOnMask(value: boolean);
	    get stencilCompMask(): boolean;
	    set stencilCompMask(value: boolean);
	    get stencilPassMask(): boolean;
	    set stencilPassMask(value: boolean);
	    get stencilFailMask(): boolean;
	    set stencilFailMask(value: boolean);
	    get stencilZFailMask(): boolean;
	    set stencilZFailMask(value: boolean);
	    get stencilWriteMaskMask(): boolean;
	    set stencilWriteMaskMask(value: boolean);
	    get stencilReadMaskMask(): boolean;
	    set stencilReadMaskMask(value: boolean);
	    get stencilRefMask(): boolean;
	    set stencilRefMask(value: boolean);
	    constructor(macros?: {
	        [name: string]: string | number | boolean;
	    }, effect?: Effect, uniformBlock?: UniformBlock);
	    changeMacros(macros?: {
	        [name: string]: string | number | boolean;
	    }): void;
	    getMacro(key: string): string | number | boolean;
	    clone(uniforms?: UniformBlock): Material;
	    showDebugInfo(): string;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/DataModel' {
	/**
	 * DataModel.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 1:18:13 PM
	 */
	import { EDataModelType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	export default class DataModel extends PureResource {
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/SkeletonBoneInverseModel' {
	import DataModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/DataModel';
	export default class SkeletonBoneInverseModel extends DataModel {
	    boneNum: number;
	    setBoneInverseMatrix(matrices: Float32Array): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/SkinnedSkeletonComponent' {
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	import SkeletonBoneInverseModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/SkeletonBoneInverseModel';
	import Entity3D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	export default class SkinnedSkeletonComponent extends NativeObject {
	    static UPDATE_MATS(comps: SkinnedSkeletonComponent[], size: number): void;
	    get boneNum(): number;
	    get boneInverseModel(): SkeletonBoneInverseModel;
	    get boneOffsetMatrices(): Float32Array;
	    constructor(boneNum: number, flag: number);
	    setBoneMatrix(boneInverseModel: SkeletonBoneInverseModel, boneIndices: number[], boneEntities: Entity3D[]): void;
	    getBoneNum(): number;
	    getBoneOffsetMatrices(): Float32Array;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/CullingComponent' {
	import Entity3D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	import Entity2D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity2D';
	import PoolObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolObject';
	import PoolManager from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/pool/PoolManager';
	export default class CullingComponent extends PoolObject {
	    static POLL_MANAGER: PoolManager;
	    constructor(entity: Entity2D | Entity3D);
	    getActive(): boolean;
	    setActive(val: boolean): void;
	    getLayer(): number;
	    setLayer(val: number): void;
	    getBoundingBallCenter(): Float32Array;
	    setBoundingBallCenter(val: Float32Array, offset?: number): void;
	    getBoundingBallRadius(): number;
	    setBoundingBallRadius(val: number): void;
	    bindEntity(entity: Entity2D | Entity3D): void;
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/MeshRendererComponent' {
	/**
	 * MeshRendererComponent.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/3/2020, 7:54:23 PM
	 */
	import { EMeshRenderType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	import Entity3D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	import Entity2D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity2D';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformBlock';
	import VertexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexBuffer';
	import IndexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/IndexBuffer';
	import VertexData from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexData';
	import IndexData from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/IndexData';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Material';
	import SkinnedSkeletonComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/SkinnedSkeletonComponent';
	import CullingComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/CullingComponent';
	export default class MeshRendererComponent extends NativeObject {
	    static OFFSETS: {
	        dynamicBatch: number;
	        skinHandle: number;
	        castShadow: number;
	        bindTarget: number;
	        start: number;
	        size: number;
	        materialId: number;
	        vertexBufferId: number;
	        indexBufferId: number;
	        startIndex: number;
	        numIndices: number;
	    };
	    static CREATE_FAKE(entity: Entity3D | Entity2D, options: {
	        meshCount: number;
	        uniformBlock?: UniformBlock;
	    }): FakeMeshRenderComponent;
	    get uniforms(): UniformBlock;
	    get meshCount(): number;
	    get castShadow(): boolean;
	    set castShadow(value: boolean);
	    get dynamicBatch(): boolean;
	    set dynamicBatch(value: boolean);
	    set skinSkeleton(sk: SkinnedSkeletonComponent);
	    set bindTarget(target: Entity3D | Entity2D | null);
	    get macros(): {
	        [name: string]: string | number | boolean;
	    };
	    constructor(entity: Entity3D | Entity2D, options: {
	        meshCount: number;
	        uniformBlock: UniformBlock;
	        renderType: EMeshRenderType;
	        culling?: CullingComponent;
	        macros?: {
	            [name: string]: string | number | boolean;
	        };
	    });
	    changeMacros(macros?: {
	        [name: string]: string | number | boolean;
	    }): void;
	    getStartIndex(index: number): number;
	    setStartIndex(index: number, value: number): void;
	    getNumIndices(index: number): number;
	    setNumIndices(index: number, value: number): void;
	    getVertexBuffer(index: number): VertexBuffer;
	    setVertexBuffer(index: number, buffer: VertexBuffer): void;
	    getIndexBuffer(index: number): IndexBuffer;
	    setIndexBuffer(index: number, buffer: IndexBuffer): void;
	    getVertexData(index: number): VertexData;
	    setVertexData(index: number, buffer: VertexData): void;
	    getIndexData(index: number): IndexData;
	    setIndexData(index: number, buffer: IndexData): void;
	    getMaterial(index: number): Material;
	    setMaterial(index: number, material: Material | null): void;
	    fastSet(vertexes: (VertexBuffer | VertexData)[], indexes: (VertexData | IndexBuffer)[], materials: Material[], startIndexes: number[], numIndices: number[]): void;
	    setDirty(): void;
	    copyStates(comp: MeshRendererComponent): void;
	} class FakeMeshRenderComponent extends MeshRendererComponent {
	    get uniforms(): UniformBlock;
	    set uniforms(uniforms: UniformBlock);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipModel' {
	import DataModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/DataModel';
	export default class AnimationClipModel extends DataModel {
	    setAnimationClip(ab: ArrayBuffer): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/AnimatorComponent' {
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	import Entity3D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	import AnimationClipModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipModel';
	export default class AnimatorComponent extends NativeObject {
	    static UPDATE_ANIMATORS(animators: AnimatorComponent[], size: number): void;
	    animationClipModels: AnimationClipModel[];
	    constructor();
	    bindAnimations(animationClipModels: AnimationClipModel[], entities: (Entity3D | null)[][], rootEntity?: Entity3D): void;
	    setClipParams(index: number, frameIndex: number, blendWeight: number): void;
	    getAnimationClipCount(): number;
	    getNodeCount(): number;
	    getAnimationParameter(index: number): {
	        animationClipId: number;
	        frameIndex: number;
	        percentage: number;
	    };
	    getEntity(index: number): number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/ScalableList' {
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	/**
	 * 可扩容列表，用于存储Mesh的剔除结果以及绘制数据的id。
	 */
	export default class ScalableList extends PureResource {
	    /**
	     * 当前全部可用的大小。
	     */
	    get size(): number;
	    /**
	     * 存储的id集合。
	     */
	    get dataView(): Uint32Array;
	    /**
	     * 当前已用的大小，一般不需要自己设置。
	     */
	    get usedSize(): number;
	    set usedSize(value: number);
	    constructor(initSize: number);
	    /**
	     * 扩容，将会扩大两倍，一般不需要自己调用。
	     *
	     * @param deprecatedSize will always be current size, don't use it!
	     */
	    enlarge(deprecatedSize?: number): void;
	    /**
	     * 初始化到准备`add`的阶段。
	     */
	    begin(): void;
	    /**
	     * 添加一个数据。
	     *
	     * @param deprecatedEnlargeSize will always be current size, don't use it!
	     */
	    add(id: number, deprecatedEnlargeSize?: number): void;
	    /**
	     * 结束此次所有`add`的流程。
	     */
	    end(): void;
	    /**
	     * 清空整个列表。
	     */
	    reset(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/CameraComponent' {
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	import Entity3D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	import Entity2D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity2D';
	import View from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/View';
	import ScalableList from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/ScalableList';
	export default class CameraComponent extends NativeObject {
	    static OFFSETS: {
	        size: number;
	        view: number;
	        depth: number;
	        active: number;
	        fov: number;
	        aspect: number;
	        near: number;
	        far: number;
	        up: number;
	        eye: number;
	        orthoSize: number;
	        isProjection: number;
	        cullingMask: number;
	        canvasSizeY: number;
	        targetTransform: number;
	        viewMatrix: number;
	        projectionMatrix: number;
	        viewMatrixInverse: number;
	        viewMatrix2D: number;
	        projectionMatrix2D: number;
	        viewMatrixInverse2D: number;
	        manualMatrix: number;
	        layerCullDistances: number;
	    };
	    get active(): boolean;
	    set active(value: boolean);
	    get depth(): number;
	    set depth(value: number);
	    get isProjection(): boolean;
	    set isProjection(value: boolean);
	    get view(): View;
	    set view(value: View);
	    get fov(): number;
	    set fov(value: number);
	    get aspect(): number;
	    set aspect(value: number);
	    get near(): number;
	    set near(value: number);
	    get far(): number;
	    set far(value: number);
	    get orthoSize(): number;
	    set orthoSize(value: number);
	    get cullingMask(): number;
	    set cullingMask(value: number);
	    get layerCullDistances(): Float32Array | number[];
	    set layerCullDistances(value: Float32Array | number[]);
	    get canvasSizeY(): number;
	    set canvasSizeY(value: number);
	    set targetTransform(entityId: number);
	    get targetTransform(): number;
	    set up(vec3: Float32Array);
	    constructor(entity: Entity2D | Entity3D, isUI?: boolean);
	    cull(cullResult: ScalableList, lightMode: string): void;
	    draw(renderList: ScalableList, lightMode: string): void;
	    changeProjectionMatrix(manual: boolean, mat4?: Float32Array): void;
	    changeViewMatrix(manual: boolean, mat4?: Float32Array): void;
	    updateMatrix(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/LightCameraComponent' {
	/**
	 * CameraLightComponent.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/3/2020, 7:54:13 PM
	*/
	import { EShadowMode } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	import View from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/View';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformBlock';
	import ScalableList from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/ScalableList';
	import CameraComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/CameraComponent';
	export default class LightCameraComponent extends NativeObject {
	    static OFFSETS: {
	        size: number;
	        view: number;
	        depth: number;
	        active: number;
	        shadowDistance: number;
	        shadowMode: number;
	        shadowFilterMode: number;
	        lightDir: number;
	        bounds: number;
	        lightSpaceMatrices: number;
	    };
	    get view(): View;
	    set view(value: View);
	    get active(): boolean;
	    set active(value: boolean);
	    get depth(): number;
	    set depth(value: number);
	    get shadowDistance(): number;
	    set shadowDistance(value: number);
	    get shadowFilterMode(): number;
	    set shadowFilterMode(value: number);
	    get shadowMode(): EShadowMode;
	    set shadowMode(value: EShadowMode);
	    get lightSpaceMatrices(): Float32Array;
	    constructor();
	    draw(camera: CameraComponent, renderList: ScalableList, lightMode: string): void;
	    prepareUniforms(uniforms: UniformBlock): void;
	    setLightDir(x: number, y: number, z: number): void;
	    setCascadedSplits(s0: number, s1: number, s2: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/DynamicBonesComponent' {
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	import Entity3D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	export default class DynamicBonesComponent extends NativeObject {
	    static OFFSETS: {
	        stiffness: number;
	        elasticity: number;
	        damping: number;
	    };
	    get stiffness(): number;
	    set stiffness(v: number);
	    get damping(): number;
	    set damping(v: number);
	    get elasticity(): number;
	    set elasticity(v: number);
	    constructor(rootNode?: Entity3D);
	    preUpdate(): void;
	    update(dt: number, rootMotion?: {
	        x: number;
	        y: number;
	        z: number;
	    }): void;
	    rebuild(): void;
	    resetRoot(root?: Entity3D): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/worker' {
	/**
	 * INativeWorker.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/3/2020, 4:31:17 PM
	*/
	import { IHandle, ETextureType, ETextureFormat, IRect, EMeshRenderType, INativeMap, ILongIntNativeMap, IGlyphInfo, IRenderEnv } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export interface INativeWorker {
	    createVertexLayout(options: string): IHandle;
	    createVertexDataDescriptor(options: string): IHandle;
	    createVertexBuffer(buffer: ArrayBuffer | ArrayBufferView, layout: number): IHandle;
	    updateVertexBuffer(bufferId: number, buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	    createIndexBuffer(buffer: ArrayBuffer | ArrayBufferView, is32bits?: boolean): IHandle;
	    updateIndexBuffer(bufferId: number, buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	    createVertexData(layout: number, size: number, batchDesc: number): IHandle;
	    createIndexData(size: number): IHandle;
	    createTexture(type: ETextureType, width: number, height: number, slice: number, mips: number, format: ETextureFormat, flags: number, buffer: (ArrayBuffer | ArrayBufferView)[], offsets: Uint32Array): IHandle;
	    createTexture(canvas: HTMLCanvasElement): IHandle;
	    updateTexture(id: number, level: number, slice: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, buffer: ArrayBuffer | ArrayBufferView): void;
	    updateTextureFlags(textureId: number, flags: number): void;
	    createShader(vs: string, fs: string): IHandle;
	    createUniformBlockDescriptor(descriptor: string): IHandle;
	    createUniformBlock(descriptor: number): IHandle;
	    createEffect(name: string, passCount: number, keyIndexMap: string, passes: string, shaders: string[], variants: string): IHandle & {
	        warmUp(): void;
	    };
	    createMaterial(macros: string): IHandle;
	    changeMaterialMacros(material: number, macros: string, reset?: boolean): void;
	    createScalableList(initSize: number, onBackendEnlarge: () => void): IHandle & {
	        enlarge(size: number): void;
	    };
	}
	export interface INativeWorker {
	    createView(view: string): IHandle;
	    updateViewRect(view: number, rect: IRect): void;
	    updateViewScissor(view: number, rect: IRect): void;
	}
	export interface INativeWorker {
	    createRenderPass(descriptor: string): IHandle;
	}
	export interface INativeWorker {
	    createNodePool(count: number, is3d: boolean): IHandle;
	    createNodeTree(length: number, ids: ArrayBuffer, buffer: ArrayBuffer, calculateWordMatrix: boolean, is3d?: boolean): boolean;
	}
	export namespace INativeWorker {
	    interface IAnimationClipBinding extends IHandle {
	        id: number;
	        rebind(buffer: ArrayBuffer, offset: number, cLength: number, eLength: number, removeAction: number, retainedAction: number, addedAction: number, rootEntity: number): boolean;
	        update(buffer: ArrayBuffer, offset: number, cLength: number, eLength: number, removeAction: number, retainedAction: number, addedAction: number): boolean;
	        writeDefaultValues(): void;
	    }
	}
	export interface INativeWorker {
	    createCullingComponentPool(count: number): IHandle;
	    createRenderComponent(meshCount: number, uniformBlock: number, attachedNode: number, cullingId: number, meshRenderType: EMeshRenderType, macros?: string): IHandle & {
	        setSharedDirty(): void;
	    };
	    changeMeshMacros(mesh: number, macros: string): void;
	    createAnimator(clipCount: number, nodeCount: number): IHandle;
	    updateAnimators(data: Uint32Array): void;
	    createAnimationClipBinding(buffer: ArrayBuffer, offset: number, cLength: number, eLength: number, useDefaultAddedNodesAction: number, rootEntity: number): INativeWorker.IAnimationClipBinding;
	    createAnimatorControllerModel(layerCount: number): {
	        id: number;
	        buffer: ArrayBuffer;
	        setMaskAtIndex(index: number, mask: null | ArrayBuffer, offset: number, length: number): void;
	        update(): void;
	    };
	    createAnimatorControllerStateModel(clipCount: number): {
	        id: number;
	        buffer: ArrayBuffer;
	    };
	    updateAnimatorControllers(data: Uint32Array): void;
	    createSkinning(boneCount: number, flag: number): IHandle;
	    updateSkinnings(data: Uint32Array): void;
	    createDynamicBones(rootNodeId: number): IHandle & {
	        preUpdate(): void;
	        update(dt: number, rootMotionX?: number, rootMotionY?: number, rootMotionZ?: number): void;
	        rebuild(): void;
	        resetRoot(rootId: number): void;
	    };
	}
	export interface INativeWorker {
	    createRenderCamera(attachedNode: number, isUI?: boolean): IHandle & {
	        setSharedDirty(): void;
	        updateMatrices(): void;
	    };
	    createLightCamera(): IHandle;
	}
	export interface INativeWorker {
	    createAnimationClipModel(buffer: ArrayBuffer): IHandle;
	    createBoneInverseModel(buffer: ArrayBuffer): IHandle;
	}
	export interface INativeWorker {
	    eventBusSM: ArrayBuffer;
	    dirtyNodesSM: ArrayBuffer;
	    uiRenderList: ArrayBuffer;
	    enlargeUIRenderList(): void;
	    refreshNodesWorldTransform(): void;
	}
	export interface INativeWorker {
	    loadTTFFont(buffer: ArrayBuffer, filaPath: string): string;
	    getGlyphInfo(name: string, charCode: number): IGlyphInfo;
	}
	export interface INativeWorker {
	    decodeImage(buffer: ArrayBuffer, callback: (data: ArrayBuffer | undefined, width: number, height: number) => void, premultiplyAlpha: boolean): void;
	    getRenderEnv(): IRenderEnv;
	    clearView(view: number): void;
	    cullCamera(camera: number, cullResult: number, lightMode: string): void;
	    drawCamera(camera: number, renderList: number, lightMode: string): void;
	    drawLight(light: number, camera: number, renderList: number, lightMode: string): void;
	    submit(): void;
	    createWeakRef<T>(wrapper: T): {
	        deref: () => T;
	    };
	    createWeakRefSentry(): any;
	    createNativeUUMap(): INativeMap<number>;
	    createNativeSUMap(): INativeMap<string>;
	    createNativeULUMap(): ILongIntNativeMap;
	    setNodeName(id: number, name: string): void;
	    setRenderComponentName(id: number, name: string): void;
	    debugPrint(msg: string): void;
	}
	export const worker: INativeWorker;
	export function GET_MAIN_CANVAS(): HTMLCanvasElement;
	export function IS_VALID(): boolean;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipBinding' {
	/**
	 * AnimationClipBinding.ts
	 *
	 * @Author  : jasonjwang(jasonjwang@tencent.com)
	 */
	import Entity3D from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	import AnimationClipModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipModel';
	import { EUseDefaultAddedAction } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	import { INativeWorker } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/worker';
	export default class AnimationClipBinding extends PureResource {
	    constructor(clipArray: AnimationClipModel[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<number | Entity3D | null>, entityArrayOffset: number, entityArrayLength: number, useDefaultAddedNodesAction: EUseDefaultAddedAction, rootEntity: Entity3D);
	    rebind(clipArray: AnimationClipModel[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<number | Entity3D | null>, entityArrayOffset: number, entityArrayLength: number, removeAction: number, retainedAction: number, addedAction: number, rootEntity: Entity3D): boolean;
	    update(clipArray: AnimationClipModel[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<number | Entity3D | null>, entityArrayOffset: number, entityArrayLength: number, removeAction: number, retainedAction: number, addedAction: number): boolean;
	    writeDefaultValues(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimatorControllerStateModel' {
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	import AnimationClipModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipModel';
	export default class AnimatorControllerStateModel extends PureResource {
	    readonly count: number;
	    get weight(): number;
	    set weight(weight: number);
	    get useDefault(): number;
	    set useDefault(useDefault: number);
	    constructor(count: number);
	    resetBlendInfo(): void;
	    setNextState(state: AnimatorControllerStateModel | null): void;
	    setBlendInfo(clip: AnimationClipModel, frameIndex: number, blendWeight: number, additiveReferenceClip: null | AnimationClipModel, additiveFrameIndex: number): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimatorControllerModel' {
	/**
	 * AnimatorControllerModel.ts
	 *
	 * @Author  : jasonjwang(jasonjwang@tencent.com)
	 */
	import AnimatorControllerStateModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimatorControllerStateModel';
	import PureResource from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/PureResource';
	import AnimationClipBinding from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipBinding';
	export default class AnimatorControllerModel extends PureResource {
	    layerCount: number;
	    static UPDATE_ANIMATOR_CONTROLLERS(animatorControllers: AnimatorControllerModel[], size: number): void;
	    constructor(layerCount: number);
	    setAnimationClipBinding(binding: null | AnimationClipBinding): void;
	    setLayerBlendType(layerIndex: number, blendType: number): void;
	    setLayerWeight(layerIndex: number, weight: number): void;
	    setLayerBlend(layerIndex: number, blend: null | AnimatorControllerStateModel): void;
	    setLayerMask(layerIndex: number, mask: {
	        buffer: null | ArrayBuffer;
	        offset: number;
	        length: number;
	    }): void;
	    update(): void;
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/DataBuffer' {
	/**
	 * DataBuffer.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 1:21:59 PM
	 */
	import { IHandle } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend';
	import NativeObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/NativeObject';
	export default class DataBuffer extends NativeObject {
	    constructor(nativeObj: IHandle);
	    get dataLength(): number;
	    get byteOffset(): number;
	    get arrayBuffer(): ArrayBuffer;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend' {
	import MeshRendererComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/MeshRendererComponent';
	import renderEnv from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/renderEnv';
	export { RenderEnv } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/renderEnv';
	export { default as AnimatorComponent } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/AnimatorComponent';
	export { default as CameraComponent } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/CameraComponent';
	export { default as LightCameraComponent } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/LightCameraComponent';
	export { default as CullingComponent } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/CullingComponent';
	export { default as MeshRendererComponent } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/MeshRendererComponent';
	export { default as SkinnedSkeletonComponent } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/SkinnedSkeletonComponent';
	export { default as DynamicBonesComponent } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/component/DynamicBonesComponent';
	export { default as Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity2D';
	export { default as Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/entity/Entity3D';
	export { default as AnimationClipModel } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipModel';
	export { default as AnimationClipBinding } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimationClipBinding';
	export { default as AnimatorControllerModel } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimatorControllerModel';
	export { default as AnimatorControllerStateModel } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/AnimatorControllerStateModel';
	export { default as DataBuffer } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/DataBuffer';
	export { default as DataModel } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/DataModel';
	export { default as Effect } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Effect';
	export { default as Material } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Material';
	export { default as RenderPass, IRenderPassOptions } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/RenderPass';
	export { default as SkeletonBoneInverseModel } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/SkeletonBoneInverseModel';
	export { default as Texture, ITextureOptions } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/Texture';
	export { default as UniformBlock } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformBlock';
	export { default as UniformDescriptor } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/UniformDescriptor';
	export { default as IndexBuffer } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/IndexBuffer';
	export { default as IndexData } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/IndexData';
	export { default as VertexBuffer } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexBuffer';
	export { default as VertexData } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexData';
	export { default as VertexLayout } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexLayout';
	export { default as VertexDataDescriptor } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/VertexDataDescriptor';
	export { default as View } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/View';
	export { default as ScalableList } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/resource/ScalableList'; const IS_VALID: () => boolean, GET_MAIN_CANVAS: () => HTMLCanvasElement, Image: {
	    new (): import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').IImage;
	    IS(obj: any): obj is import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').IImage;
	}; const downloader: import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').IDownloader;
	export { renderEnv };
	export { Image, downloader as Downloader, IS_VALID, GET_MAIN_CANVAS };
	export const createWeakRef: <T>(wrapper: T) => {
	    deref: () => T;
	};
	export const createWeakRefSentry: () => any;
	export const createNativeUUMap: () => import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').INativeMap<number>;
	export const createNativeSUMap: () => import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').INativeMap<string>;
	export const createNativeULUMap: () => import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').ILongIntNativeMap;
	export const loadTTFFont: (url: string, callback: (font: string) => void) => void;
	export const getGlyphInfo: (fontSetting: import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').IFontSetting, charCode: number) => import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend').IGlyphInfo;
	export const refreshNodesWorldTransform: () => void;
	export function update(delta: number): void;
	export const setNodeName: (id: number, name: string) => void;
	export const setRenderComponentName: (comp: MeshRendererComponent, name: string) => void;
	export const debugPrint: (msg: string) => void;
	export const eventBridge: {
	    bindEntityToBone: (entity: {
	        id: number;
	    }, boneEntity: {
	        id: number;
	    }) => void;
	    unbindEntityFromBone: (entity: {
	        id: number;
	    }) => void;
	    bindEntitiesToBones: (entities: {
	        id: number;
	    }[], boneEntities: {
	        id: number;
	    }[]) => void;
	    unbindEntitiesFromBones: (entities: {
	        id: number;
	    }[]) => void;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src' {
	/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/8/18 下午4:48:36
	 */
	export * from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export const VERSION = "1.0.3";
	/**
	 * 根据数据，返回二维节点对应结构的Float32array
	 */
	export function composeRawBufferEntity2D(rotation: number, position: ArrayLike<number>, scale: ArrayLike<number>): Float32Array;
	/**
	 * 根据数据，返回三维节点对应结构的Float32array，除WorldMatrix。
	 */
	export function composeRawBufferEntity3D(useEuler: boolean, rotation: ArrayLike<number>, position: ArrayLike<number>, scale: ArrayLike<number>): Float32Array;
	/**
	 * 根据数据，返回三维节点对应结构的Float32array
	 */
	export function composeRawBufferEntity3DWhole(useEuler: boolean, rotation: ArrayLike<number>, position: ArrayLike<number>, scale: ArrayLike<number>): Float32Array;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise' {
	 type ResolveTransfer<T> = (value?: T | PromiseLike<T>) => void; type RejectTransfer = (reason?: any) => void; type Callback<PromiseT, ThenT> = ((value: PromiseT) => ThenT | PromiseLike<ThenT>) | undefined | null;
	export type Executor<T> = (resolve: ResolveTransfer<T>, reject: RejectTransfer) => PromiseLike<T> | void; enum State {
	    Pending = 0,
	    Resolved = 1,
	    Rejected = 2
	}
	export default class LitePromise<T> {
	    static resolve<T>(value?: T): LitePromise<T>;
	    static reject<T = never>(value?: any): LitePromise<T>;
	    static race<T>(array: LitePromise<T>[]): LitePromise<T>;
	    static all<T>(array: PromiseLike<T>[]): LitePromise<T[]>;
	    get state(): State;
	    get pending(): boolean;
	    get resolved(): boolean;
	    get rejected(): boolean;
	    resolve: ResolveTransfer<T>;
	    reject: RejectTransfer;
	    constructor(executor?: Executor<T>, delayed?: boolean);
	    execute(): void;
	    reset(): void;
	    /**
	     * 其实完全不能精确地代表栈调用深度, 因为一个LitePromise可能会then很多个东西.
	     * 只是用来避免极端情况.
	     */
	    static roughStackDepth: number;
	    then<T1 = T, T2 = never>(onResolved?: Callback<T, T1>, onRejected?: Callback<any, T2>): LitePromise<T1 | T2>;
	    catch<T2 = never>(onRejected: Callback<any, T2>): LitePromise<T | T2>;
	    whatever(): LitePromise<void | T>;
	    finally(onFinally: () => void): this;
	}
	export const resolvedPromise: LitePromise<void>;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/task' {
	import LitePromise, { Executor } from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	export enum Status {
	    Alone = 0,
	    Queuing = 1,
	    Removed = 2,
	    Running = 3,
	    Done = 4
	}
	export class Task<T> extends LitePromise<T> {
	    priority: number;
	    status: Status;
	    startTime: number;
	    queuedTime: number;
	    stopTime: number;
	    constructor(exector: Executor<T>, priority?: number);
	    onAdd(manager: TaskManager<T>): void;
	    remove(): void;
	    run(): this;
	    reset(): void;
	}
	export class TaskManager<T> {
	    concurrency: number;
	    constructor(concurrency?: number);
	    /**
	     * 往池中添加一个任务
	     *
	     * @private
	     * @param {number} priority 该任务的优先级
	     * @param {(taskdone: () => void) => void} fn 任务函数，参数1为告知任务完成
	     * @memberof WXPriorityDownload
	     */
	    add(task: Task<T>): void;
	    remove(task: Task<T>): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/graphicResource/ResourceCreator' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	export default class ResourceCreator {
	    static createCanvas(): HTMLCanvasElement;
	    static createImage(): Kanata.IImage;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/util' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	/**
	 * 所有资源的type字段定义
	 */
	export enum ResourceType {
	    EFFECT = "effect",
	    MATERIAL = "material",
	    MESH = "mesh",
	    PREFAB = "prefab",
	    SCENE = "scene",
	    TEXTURE2D = "texture2d",
	    TEXTURECUBE = "texturecube",
	    AVATAR = "avatar",
	    ANIMATIONCLIP = "animationclip",
	    ANIMATIONCONTROLLER = "animationcontroller",
	    SPRITEFRAME = "spriteframe",
	    SCRIPT = "script",
	    TEXT = "text",
	    IMAGE = "image",
	    FONT = "font"
	}
	/**
	 * 所有资源的文件格式
	 * TODO 后续需要兼容一个资源使用多个文件或者无文件的情况，因此需要修改
	 */
	export const ResourceFileType: {
	    effect: string;
	    material: string;
	    mesh: string;
	    prefab: string;
	    scene: string;
	    texture2d: string;
	    texturecube: string;
	    avatar: string;
	    animationclip: string;
	    animatorcontroller: string;
	    resource: string;
	    spriteframe: string;
	    text: string;
	    image: string;
	    font: string;
	    script: string;
	};
	/**
	 * 两个字符串合并并确认中间有/分割
	 * @param str1
	 * @param str2
	 */
	export function join(str1: string, str2: string): string;
	export function isFileURL(url: string): boolean;
	export function replaceFileProtocol(url: string, replacer: string): string;
	export function isHTTPURL(url: string): boolean;
	export function isCloudURL(url: string): boolean;
	export function extractEnvFromCloud(url: string): string;
	export function isValidRemoteURL(url: string): boolean;
	export function isAbsoluteURL(url: string): boolean;
	/**
	 required int32 headerlength
	 required int32 filecount
	 repeated
	    int32 start
	    int32 end
	    int32 type  0 json 1 text 2 arraybuffer
	*/
	export function decodeCombinedArrayBufferFile(arrayBuffer: ArrayBuffer, index: number): any;
	export function loadFont(path: string): LitePromise<string>;
	export function arrayRemove(array: Array<any>, value: any): any[] | null; class JSONMap {
	    has(key: string): boolean;
	}
	export class ComplexJSONMap<T> extends JSONMap {
	    constructor(isString?: boolean);
	    add(key: string, data: T): void;
	    get(key: string): null | T;
	}
	export class NumberJSONMap extends JSONMap {
	    constructor(schema: string[], size?: number);
	    set(key: string, data: {
	        [key: string]: number;
	    }): void;
	    get(key: string): {
	        [key: string]: number;
	    } | null;
	    setProperty(key: string, schemaKey: string, value: number): void;
	    getProperty(key: string, schemaKey: string): number | null;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/load-file' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	export default function loadFile(path: string, type?: string): LitePromise<any>;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/base' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import { EngineError } from '!!Only Export Engine Module, Cant Use Internal Module：engine/error';
	export interface IFile {
	    type: string;
	    urls: string[];
	    path: string;
	    size: number;
	    existed: boolean;
	    loaded: boolean;
	    content: any;
	    load(): LitePromise<void>;
	    release(): void;
	}
	export enum State {
	    Unloaded = 0,
	    Downloading = 1,
	    Downloaded = 2,
	    Reading = 3,
	    Loaded = 4
	}
	export abstract class File implements IFile {
	    type: string;
	    size: number;
	    urls: string[];
	    path: string;
	    abstract get existed(): boolean;
	    get content(): any;
	    set content(content: any);
	    get loaded(): boolean;
	    get state(): State;
	    set state(value: State);
	    get error(): EngineError | null;
	    read(): LitePromise<void>;
	    abstract load(): LitePromise<void>;
	    release(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/storage' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import { UserFile } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file';
	export default abstract class FileStorage {
	    size: number;
	    count: number;
	    realSizeLimit?: number;
	    constructor(root?: string, sizeLimit?: number);
	    /**
	     * 初始化，从文件系统中获取缓存列表并删除缓存目录下路径不符合格式的非法文件。
	     *
	     * @returns {LitePromise<void[]>}
	     * @memberof CacheManager
	     */
	    init(): LitePromise<void>;
	    has(path: string): boolean;
	    get(path: string): UserFile;
	    checkSize(file: UserFile): boolean;
	    add(file: UserFile): void;
	    remove(file: UserFile): void;
	    abstract release(sizeToRelease: number): LitePromise<number>;
	    /**
	     * 清空缓存空间，删除所有的缓存文件。
	     *
	     * @returns {LitePromise<void>}
	     * @memberof CacheManager
	     */
	    clear(): LitePromise<void>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/logger' {
	 const entrance: LoggerEntrance;
	export default entrance; type LoggerTagger = (tag: string) => LoggerInstance;
	export interface LoggerInstance extends LoggerTagger {
	    /**
	     * 打印点东西
	     * 用法和 console.log 一样
	     * @param args
	     */
	    log(...args: any[]): void;
	    /**
	     * 打印点东西
	     * 和console.log不一样的是，这里可以支持只传一个返回数组的函数参数，这个数组才会是log的内容
	     * 这个函数在log标签和log等级都命中的时候才会执行
	     * 用于节省日常情况的计算量
	     * @param lazyArgs
	     */
	    log(lazyArgs: () => any[]): void;
	    info(...args: any[]): void;
	    info(lazyArgs: () => any[]): void;
	    warn(...args: any[]): void;
	    warn(lazyArgs: () => any[]): void;
	    error(...args: any[]): void;
	    error(lazyArgs: () => any[]): void;
	}
	/**
	 * 日志输出模块
	 *
	 * import Logger from '!!Only Export Engine Module, Cant Use Internal Module：../debug/logger'
	 *
	 * 创建tag为'loader'的logger对象
	 * 该logger对象打出的日志会带有'loader'这个tag
	 * const logger = Logger('loader');
	 *
	 * logger.log('xxx')
	 * logger.info('yyy')
	 * logger.warn('zzz')
	 * logger.error('www')
	 *
	 * 上述logger对象可以继续链式创建下一个logger对象
	 * 这样会打出的日志会带有'context'和'loader'两个tag
	 * const contextLogger = logger('context')
	 * contextLogger.log('aaa')
	 * contextLogger.log('bbb')
	 *
	 *
	 * 可以设置全局日志过滤器，这样仅带有某些tag的日志会输出到控制台
	 * Logger.filter = 'loader';
	 *
	 * 还可以设置全局日志级别过滤，这样仅高于该级别的日志会输出到控制台
	 * 其中打印方法对应的日志级别是：.log = 0; .info = 1; .warn = 2; .error = 3
	 * Logger.level = 0;
	 * @export
	 */
	interface LoggerEntrance extends LoggerInstance {
	    /**
	     * 日志全局设置
	     * 级别
	     * 高于该级别的日志才会在vconsole出现
	     *
	     * @static
	     * @type {number}
	     * @memberof Logger
	     */
	    level: number;
	    /**
	     * 过滤器
	     * tag满足这个过滤器的日志才会输出到控制台
	     *
	     * @static
	     * @type {number}
	     * @memberof Logger
	     */
	    filter: {
	        add(tag: string): void;
	        remove(tag: string): void;
	        clear(): void;
	    };
	    /**
	     * 输出器
	     * 设定了这个值之后，日志会在这个函数被丢出来，然后外部可以拿到日志内容用作上传
	     *
	     *
	     */
	    output: (texts: string[]) => void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/type' {
	/** Alias type for value that can be null */
	export type Nullable<T> = T | null;
	/**
	 * Alias type for number that are floats
	 * @ignorenaming
	 */
	export type float = number;
	/**
	 * Alias type for number that are doubles.
	 * @ignorenaming
	 */
	export type double = number;
	/**
	 * Alias type for number that are integer
	 * @ignorenaming
	 */
	export type int = number;
	/** Alias type for number array or Float32Array */
	export type FloatArray = number[] | Float32Array;
	/** Alias type for number array or Float32Array or Int32Array or Uint32Array or Uint16Array */
	export type IndicesArray = number[] | Int32Array | Uint32Array | Uint16Array;
	/**
	 * Alias for types that can be used by a Buffer or VertexBuffer.
	 */
	export type DataArray = number[] | ArrayBuffer | ArrayBufferView; type Primitive = undefined | null | boolean | string | number | ((...args: any[]) => any);
	/**
	 * Type modifier to make all the properties of an object Readonly
	 */
	export type Immutable<T> = T extends Primitive ? T : T extends Array<infer U> ? ReadonlyArray<U> : DeepImmutable<T>;
	/**
	 * Type modifier to make all the properties of an object Readonly recursively
	 */
	export type DeepImmutable<T> = T extends Primitive ? T : T extends Array<infer U> ? DeepImmutableArray<U> : DeepImmutableObject<T>;
	/** @hidden */
	export interface DeepImmutableArray<T> extends ReadonlyArray<DeepImmutable<T>> {
	}
	/** @hidden */
	/** @hidden */
	export type DeepImmutableObject<T> = {
	    readonly [K in keyof T]: DeepImmutable<T[K]>;
	};
	export type Never = never | undefined;
	interface CastDeepMutableArray<T> extends Array<CastDeepMutable<T>> {
	} type CastDeepMutableObject<T> = {
	    [K in keyof T]: CastDeepMutable<T[K]>;
	};
	export type CastDeepMutable<T> = T extends Primitive ? T : T extends ReadonlyArray<infer U> ? CastDeepMutableArray<U> : CastDeepMutableObject<T>;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/utils' {
	import { Immutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	export function arcTanAngle(x: number, y: number): number;
	export function isPowOf2(num: number): boolean;
	export function nearEqual(a: number, b: number): boolean;
	export function mathClamp(val: number, min: number, max: number): number;
	export function round(number: number, precision: number): number;
	export const mathHelper: {
	    arcTanAngle: typeof arcTanAngle;
	    isPowOf2: typeof isPowOf2;
	    nearEqual: typeof nearEqual;
	    mathClamp: typeof mathClamp;
	}; type F32A = Immutable<Float32Array>; type F32A_W = Float32Array;
	export const v2Helper: {
	    equal: (a: F32A, ao: number, b: F32A, bo: number) => boolean;
	    add: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    sub: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    length: (a: F32A, ao: number) => number;
	    normalize: (a: F32A, ao: number, dst: F32A_W, dsto: number) => void;
	    scale: (a: F32A, ao: number, f: number, dst: F32A_W, dsto: number) => void;
	    lerp: (a: F32A, ao: number, b: F32A, bo: number, f: number, dst: F32A_W, dsto: number) => void;
	    dot: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    isZero: (a: F32A, ao: number) => boolean;
	    getAngle: (a: F32A, ao: number) => number;
	    distance: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    copy(v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	};
	export const v3Helper: {
	    equal: (a: F32A, ao: number, b: F32A, bo: number) => boolean;
	    add: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    sub: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    length: (a: F32A, ao: number) => number;
	    normalize: (a: F32A, ao: number, dst: F32A_W, dsto: number) => void;
	    scale: (a: F32A, ao: number, f: number, dst: F32A_W, dsto: number) => void;
	    lerp: (a: F32A, ao: number, b: F32A, bo: number, f: number, dst: F32A_W, dsto: number) => void;
	    dot: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    isZero: (a: F32A, ao: number) => boolean;
	    cross: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    distance: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    angleTo: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    copy(v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	};
	export const v4Helper: {
	    equal: (a: F32A, ao: number, b: F32A, bo: number) => boolean;
	    add: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    sub: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    scale: (a: F32A, ao: number, f: number, dst: F32A_W, dsto: number) => void;
	    lerp: (a: F32A, ao: number, b: F32A, bo: number, f: number, dst: F32A_W, dsto: number) => void;
	    dot: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    isZero: (a: F32A, ao: number) => boolean;
	    copy(v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	};
	export const quatHelper: {
	    multiply: (l: F32A, lo: number, r: F32A, ro: number, dst: F32A_W, dsto: number) => void;
	    invert: (a: F32A, ao: number, dst: F32A_W, dsto: number) => void;
	    toMatrix4: (quat: F32A, quato: number, dst: F32A_W, dsto: number) => void;
	    fromMatrix4: (m: F32A, mo: number, dst: F32A_W, dsto: number) => void;
	    fromEulerAngles: (v: F32A, vo: number, dst: F32A_W, dsto: number) => void;
	    fromYawRawPitch: (yaw: number, pitch: number, roll: number, dst: F32A_W, dsto: number) => void;
	    toEulerAngles: (quat: F32A_W, quato: number, dst: F32A_W, dsto: number) => void;
	    toYawRawPitch: (quat: F32A, quato: number, dst: F32A_W, dsto: number) => void;
	    slerp: (l: F32A, lo: number, r: F32A, ro: number, t: number, dst: F32A_W, dsto: number) => Float32Array;
	    transformDirection: (quat: F32A, quato: number, v: F32A, vo: number, dst: F32A_W, dsto: number) => void;
	};
	export const m3Helper: {
	    translate: (m: F32A, mo: number, tx: number, ty: number, dst: F32A_W, dsto: number) => void;
	    scale: (m: F32A, mo: number, sx: number, sy: number, dst: F32A_W, dsto: number) => void;
	    rotate: (m: F32A, mo: number, rz: number, dst: F32A_W, dsto: number) => void;
	    inverse(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    multiply: (mA: F32A, mAo: number, mB: F32A, mBo: number, dst: F32A_W, dsto: number) => void;
	    transformPoint(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    decomposeScale(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    copy(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	};
	export const m4Helper: {
	    lookAt: (position: F32A, positionOffset: number, target: F32A, targetOffset: number, up: F32A, upOffset: number, dst: F32A_W, dsto: number) => void;
	    perspective: (fieldOfViewRadians: number, aspect: number, near: number, far: number, dst: F32A_W, dsto: number) => void;
	    orthographic: (left: number, right: number, bottom: number, top: number, near: number, far: number, dst: F32A_W, dsto: number) => void;
	    xRotation(rad: number, dst: F32A_W, dsto: number): void;
	    yRotation(rad: number, dst: F32A_W, dsto: number): void;
	    zRotation(rad: number, dst: F32A_W, dsto: number): void;
	    axisRotation(axis: F32A, axiso: number, angleInRadians: number, dst: F32A_W, dsto: number): Float32Array;
	    composeTRS: (trans: F32A, transo: number, rot: F32A, roto: number, scale: F32A, scaleo: number, dst: F32A_W, dsto: number) => void;
	    composeTQS: (trans: F32A, transo: number, quat: F32A, quato: number, scale: F32A, scaleo: number, dst: F32A_W, dsto: number) => void;
	    translate: (m: F32A, mo: number, tx: number, ty: number, tz: number, dst: F32A_W, dsto: number) => void;
	    scale: (m: F32A, mo: number, sx: number, sy: number, sz: number, dst: F32A_W, dsto: number) => void;
	    xRotate: (m: F32A, mo: number, rx: number, dst: F32A_W, dsto: number) => void;
	    yRotate: (m: F32A, mo: number, ry: number, dst: F32A_W, dsto: number) => void;
	    zRotate: (m: F32A, mo: number, rz: number, dst: F32A_W, dsto: number) => void;
	    axisRotate: (m: F32A, mo: number, axis: F32A, axiso: number, angleInRadians: number, dst: F32A_W, dsto: number) => void;
	    multiply: (mA: F32A, mAo: number, mB: F32A, mBo: number, dst: F32A_W, dsto: number) => void;
	    transformVector(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    transformDirection(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    transformPoint(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    decomposeTransRotMatScale(m: F32A, mo: number, trans: F32A_W, transo: number, rot: F32A_W, roto: number, scale: F32A_W, scaleo: number): boolean;
	    inverse(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    transpose(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    composeRST3toRST4(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    copy(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	};
	export function seedrandom(seed?: number): number;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/interface' {
	/**
	 * {@link Loader.load}加载资源时使用的选项。
	 */
	export interface ILoadOptions {
	    /**
	     * 下载失败后的重试次数。
	     *
	     * 如果`engine.config.json`里配置了多个cdn，则会按顺序依次尝试，详见[用户手册](//TODO)。
	     * @default 0
	     */
	    httpRetryCount?: number;
	    /**
	     * 下载优先级，值越大优先级越高。
	     * @default 1
	     */
	    httpPriority?: number;
	    /**
	     * 只把资源需要的文件下载到本地，不会将资源反序列化到内存。
	     * @default false
	     */
	    preload?: boolean;
	    /**
	     * 下载文件后，是否需要缓存到用户目录，下次打开小游戏可以不需要再次下载。
	     * @default false
	     */
	    cacheable?: boolean;
	    /**
	     * @unused 暂未实现。
	     */
	    useFrameSystem?: boolean;
	    /**
	     * 直接读取文件内容，而不是反序列化资源。
	     * @default false
	     */
	    raw?: boolean;
	}
	/**
	 * {@link Loader.loadFile}读取文件时使用的选项。
	 */
	export interface ILoadFileOptions {
	    /**
	     * 文件类型。
	     *
	     * 不填写的话会返回undefined。
	     */
	    filetype?: "text" | "json" | "arraybuffer" | "image" | "script" | "font";
	    /**
	     * 下载失败后的重试次数。
	     * @default 0
	     * */
	    httpRetryCount?: number;
	    /**
	     * 下载优先级，值越大优先级越高。
	     * @default 1
	     */
	    priority?: number;
	}
	export interface IResourceDefinition {
	    dependencies: string[];
	    type: string;
	}
	export interface IResourceDefinitions {
	    [id: string]: IResourceDefinition;
	}
	export interface ISimplifiedGroupManifest {
	    fileDescriptions: {
	        [id: string]: {
	            path: string;
	            index?: number;
	        };
	    };
	    resourceDefinitions: IResourceDefinitions;
	    entries?: {
	        [id: string]: string;
	    };
	}
	export interface IGroupManifest extends ISimplifiedGroupManifest {
	    files: Array<{
	        filetype: string;
	        path: string;
	        size: number;
	    }>;
	    size: number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import { ILoadOptions } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/interface';
	export interface LoadTaskInspect {
	    id: string;
	    priority: number;
	    progress: {
	        current: number;
	        total: number;
	    };
	    startTime: number;
	    endTime: number;
	    contexts: string[];
	    pendingContexts: string[];
	}
	export default class LoadTask<T> {
	    /**
	     * 获取下载进度。
	     *
	     * 不会统计每个文件内部的下载进度，只会在这个文件下载完成之后再计入进度。
	     */
	    get progress(): {
	        current: number;
	        total: number;
	    };
	    /**
	     * 用来表示加载结果的promise。
	     */
	    promise: LitePromise<T>;
	    /** 任务开始时间。 */
	    startTime: number;
	    /** 是否已被手动终止。 */
	    aborted: boolean;
	    constructor(id: string, options: ILoadOptions);
	    /**
	     * 手动终止这个加载任务。
	     */
	    abort(): void;
	}
	/**
	 * 代表一个资源的加载任务，调用{@link Loader.load}之后生成。
	 *
	 * \**文档内请勾选右上角Inherited来查看具体内容。*
	 *
	 * @template T 加载完成后返回的类型。
	 */
	export interface ILoadTask<T> extends LoadTask<T> {
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import LoadTask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task';
	export enum LoadType {
	    File = 0,
	    FileContent = 1,
	    Asset = 2
	}
	export default abstract class BaseLoadContext {
	    id: string;
	    get progress(): {
	        total: number;
	        current: number;
	    };
	    get error(): Error | null;
	    size: number;
	    get loaded(): boolean;
	    abstract load(type: LoadType): LitePromise<void>;
	    abstract getFileSrc(fileID: string): string;
	    abstract getImageSrc(fileId: string): string;
	    abstract getFile<T>(fileID: string): T | null;
	    abstract getAsset<T>(assetID: string): T | null;
	    registerTask(task: LoadTask<any>): void;
	    unregisterTask(task: LoadTask<any>): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/observable' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	/**
	 * A class serves as a medium between the observable and its observers
	 */
	export class EventState {
	    /**
	     * An Observer can set this property to true to prevent subsequent observers of being notified
	     */
	    skipNextObservers: boolean;
	    /**
	     * Get the mask value that were used to trigger the event corresponding to this EventState object
	     */
	    mask: number;
	    /**
	     * The object that originally notified the event
	     */
	    target?: any;
	    /**
	     * The current object in the bubbling phase
	     */
	    currentTarget?: any;
	    /**
	     * This will be populated with the return value of the last function that was executed.
	     * If it is the first function in the callback chain it will be the event data.
	     */
	    lastReturnValue?: any;
	    /**
	     * Create a new EventState
	     * @param mask defines the mask associated with this state
	     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
	     * @param target defines the original target of the state
	     * @param currentTarget defines the current target of the state
	     */
	    constructor(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any);
	    /**
	     * Initialize the current event state
	     * @param mask defines the mask associated with this state
	     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
	     * @param target defines the original target of the state
	     * @param currentTarget defines the current target of the state
	     * @returns the current event state
	     */
	    initalize(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any): EventState;
	}
	/**
	 * Represent an Observer registered to a given Observable object.
	 */
	export class Observer<T> {
	    /**
	     * Defines the callback to call when the observer is notified
	     */
	    callback: (eventData: T, eventState: EventState) => void;
	    /**
	     * Defines the mask of the observer (used to filter notifications)
	     */
	    mask: number;
	    /**
	     * Defines the current scope used to restore the JS context
	     */
	    scope: any;
	    /**
	     * Gets or sets a property defining that the observer as to be unregistered after the next notification
	     */
	    unregisterOnNextCall: boolean;
	    /**
	     * Creates a new observer
	     * @param callback defines the callback to call when the observer is notified
	     * @param mask defines the mask of the observer (used to filter notifications)
	     * @param scope defines the current scope used to restore the JS context
	     */
	    constructor(
	    /**
	     * Defines the callback to call when the observer is notified
	     */
	    callback: (eventData: T, eventState: EventState) => void, 
	    /**
	     * Defines the mask of the observer (used to filter notifications)
	     */
	    mask?: number, 
	    /**
	     * Defines the current scope used to restore the JS context
	     */
	    scope?: any);
	}
	/**
	 * The Observable class is a simple implementation of the Observable pattern.
	 *
	 * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
	 * This enable a more fine grained execution without having to rely on multiple different Observable objects.
	 * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
	 * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
	 */
	export class Observable<T> {
	    /**
	     * Gets the list of observers
	     */
	    get observers(): Array<Observer<T>>;
	    /**
	     * Creates a new observable
	     * @param onObserverAdded defines a callback to call when a new observer is added
	     */
	    constructor(onObserverAdded?: (observer: Observer<T>) => void);
	    /**
	     * Create a new Observer with the specified callback
	     * @param callback the callback that will be executed for that Observer
	     * @param mask the mask used to filter observers
	     * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
	     * @param scope optional scope for the callback to be called from
	     * @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification
	     * @returns the new observer created for the callback
	     */
	    add(callback: (eventData: T, eventState: EventState) => void, mask?: number, insertFirst?: boolean, scope?: any, unregisterOnFirstCall?: boolean): Observer<T>;
	    addObserver(observer: Observer<T>, insertFirst?: boolean): void;
	    /**
	     * Create a new Observer with the specified callback and unregisters after the next notification
	     * @param callback the callback that will be executed for that Observer
	     * @returns the new observer created for the callback
	     */
	    addOnce(callback: (eventData: T, eventState: EventState) => void): Nullable<Observer<T>>;
	    /**
	     * Remove an Observer from the Observable object
	     * @param observer the instance of the Observer to remove
	     * @returns false if it doesn't belong to this Observable
	     */
	    remove(observer?: Observer<T>): boolean;
	    /**
	     * Remove a callback from the Observable object
	     * @param callback the callback to remove
	     * @param scope optional scope. If used only the callbacks with this scope will be removed
	     * @returns false if it doesn't belong to this Observable
	     */
	    removeCallback(callback: (eventData: T, eventState: EventState) => void, scope?: any): boolean;
	    /**
	     * Moves the observable to the top of the observer list making it get called first when notified
	     * @param observer the observer to move
	     */
	    makeObserverTopPriority(observer: Observer<T>): void;
	    /**
	     * Moves the observable to the bottom of the observer list making it get called last when notified
	     * @param observer the observer to move
	     */
	    makeObserverBottomPriority(observer: Observer<T>): void;
	    /**
	     * Notify all Observers by calling their respective callback with the given data
	     * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
	     * @param eventData defines the data to send to all observers
	     * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
	     * @param target defines the original target of the state
	     * @param currentTarget defines the current target of the state
	     * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
	     */
	    notifyObservers(eventData: T, mask?: number, target?: any, currentTarget?: any): boolean;
	    /**
	     * Calling this will execute each callback, expecting it to be a promise or return a value.
	     * If at any point in the chain one function fails, the promise will fail and the execution will not continue.
	     * This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
	     * and it is crucial that all callbacks will be executed.
	     * The order of the callbacks is kept, callbacks are not executed parallel.
	     *
	     * @param eventData The data to be sent to each callback
	     * @param mask is used to filter observers defaults to -1
	     * @param target defines the callback target (see EventState)
	     * @param currentTarget defines he current object in the bubbling phase
	     * @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.
	     */
	    notifyObserversWithPromise(eventData: T, mask?: number, target?: any, currentTarget?: any): Promise<T>;
	    /**
	     * Notify a specific observer
	     * @param observer defines the observer to notify
	     * @param eventData defines the data to be sent to each callback
	     * @param mask is used to filter observers defaults to -1
	     */
	    notifyObserver(observer: Observer<T>, eventData: T, mask?: number): void;
	    /**
	     * Gets a boolean indicating if the observable has at least one observer
	     * @returns true is the Observable has at least one Observer registered
	     */
	    hasObservers(): boolean;
	    /**
	     * Clear the list of observers
	     */
	    clear(): void;
	    /**
	     * Clone the current observable
	     * @returns a new observable
	     */
	    clone(): Observable<T>;
	    /**
	     * Does this observable handles observer registered with a given mask
	     * @param mask defines the mask to be tested
	     * @return whether or not one observer registered with the given mask is handeled
	     */
	    hasSpecificMask(mask?: number): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Observable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/observable';
	/**
	 * Defines an array and its length.
	 * It can be helpfull to group result from both Arrays and smart arrays in one structure.
	 */
	export interface ISmartArrayLike<T> {
	    /**
	     * The data of the array.
	     */
	    data: T[];
	    /**
	     * The active length of the array.
	     */
	    length: number;
	}
	/**
	 * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
	 */
	export class SmartArray<T> implements ISmartArrayLike<T> {
	    /**
	     * The full set of data from the array.
	     */
	    data: T[];
	    /**
	     * The active length of the array.
	     */
	    length: number;
	    /**
	     * Instantiates a Smart Array.
	     * @param capacity defines the default capacity of the array.
	     */
	    constructor(capacity: number,scaleFactor?: number,releaseOnReset?: boolean);
	    /**
	     * Pushes a value at the end of the active data.
	     * @param value defines the object to push in the array.
	     */
	    push(value: T): void;
	    /**
	     * Pops a value at the end of the active data.
	     * @return defines the object to pop in the array.
	     */
	    pop(): T;
	    remove(idx: number): void;
	    /**
	     * Iterates over the active data and apply the lambda to them.
	     * @param func defines the action to apply on each value.
	     */
	    forEach(func: (content: T) => void): void;
	    /**
	     * Sorts the full sets of data.
	     * @param compareFn defines the comparison function to apply.
	     */
	    sort(compareFn: (a: T, b: T) => number): void;
	    /**
	     * Resets the active data to an empty array.
	     */
	    reset(): void;
	    /**
	     * Releases all the data from the array as well as the array.
	     */
	    dispose(): void;
	    /**
	     * Concats the active data with a given array.
	     * @param array defines the data to concatenate with.
	     */
	    concat(array: any): void;
	    /**
	     * Returns the position of a value in the active data.
	     * @param value defines the value to find the index for
	     * @returns the index if found in the active data otherwise -1
	     */
	    indexOf(value: T): number;
	    /**
	     * Returns whether an element is part of the active data.
	     * @param value defines the value to look for
	     * @returns true if found in the active data otherwise false
	     */
	    contains(value: T): boolean;
	}
	/**
	 * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
	 * The data in this array can only be present once
	 */
	export class SmartArrayNoDuplicate<T> extends SmartArray<T> {
	    /**
	     * Pushes a value at the end of the active data.
	     * THIS DOES NOT PREVENT DUPPLICATE DATA
	     * @param value defines the object to push in the array.
	     */
	    push(value: T): void;
	    pop(): T;
	    remove(idx: number): void;
	    /**
	     * Pushes a value at the end of the active data.
	     * If the data is already present, it won t be added again
	     * @param value defines the object to push in the array.
	     * @returns true if added false if it was already present
	     */
	    pushNoDuplicate(value: T): boolean;
	    /**
	     * Resets the active data to an empty array.
	     */
	    reset(): void;
	    /**
	     * Concats the active data with a given array.
	     * This ensures no dupplicate will be present in the result.
	     * @param array defines the data to concatenate with.
	     */
	    concatWithNoDuplicate(array: any): void;
	}
	export class ObservableArray<T> {
	    get data(): T[];
	    get length(): number;
	    get onAddObservable(): Observable<T>;
	    get onRemoveObservable(): Observable<T>;
	    constructor(source: T[],getter?: (item: T) => T,setter?: (item: T) => T);
	    push(value: T): void;
	    pop(): T | undefined;
	    remove(idx: number): void;
	    forEach(func: (content: T) => void): void;
	    setAtIndex(index: number, value: T): boolean;
	    getAtIndex(index: number): Nullable<T>;
	    sort(compareFn: (a: T, b: T) => number): void;
	    clear(): void;
	    indexOf(value: T): number;
	    contains(value: T): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter' {
	 class Pair<S, T> {
	    first: S;
	    second: T;
	    constructor(first: S, second: T);
	} class Node<T> {
	    static readonly Undefined: Node<any>;
	    static readonly Invalid: Node<any>;
	    element: T;
	    next: Node<T>;
	    prev: Node<T>;
	    constructor(element: T);
	} class List<T> {
	    first: Node<T>;
	    last: Node<T>;
	    size: number;
	    isEmpty(): boolean;
	    clear(cb?: (node: T) => void): void;
	    unshift(arg: T): Node<T>;
	    push(arg: T): Node<T>;
	    remove(node: Node<T>): void;
	    shift(): T | undefined;
	    pop(): T | undefined;
	    iterator(func: (Arg: T) => void, reverse?: boolean): void;
	}
	export interface EmitterOptions<S, T> {
	    onFirstListenerAdd?: (emitter: Emitter<S, T>) => any;
	    onFirstListenerDidAdd?: (emitter: Emitter<S, T>) => any;
	    onListenerDidAdd?: (emitter: Emitter<S, T>, listener: EventListener<S, T>, thisArgs: any) => any;
	    onLastListenerRemove?: (emitter: Emitter<S, T>) => any;
	}
	export interface IDisposable {
	    dispose(): void;
	} type EventListener<S, T> = (target: S, arg: T) => void;
	interface IEvent<S, T> {
	    add: (listener: EventListener<S, T>, thisArgs?: any) => Node<Pair<EventListener<S, T>, any>> | undefined;
	    remove: (node?: Node<Pair<EventListener<S, T>, any>>) => void;
	}
	export type Listener<S, T = void> = Node<Pair<EventListener<S, T>, any>>;
	export class Emitter<S, T = void> implements IEvent<S, T>, IDisposable {
	    constructor(options?: EmitterOptions<S, T>);
	    add(listener: EventListener<S, T>, thisArgs?: any): Listener<S, T> | undefined;
	    remove(node?: Listener<S, T>): void;
	    fireUnsafe(first: S, second: T): void;
	    fire(first: S, second: T): void;
	    dispose(): void;
	    isEmpty(): boolean;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/event' {
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	export enum MaterialEventType {
	    RenderQueueChange = 0,
	    RenderStateChange = 1,
	    DefinationChange = 2,
	    TextureChange = 3
	}
	export enum MeshEventType {
	    SubMeshModified = 0,
	    SubMeshCountChanged = 1,
	    BoundBallChanged = 2,
	    BoundBoxChanged = 3
	}
	export enum BoundsChangeEventType {
	    SizeChange = 0,
	    AnchorChange = 1,
	    HitAreaChange = 2
	}
	export enum ChildChangeEventType {
	    Add = 0,
	    Remove = 1
	}
	export enum LightEventType {
	    Added = 0,
	    Removed = 1
	}
	export enum Renderable2DEventType {
	    Added = 0,
	    Removed = 1,
	    Moved = 2,
	    Modified = 3,
	    VertexChange = 4,
	    MaterialChange = 5
	}
	export enum UILayerChangeType {
	    Added = 0,
	    Removed = 1,
	    Modified = 2,
	    SiblingIndex = 3,
	    SubTreeUpdate = 4,
	    VisibleChange = 5
	}
	export enum MeshRendererEventType {
	    Added = 0,
	    Removed = 1,
	    Modified = 2,
	    SubMeshModified = 3,
	    CastShadowModified = 4
	}
	export enum PipeLineEventType {
	    ClearAllCache = 0
	}
	export const RenderSizeChangeEvent: Emitter<number, number>;
	export const FrameSizeChangeEvent: Emitter<number, number>;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color' {
	export enum BlendType {
	    Alpha = 0,
	    RGB = 1,
	    RGBA = 2,
	    None = 3
	}
	export const GetColorFromHex: (str: any) => number;
	/**
	 * @public
	 */
	export default class Color {
	    get r(): number;
	    set r(val: number);
	    get g(): number;
	    set g(val: number);
	    get b(): number;
	    set b(val: number);
	    get a(): number;
	    set a(val: number);
	    static get WHITE(): Color;
	    static get BLACK(): Color;
	    static get TRANSPARENT(): Color;
	    static BlendType: typeof BlendType;
	    static blendColorHex(colorHexA: number, colorHexB: number, type?: BlendType): number;
	    static multiplyColorHex(colorHexA: number, colorHexB: number, type?: BlendType): number;
	    static getValue32FromRGBA(r: number, g: number, b: number, a: number): number;
	    static randomMix(colorHexA: number, colorHexB: number, randomSeed?: number): number;
	    static fromHex(hex: number): Color;
	    static fromHexString(hexString: string): Color;
	    static fromFloatArray(arr: number[]): Color;
	    constructor(r?: number, g?: number, b?: number, a?: number);
	    clone(): Color;
	    equals(target: Color): boolean;
	    set(val: Color): void;
	    setRGBA(r: number, g: number, b: number, a: number): void;
	    setValue32(v32: number): void;
	    toNormalizedArray(): [number, number, number, number];
	    toRGBAString(): string;
	    mix(color: Color, dst?: Color): Color;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2' {
	import { V2ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	/**
	 * @public
	 */
	export default class Vector2 {
	    /**
	     * x值
	     *
	     * @type {number}
	     * @memberof Vector2
	     */
	    get x(): number;
	    set x(val: number);
	    /**
	     * y值
	     *
	     * @type {number}
	     * @memberof Vector2
	     */
	    get y(): number;
	    set y(val: number);
	    /**
	     * 零向量，不要对该对象进行修改
	     *
	     * @readonly
	     * @static
	     * @type {V3ReadOnly}
	     * @memberof Vector3
	     */
	    static readonly ZERO: V2ReadOnly;
	    /**
	     * 一向量，不要对该对象进行修改
	     *
	     * @readonly
	     * @static
	     * @type {V3ReadOnly}
	     * @memberof Vector3
	     */
	    static readonly ONE: V2ReadOnly;
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 使用数值创建
	     * 推荐使用这种方式代替new Vector2
	     *
	     * @static
	     * @param {number} x x
	     * @param {number} y y
	     * @returns {Vector2} 创建出来的向量
	     * @memberof Vector2
	     */
	    static createFromNumber(x: number, y: number): Vector2;
	    /**
	     * 使用一个数组创建
	     * 此操作会拷贝一份数组
	     *
	     * @static
	     * @param {number[]} array 数据源，长度必须为2，否则会抛出异常
	     * @returns {Vector2} 创建出来的向量
	     * @memberof Vector2
	     */
	    static createFromArray(array: number[]): Vector2;
	    /**
	     * 使用某个已有的typedArray创建
	     * 此操作不会拷贝数据，而是在原来的内存区域上操作
	     *
	     * @static
	     * @param {Float32Array} array 数据源
	     * @param {number} [offset=0] 数据源中的偏移
	     * @returns {Vector2} 创建出来的向量
	     * @memberof Vector2
	     */
	    static createFromTypedArray(array: Float32Array, offset?: number): Vector2;
	    /**
	     * 返回向量数据
	     *
	     * @returns {number[]} 矩阵数据，以JSArray返回
	     * @memberof Vector2
	     */
	    toArray(): number[];
	    /**
	     * 判断与目标向量的值是否相等
	     *
	     * @param {V2ReadOnly} v 目标向量
	     * @returns {boolean} 是否相等，这里误差小于10^-6视为相等
	     * @memberof Vector2
	     */
	    equal(v: V2ReadOnly): boolean;
	    /**
	     * 拷贝目标向量的值到该向量
	     *
	     * @param {V2ReadOnly} val 目标向量
	     * @returns {Vector2} 自身
	     * @memberof Vector2
	     */
	    set(val: V2ReadOnly): Vector2;
	    /**
	     * 设置向量的值
	     *
	     * @param {number} x x值
	     * @param {number} y y值
	     * @returns {Vector2} 自身
	     * @memberof Vector2
	     */
	    setValue(x: number, y: number): Vector2;
	    /**
	     * 向量加法
	     *
	     * @param {V2ReadOnly} v 目标向量
	     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector2} 计算结果
	     * @memberof Vector2
	     */
	    add(v: V2ReadOnly, dst?: Vector2): Vector2;
	    /**
	     * 向量减法
	     *
	     * @param {V2ReadOnly} v 目标向量
	     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector2} 计算结果
	     * @memberof Vector2
	     */
	    sub(v: V2ReadOnly, dst?: Vector2): Vector2;
	    /**
	     * 向量归一化，如该向量为零向量，则结果依然为零向量
	     *
	     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector2} 计算结果
	     * @memberof Vector2
	     */
	    normalize(dst?: Vector2): Vector2;
	    /**
	     * 向量缩放
	     *
	     * @param {number} f 缩放比
	     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector2} 计算结果
	     * @memberof Vector2
	     */
	    scale(f: number, dst?: Vector2): Vector2;
	    /**
	     * 在该向量与目标向量之间计算插值
	     *
	     * @param {V2ReadOnly} v 目标向量
	     * @param {number} f 插值系数
	     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector2} 计算结果
	     * @memberof Vector2
	     */
	    lerp(v: V2ReadOnly, f: number, dst?: Vector2): Vector2;
	    /**
	     * 取反
	     * @returns
	     */
	    negate(): this;
	    /**
	     * 向量点乘
	     *
	     * @param {V2ReadOnly} v 目标向量
	     * @returns {number} 计算结果
	     * @memberof Vector2
	     */
	    dot(v: V2ReadOnly): number;
	    /**
	     * 向量的模
	     *
	     * @returns {number} 计算结果
	     * @memberof Vector2
	     */
	    length(): number;
	    /**
	     * 拷贝该向量
	     *
	     * @returns {Vector2} 拷贝出来的对象
	     * @memberof Vector2
	     */
	    clone(): Vector2;
	    /**
	     * 是否为零向量
	     *
	     * @returns {boolean}
	     * @memberof Vector2
	     */
	    isZero(): boolean;
	    /**
	     * 获取向量旋转角，以角度表示
	     *
	     * @returns {number} 旋转角，以角度表示
	     * @memberof Vector2
	     */
	    getAngle(): number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix3' {
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { M3ReadOnly, V2ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export default class Matrix3 {
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 单位矩阵
	     *
	     * @readonly
	     * @static
	     * @returns {Matrix3} 单位矩阵，每次返回都会创建新的对象
	     * @memberof Matrix3
	     */
	    static get IDENTITY(): Matrix3;
	    /**
	     * 使用一个数组创建
	     * 此操作会拷贝一份数组
	     *
	     * @static
	     * @param {number[]} array 数据源，长度必须为9，否则会抛出异常
	     * @returns {Matrix3} 创建出来的矩阵
	     * @memberof Matrix3
	     */
	    static createFromArray(array: number[]): Matrix3;
	    /**
	     * 使用某个已有的typedArray创建
	     * 此操作不会拷贝数据，而是在原来的内存区域上操作
	     *
	     * @static
	     * @param {Float32Array} array 数据源
	     * @param {number} [offset=0] 数据源中的偏移
	     * @returns {Matrix3} 创建出来的矩阵
	     * @memberof Matrix3
	     */
	    static createFromTypedArray(array: Float32Array, offset?: number): Matrix3;
	    /**
	     * 返回矩阵数据
	     *
	     * @returns {number[]} 矩阵数据，以JSArray返回
	     * @memberof Matrix3
	     */
	    toArray(): number[];
	    /**
	     * 将该矩阵进行位移变换
	     *
	     * @param {number} tx x轴位移
	     * @param {number} ty y轴位移
	     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix3} 计算结果
	     * @memberof Matrix3
	     */
	    translate(tx: number, ty: number, dst?: Matrix3): Matrix3;
	    /**
	     * 将该矩阵进行缩放变换
	     *
	     * @param {number} sx x轴缩放
	     * @param {number} sy y轴缩放
	     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix3} 计算结果
	     * @memberof Matrix3
	     */
	    scale(sx: number, sy: number, dst?: Matrix3): Matrix3;
	    /**
	     * 将该矩阵进行旋转变换
	     *
	     * @param {number} radians 旋转幅度，用弧度表示
	     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix3} 计算结果
	     * @memberof Matrix3
	     */
	    rotate(radians: number, dst?: Matrix3): Matrix3;
	    /**
	     * 求该矩阵的逆
	     *
	     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix3} 计算结果
	     * @memberof Matrix3
	     */
	    inverse(dst?: Matrix3): Matrix3;
	    /**
	     * 将该矩阵与另一个矩阵相乘
	     *
	     * @param {Matrix3} m 右乘矩阵
	     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix3} 计算结果
	     * @memberof Matrix3
	     */
	    multiply(m: M3ReadOnly, dst?: Matrix3): Matrix3;
	    /**
	     * 矩阵变换作用于点
	     *
	     * @param {Vector2} v 点
	     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector2} 计算结果
	     * @memberof Matrix3
	     */
	    transformPoint(v: V2ReadOnly, dst?: Vector2): Vector2;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export default class BoundBall {
	    static readonly OFFSETS: Readonly<{
	        center: number;
	        radius: number;
	    }>;
	    /**
	     * 包围球中心
	     *
	     * @type {V3ReadOnly}
	     * @memberof BoundBall
	     */
	    get center(): V3ReadOnly;
	    set center(val: V3ReadOnly);
	    /**
	     * 包围球半径
	     *
	     * @type {number}
	     * @memberof BoundBall
	     */
	    get radius(): number;
	    set radius(val: number);
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 使用中心和半径创建包围球
	     *
	     * @static
	     * @param {V3ReadOnly} center
	     * @param {number} radius
	     * @returns {BoundBall}
	     * @memberof BoundBall
	     */
	    static createFromCenterAndRadius(center: V3ReadOnly, radius: number): BoundBall;
	    /**
	     * 设置值
	     *
	     * @param {V3ReadOnly} center
	     * @param {number} radius
	     * @returns {BoundBall}
	     * @memberof BoundBall
	     */
	    setValue(center: V3ReadOnly, radius: number): BoundBall;
	    /**
	     * 使用一系列点初始化
	     *
	     * @param {V3ReadOnly[]} points
	     * @returns {BoundBall} 自身
	     * @memberof BoundBall
	     */
	    initByPoints(points: V3ReadOnly[]): BoundBall;
	    initByPointRadius(center: V3ReadOnly, radius: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBox' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export default class BoundBox {
	    static readonly OFFSETS: Readonly<{
	        center: number;
	        size: number;
	    }>;
	    /**
	     * 包围盒中心
	     *
	     * @type {Vector3}
	     * @memberof BoundBox
	     */
	    get center(): V3ReadOnly;
	    set center(val: V3ReadOnly);
	    /**
	     * 包围盒尺寸
	     *
	     * @memberof BoundBox
	     */
	    get size(): V3ReadOnly;
	    set size(val: V3ReadOnly);
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 使用中心和尺寸创建包围球
	     *
	     * @static
	     * @param {V3ReadOnly} center 中心
	     * @param {V3ReadOnly} size 尺寸
	     * @returns {BoundBall}
	     * @memberof BoundBall
	     */
	    static createFromCenterAndSize(center: V3ReadOnly, size: V3ReadOnly): BoundBox;
	    /**
	     * 设置值
	     *
	     * @param {V3ReadOnly} center
	     * @param {V3ReadOnly} size
	     * @returns {BoundBox}
	     * @memberof BoundBox
	     */
	    setValue(center: V3ReadOnly, size: V3ReadOnly): BoundBox;
	    initByPoints(points: Vector3[], length?: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types' {
	import { DeepImmutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; type Vector2 = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2').default; type Vector3 = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3').default; type Vector4 = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4').default; type Quaternion = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion').default; type Matrix3 = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix3').default; type Matrix4 = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4').default; type BoundBall = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall').default; type BoundBox = import('!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBox').default;
	export type V2ReadOnly = DeepImmutable<Vector2>;
	export type V3ReadOnly = DeepImmutable<Vector3>;
	export type V4ReadOnly = DeepImmutable<Vector4>;
	export type QuatReadOnly = DeepImmutable<Quaternion>;
	export type M3ReadOnly = DeepImmutable<Matrix3>;
	export type M4ReadOnly = DeepImmutable<Matrix4>;
	export type BoundBallReadOnly = DeepImmutable<BoundBall>;
	export type BoundBoxReadOnly = DeepImmutable<BoundBox>;
	export type NumberReadOnly = DeepImmutable<number>;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4' {
	import { V4ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export default class Vector4 {
	    /**
	     * x值
	     *
	     * @type {number}
	     * @memberof Vector4
	     */
	    get x(): number;
	    set x(val: number);
	    /**
	     * y值
	     *
	     * @type {number}
	     * @memberof Vector4
	     */
	    get y(): number;
	    set y(val: number);
	    /**
	     * z值
	     *
	     * @type {number}
	     * @memberof Vector4
	     */
	    get z(): number;
	    set z(val: number);
	    /**
	     * w值
	     *
	     * @type {number}
	     * @memberof Vector4
	     */
	    get w(): number;
	    set w(val: number);
	    /**
	     * 零向量，不要对该对象进行修改
	     *
	     * @static
	     * @readonly
	     * @type {V4ReadOnly}
	     * @memberof Vector4
	     */
	    static readonly ZERO: V4ReadOnly;
	    /**
	     * 一向量，不要对该对象进行修改
	     *
	     * @readonly
	     * @static
	     * @type {V3ReadOnly}
	     * @memberof Vector3
	     */
	    static readonly ONE: V4ReadOnly;
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 使用数值创建
	     * 推荐使用这种方式代替new Vector4
	     *
	     * @static
	     * @param {number} x
	     * @param {number} y
	     * @param {number} z
	     * @param {number} w
	     * @returns {Vector4} 创建出来的向量
	     * @memberof Vector4
	     */
	    static createFromNumber(x: number, y: number, z: number, w: number): Vector4;
	    /**
	     * 使用一个数组创建
	     * 此操作会拷贝一份数组
	     *
	     * @static
	     * @param {number[]} array 数据源，长度必须为4，否则会抛出异常
	     * @returns {Vector4} 创建出来的向量
	     * @memberof Vector4
	     */
	    static createFromArray(array: number[]): Vector4;
	    /**
	     * 使用某个已有的typedArray创建
	     * 此操作不会拷贝数据，而是在原来的内存区域上操作
	     *
	     * @static
	     * @param {Float32Array} array 数据源
	     * @param {number} [offset=0] 数据源中的偏移
	     * @returns {Vector4}
	     * @memberof Vector4
	     */
	    static createFromTypedArray(array: Float32Array, offset?: number): Vector4;
	    /**
	     * 返回向量数据
	     *
	     * @returns {number[]} 矩阵数据，以JSArray返回
	     * @memberof Vector4
	     */
	    toArray(): number[];
	    /**
	     * 判断与目标向量的值是否相等
	     *
	     * @param {V4ReadOnly} v 目标向量
	     * @returns {boolean} 是否相等，这里误差小于10^-6视为相等
	     * @memberof Vector4
	     */
	    equal(v: V4ReadOnly): boolean;
	    /**
	     * 拷贝目标向量的值到该向量
	     *
	     * @param {V4ReadOnly} val 目标向量
	     * @returns {Vector4} 自身
	     * @memberof Vector4
	     */
	    set(v: V4ReadOnly): Vector4;
	    /**
	     * 设置向量的值
	     *
	     * @param {number} x x值
	     * @param {number} y y值
	     * @param {number} z z值
	     * @param {number} w w值
	     * @returns {Vector4} 自身
	     * @memberof Vector4
	     */
	    setValue(x: number, y: number, z: number, w: number): Vector4;
	    /**
	     * 向量加法
	     *
	     * @param {V4ReadOnly} v 目标向量
	     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector4} 计算结果
	     * @memberof Vector4
	     */
	    add(v: V4ReadOnly, dst?: Vector4): Vector4;
	    /**
	     * 向量减法
	     *
	     * @param {V4ReadOnly} v 目标向量
	     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector4} 计算结果
	     * @memberof Vector4
	     */
	    sub(v: V4ReadOnly, dst?: Vector4): Vector4;
	    /**
	     * 向量缩放
	     *
	     * @param {number} f 缩放比
	     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector4} 计算结果
	     * @memberof Vector4
	     */
	    scale(f: number, dst?: Vector4): Vector4;
	    /**
	     * 在该向量与目标向量之间计算插值
	     *
	     * @param {V4ReadOnly} v 目标向量
	     * @param {number} f 插值系数
	     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector4} 计算结果
	     * @memberof Vector4
	     */
	    lerp(v: V4ReadOnly, f: number, dst?: Vector4): Vector4;
	    /**
	     * 取反
	     * @returns
	     */
	    negate(): this;
	    /**
	     * 向量点乘
	     *
	     * @param {V4ReadOnly} v 目标向量
	     * @returns {number} 计算结果
	     * @memberof Vector4
	     */
	    dot(v: V4ReadOnly): number;
	    /**
	     * 是否为零向量
	     *
	     * @returns {boolean}
	     * @memberof Vector4
	     */
	    isZero(): boolean;
	    /**
	     * 拷贝该向量
	     *
	     * @returns {Vector4} 拷贝出来的对象
	     * @memberof Vector4
	     */
	    clone(): Vector4;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Vector4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4';
	import { V3ReadOnly, V4ReadOnly, QuatReadOnly, M3ReadOnly, M4ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	/**
	 * @public
	 */
	export default class Matrix4 {
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 单位矩阵
	     *
	     * @readonly
	     * @static
	     * @returns {Matrix4} 单位矩阵，每次返回都会创建新的对象
	     * @memberof Matrix4
	     */
	    static get IDENTITY(): Matrix4;
	    /**
	     * 构造相机矩阵
	     *
	     * @static
	     * @param {Vector3} position 相机位置
	     * @param {Vector3} target 相机目标位置
	     * @param {Vector3} up 上方向
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static lookAt(position: V3ReadOnly, target: V3ReadOnly, up: V3ReadOnly, dst?: Matrix4): Matrix4;
	    /**
	     * 构造透视投影矩阵
	     *
	     * @static
	     * @param {number} fieldOfViewRadians 视野大小，用弧度表示
	     * @param {number} aspect 宽高比
	     * @param {number} near 近平面
	     * @param {number} far 远平面
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static perspective(fieldOfViewRadians: number, aspect: number, near: number, far: number, dst?: Matrix4): Matrix4;
	    /**
	     * 构造正交投影矩阵
	     *
	     * @static
	     * @param {number} left 左平面
	     * @param {number} right 右平面
	     * @param {number} bottom 上平面
	     * @param {number} top 下平面
	     * @param {number} near 近平面
	     * @param {number} far 远平面
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static orthographic(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将四元数转换为旋转矩阵
	     *
	     * @static
	     * @param {Quaternion} quat 四元数
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static fromQuaternion(quat: QuatReadOnly, dst?: Matrix4): Matrix4;
	    /**
	     * 使用一个数组创建
	     * 此操作会拷贝一份数组
	     *
	     * @static
	     * @param {number[]} array 数据源，长度必须为16，否则会抛出异常
	     * @returns {Matrix4} 创建出来的矩阵
	     * @memberof Matrix4
	     */
	    static createFromArray(array: number[]): Matrix4;
	    /**
	     * 使用某个已有的typedArray创建
	     * 此操作不会拷贝数据，而是在原来的内存区域上操作
	     *
	     * @static
	     * @param {Float32Array} array 数据源
	     * @param {number} [offset=0] 数据源中的偏移
	     * @returns {Matrix4} 创建出来的矩阵
	     * @memberof Matrix4
	     */
	    static createFromTypedArray(array: Float32Array, offset?: number): Matrix4;
	    /**
	     * 创建绕X轴旋转的矩阵
	     *
	     * @static
	     * @param {number} rad 旋转幅度，用弧度表示
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static createRotationX(rad: number, dst?: Matrix4): Matrix4;
	    /**
	     * 创建绕Y轴旋转的矩阵
	     *
	     * @static
	     * @param {number} rad 旋转幅度，用弧度表示
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static createRotationY(rad: number, dst?: Matrix4): Matrix4;
	    /**
	     * 创建绕Z轴旋转的矩阵
	     *
	     * @static
	     * @param {number} rad 旋转轴
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static createRotationZ(rad: number, dst?: Matrix4): Matrix4;
	    /**
	     * 创建绕指定轴旋转的矩阵
	     *
	     * @static
	     * @param {Vector3} axis 旋转轴
	     * @param {number} angleInRadians 旋转幅度，用弧度表示
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static createRotationAxis(axis: V3ReadOnly, angleInRadians: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将位移旋转缩放合成一个RST矩阵，旋转用矩阵表示
	     *
	     * @static
	     * @param {V3ReadOnly} translation 位移向量
	     * @param {M4ReadOnly} rotation 旋转矩阵
	     * @param {V3ReadOnly} scale 缩放向量
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static composeTRS(translation: V3ReadOnly, rotation: M4ReadOnly, scale: V3ReadOnly, dst?: Matrix4): Matrix4;
	    /**
	     * 将位移旋转缩放合成一个RST矩阵，旋转用四元数表示
	     *
	     * @static
	     * @param {V3ReadOnly} translation 位移向量
	     * @param {QuatReadOnly} rotation 旋转四元数
	     * @param {V3ReadOnly} scale 缩放向量
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static composeTQS(translation: V3ReadOnly, rotation: QuatReadOnly, scale: V3ReadOnly, dst?: Matrix4): Matrix4;
	    /**
	     * 从二维RST矩阵扩展到三维RST矩阵
	     *
	     * @static
	     * @param {Matrix3} m3 二维RST矩阵
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    static composeFromRST3(m3: M3ReadOnly, dst?: Matrix4): Matrix4;
	    /**
	     * 返回矩阵数据
	     *
	     * @returns {number[]} 矩阵数据，以JSArray返回
	     * @memberof Matrix4
	     */
	    toArray(): number[];
	    /**
	     * 将该矩阵进行位移变换
	     *
	     * @param {number} tx x轴位移
	     * @param {number} ty y轴位移
	     * @param {number} tz z轴位移
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    translate(tx: number, ty: number, tz: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将该矩阵进行缩放变换
	     *
	     * @param {number} sx x轴缩放
	     * @param {number} sy y轴缩放
	     * @param {number} sz z轴缩放
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    scale(sx: number, sy: number, sz: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将该矩阵绕x轴旋转
	     *
	     * @param {number} rx 旋转幅度，用弧度表示
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    xRotate(rx: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将该矩阵绕y轴旋转
	     *
	     * @param {number} ry 旋转幅度，用弧度表示
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    yRotate(ry: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将该矩阵绕z轴旋转
	     *
	     * @param {number} rz 旋转幅度，用弧度表示
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    zRotate(rz: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将该矩阵绕指定轴旋转
	     *
	     * @param {Vector3} axis 轴向量
	     * @param {number} angleInRadians 旋转幅度，用弧度表示
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    axisRotate(axis: V3ReadOnly, angleInRadians: number, dst?: Matrix4): Matrix4;
	    /**
	     * 将该矩阵使用指定四元数旋转
	     *
	     * @param {Quaternion} quaternion 四元数
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    rotateByQuaternion(quaternion: QuatReadOnly, dst?: Matrix4): Matrix4;
	    /**
	     * 求该矩阵的逆
	     *
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    inverse(dst?: Matrix4): Matrix4;
	    /**
	     * 求该矩阵的转置
	     *
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    transpose(dst?: Matrix4): Matrix4;
	    /**
	     * 将该矩阵与另一个矩阵相乘
	     *
	     * @param {Matrix4} m 右乘矩阵
	     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Matrix4} 计算结果
	     * @memberof Matrix4
	     */
	    multiply(m: M4ReadOnly, dst?: Matrix4): Matrix4;
	    /**
	     * 矩阵变换作用于向量
	     *
	     * @param {Vector4} v 向量
	     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector4} 计算结果
	     * @memberof Matrix4
	     */
	    transformVector(v: V4ReadOnly, dst?: Vector4): Vector4;
	    /**
	     * 矩阵变换作用于方向
	     *
	     * @param {Vector3} dir 方向
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Matrix4
	     */
	    transformDirection(dir: V3ReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 矩阵变换作用于点
	     *
	     * @param {Vector3} p 点
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Matrix4
	     */
	    transformPoint(p: V3ReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 拷贝目标矩阵的值到该矩阵
	     *
	     * @param {M4ReadOnly} val 目标
	     * @returns {Matrix4} 自身
	     * @memberof Matrix4
	     */
	    set(val: M4ReadOnly): Matrix4;
	    /**
	     * 拷贝该矩阵
	     *
	     * @returns {Matrix4} 拷贝出来的对象
	     * @memberof Matrix4
	     */
	    clone(): Matrix4;
	    /**
	     * 分解RTS矩阵为位移、旋转、缩放向量，返回是否成功
	     *
	     * @param {Vector3} dstTranslation 目标位移向量
	     * @param {Matrix4} dstRotationMatrix 目标旋转矩阵
	     * @param {Vector3} dstScale 目标缩放分量
	     * @returns {boolean} 分解是否成功，如不成功，可能是缩放分量为0
	     * @memberof Matrix4
	     */
	    decomposeTransRotMatScale(dstTranslation: Vector3, dstRotationMatrix: Matrix4, dstScale: Vector3): boolean;
	    /**
	     * 设置该矩阵某行某列的值
	     *
	     * @param {number} value 值
	     * @param {number} column 列数
	     * @param {number} row 行数
	     * @returns {Matrix4} 自身
	     * @memberof Matrix4
	     */
	    setValue(value: number, column: number, row: number): Matrix4;
	    /**
	     * 获取矩阵某行某列的值
	     *
	     *
	     * @param {number} column 列数
	     * @param {number} row 行数
	     * @returns {number} 自身
	     * @memberof Matrix4
	     */
	    getValue(column: number, row: number): number;
	    /**
	     * 设置矩阵某列
	     *
	     * @param {V4ReadOnly} vec 列向量
	     * @param {number} column 列数
	     * @returns {Matrix4} 自身
	     * @memberof Matrix4
	     */
	    setColumn(vec: V4ReadOnly, column: number): Matrix4;
	    /**
	     * 获取矩阵某列
	     *
	     * @param {number} column 列数
	     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector4} 该列数据
	     * @memberof Matrix4
	     */
	    getColumn(column: number, dst?: Vector4): Vector4;
	    /**
	     * 设置矩阵某行
	     *
	     * @param {V4ReadOnly} vec 行向量
	     * @param {number} row 行数
	     * @returns {Matrix4} 自身
	     * @memberof Matrix4
	     */
	    setRow(vec: V4ReadOnly, row: number): Matrix4;
	    /**
	     * 获取矩阵某行
	     *
	     * @param {number} row 行数
	     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector4} 该行数据
	     * @memberof Matrix4
	     */
	    getRow(row: number, dst?: Vector4): Vector4;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/physicsPool' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Quaternion from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion'; abstract class PhysicsPool<T, N> {
	    size: number;
	    pools: Array<Array<N>>;
	    constructor(size?: number);
	    get(): N;
	    from(origin: T): N;
	    clear(): void;
	    abstract assign(dst: N, origin: T): any;
	}
	export class PhysicsVec3Pool extends PhysicsPool<Vector3, phys3D.RawVec3f> {
	    assign(dst: phys3D.RawVec3f, origin: Vector3): void;
	}
	export class PhysicsQuaternionPool extends PhysicsPool<Quaternion, phys3D.RawQuaternion> {
	    assign(dst: phys3D.RawQuaternion, origin: Quaternion): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { V3ReadOnly, QuatReadOnly, M4ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	/**
	 * @public
	 */
	export default class Quaternion {
	    /**
	     * x值
	     *
	     * @type {number}
	     * @memberof Quaternion
	     */
	    get x(): number;
	    set x(val: number);
	    /**
	     * y值
	     *
	     * @type {number}
	     * @memberof Quaternion
	     */
	    get y(): number;
	    set y(val: number);
	    /**
	     * z值
	     *
	     * @type {number}
	     * @memberof Quaternion
	     */
	    get z(): number;
	    set z(val: number);
	    /**
	     * w值
	     *
	     * @type {number}
	     * @memberof Quaternion
	     */
	    get w(): number;
	    set w(val: number);
	    /**
	     * 默认四元数，不要对该对象进行修改
	     *
	     * @readonly
	     * @static
	     * @type {QuatReadOnly}
	     * @memberof Quaternion
	     */
	    static readonly DEFAULT: QuatReadOnly;
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 从欧拉角创建四元数
	     *
	     * @static
	     * @param {Vector3} euler 欧拉角，x代表pitch，y代表yaw，z代表roll
	     * @param {Quaternion} [dst]
	     * @returns {Quaternion}
	     * @memberof Quaternion
	     */
	    static fromEulerAngles(euler: V3ReadOnly, dst?: Quaternion): Quaternion;
	    /**
	     * 从旋转矩阵创建
	     *
	     * @static
	     * @param {Matrix4} mat
	     * @param {Quaternion} [dst]
	     * @returns {Quaternion}
	     * @memberof Quaternion
	     */
	    static createFromMatrix4(mat: M4ReadOnly, dst?: Quaternion): Quaternion;
	    /**
	     * 从轴向旋转创建
	     *
	     * @static
	     * @param {V3ReadOnly} axis 旋转轴
	     * @param {number} rad 旋转幅度
	     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Quaternion} 计算结果
	     * @memberof Quaternion
	     */
	    static createFromAxisAngle(axis: V3ReadOnly, rad: number, dst?: Quaternion): Quaternion;
	    /**
	     * 由视角方向创建四元数
	     *
	     * @static
	     * @param {V3ReadOnly} forward 前方向
	     * @param {V3ReadOnly} up 上方向
	     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Quaternion} 计算结果
	     * @memberof Quaternion
	     */
	    static lookRotation(forward: V3ReadOnly, up: V3ReadOnly, dst?: Quaternion): Quaternion;
	    /**
	     * 使用数值创建
	     *
	     * @static
	     * @param {number} x x
	     * @param {number} y y
	     * @param {number} z z
	     * @param {number} w w
	     * @returns {Quaternion} 创建出来的四元数
	     * @memberof Quaternion
	     */
	    static createFromNumber(x: number, y: number, z: number, w: number): Quaternion;
	    /**
	     * 使用一个数组创建
	     * 此操作会拷贝一份数组
	     *
	     * @static
	     * @param {number[]} array 数据源，长度必须为4，否则会抛出异常
	     * @returns {Quaternion}
	     * @memberof Quaternion
	     */
	    static createFromArray(array: number[]): Quaternion;
	    /**
	     * 使用某个已有的typedArray创建
	     * 此操作不会拷贝数据，而是在原来的内存区域上操作
	     *
	     * @static
	     * @param {Float32Array} array 数据源
	     * @param {number} [offset=0] 数据源中的偏移
	     * @returns {Quaternion}
	     * @memberof Quaternion
	     */
	    static createFromTypedArray(array: Float32Array, offset?: number): Quaternion;
	    /**
	     * 通过俩个向量创建四元数
	     * @param vFrom
	     * @param vTo
	     * @returns
	     */
	    static createFromUnitVectors(vFrom: Vector3, vTo: Vector3): Quaternion;
	    /**
	     * 拷贝目标四元数的值到自身
	     *
	     * @param {Quaternion} quat 目标四元数
	     * @returns {Quaternion} 自身
	     * @memberof Quaternion
	     */
	    set(quat: Quaternion): Quaternion;
	    /**
	     * 设置四元数的值
	     *
	     * @param {number} x
	     * @param {number} y
	     * @param {number} z
	     * @param {number} w
	     * @returns {Quaternion} 自身
	     * @memberof Quaternion
	     */
	    setValue(x: number, y: number, z: number, w: number): Quaternion;
	    /**
	     * 球面插值
	     *
	     * @param {Quaternion} right 目标四元数
	     * @param {number} t 插值系数，越接近 1 则结果越接近目标
	     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Quaternion} 计算结果
	     * @memberof Quaternion
	     */
	    slerp(right: QuatReadOnly, t: number, dst?: Quaternion): Quaternion;
	    /**
	     * 四元数反转
	     *
	     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Quaternion} 计算结果
	     * @memberof Quaternion
	     */
	    invert(dst?: Quaternion): Quaternion;
	    /**
	     * 四元数相加
	     *
	     * @param {Quaternion} quat 目标四元数
	     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Quaternion} 计算结果
	     * @memberof Quaternion
	     */
	    add(quat: QuatReadOnly, dst?: Quaternion): Quaternion;
	    /**
	     * 四元数相减
	     *
	     * @param {Quaternion} quat 目标四元数
	     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Quaternion} 计算结果
	     * @memberof Quaternion
	     */
	    sub(quat: QuatReadOnly, dst?: Quaternion): Quaternion;
	    /**
	     * 四元数相乘
	     *
	     * @param {Quaternion} quat 目标四元数
	     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Quaternion} 计算结果
	     * @memberof Quaternion
	     */
	    multiply(quat: QuatReadOnly, dst?: Quaternion): Quaternion;
	    premultiply(q: QuatReadOnly): Quaternion;
	    /**
	     * 点乘
	     * @param q
	     */
	    dot(q: QuatReadOnly): number;
	    length(): number;
	    normalize(): this;
	    setFromUnitVectors(vFrom: any, vTo: any): this;
	    /**
	     * 相对角度
	     * @param q
	     */
	    angleTo(q: QuatReadOnly): number;
	    /**
	     * 转向对应的角度
	     * @param q
	     * @param step
	     */
	    rotateTowards(q: any, step: any): Quaternion;
	    /**
	     * 拷贝四元数
	     *
	     * @returns {Quaternion} 拷贝后的对象
	     * @memberof Quaternion
	     */
	    clone(): Quaternion;
	    /**
	     * 四元数是否为默认四元数（表示零旋转）
	     *
	     * @returns {boolean}
	     * @memberof Quaternion
	     */
	    isDefault(): boolean;
	    /**
	     * 将该四元数转换成欧拉角，x代表Pitch,y代表Yaw,z代表Roll
	     * 旋转的顺序为YXZ
	     *
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Quaternion
	     */
	    toEulerAngles(dst?: Vector3): Vector3;
	    /**
	     * 判断与目标四元数的值是否相等
	     *
	     * @param {QuatReadOnly} quat 目标四元数
	     * @returns {boolean}
	     * @memberof Quaternion
	     */
	    equal(quat: QuatReadOnly): boolean;
	    /**
	     * created by shanexyzhou
	     * 从物理引擎内的RawQuaternion生成Quaternion
	     */
	    static fromPhysics(v: phys3D.RawQuaternion): Quaternion;
	    fromPhysics(v: phys3D.RawQuaternion): Quaternion;
	    static clearPhysicsPool(): void;
	    /**
	     * created by shanexyzhou
	     * 生成物理引擎内的RawQuaternion
	     */
	    toPhysics(): Nullable<phys3D.RawQuaternion>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/helper' {
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import Quaternion from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Vector4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4';
	import BoundBall from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export type DirtyCallback = () => void;
	export class Color_N extends Color {
	    get r(): number;
	    set r(val: number);
	    get g(): number;
	    set g(val: number);
	    get b(): number;
	    set b(val: number);
	    get a(): number;
	    set a(val: number);
	    constructor(dirtyCb?: DirtyCallback,dirtyCbTarget?: any, value?: number);
	    /**
	     * 仅引擎内部使用，创建一个带脏标记的Color
	     *
	     * @static
	     * @param {Float32Array} array
	     * @param {DirtyCallback} dirtyCb
	     * @param {Object} target
	     * @returns {Color}
	     * @memberof Color_N
	     */
	    static createWithDirtyCallback(value: number, dirtyCb: DirtyCallback, target: any): Color_N;
	    set(v: Color): void;
	    setValue32(v32: number): void;
	}
	export class Quaternion_N extends Quaternion {
	    get x(): number;
	    set x(val: number);
	    get y(): number;
	    set y(val: number);
	    get z(): number;
	    set z(val: number);
	    get w(): number;
	    set w(val: number);
	    constructor(dirtyCb?: DirtyCallback,dirtyCbTarget?: any, array?: Float32Array, offset?: number);
	    /**
	     * 仅引擎内部使用，创建一个带脏标记的Quaternion
	     *
	     * @static
	     * @param {Float32Array} array
	     * @param {DirtyCallback} dirtyCb
	     * @param {Object} target
	     * @returns {Quaternion}
	     * @memberof Quaternion_N
	     */
	    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Quaternion_N;
	    set(v: Quaternion): this;
	    setValue(x: number, y: number, z: number, w: number): this;
	}
	export class Vector4_N extends Vector4 {
	    get x(): number;
	    set x(val: number);
	    get y(): number;
	    set y(val: number);
	    get z(): number;
	    set z(val: number);
	    get w(): number;
	    set w(val: number);
	    constructor(dirtyCb?: DirtyCallback,dirtyCbTarget?: any, array?: Float32Array, offset?: number);
	    /**
	     * 仅引擎内部使用，创建一个带脏标记的Vector
	     *
	     * @static
	     * @param {Float32Array} array
	     * @param {DirtyCallback} dirtyCb
	     * @param {Object} target
	     * @returns {Vector4}
	     * @memberof Vector4_N
	     */
	    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Vector4_N;
	    set(v: Vector4): this;
	    setValue(x: number, y: number, z: number, w: number): this;
	}
	export class Vector3_N extends Vector3 {
	    get x(): number;
	    set x(val: number);
	    get y(): number;
	    set y(val: number);
	    get z(): number;
	    set z(val: number);
	    constructor(dirtyCb?: DirtyCallback,dirtyCbTarget?: any, array?: Float32Array, offset?: number);
	    /**
	     * 仅引擎内部使用，创建一个带脏标记的Vector
	     *
	     * @static
	     * @param {Float32Array} array
	     * @param {DirtyCallback} dirtyCb
	     * @param {Object} target
	     * @returns {Vector3}
	     * @memberof Vector3_N
	     */
	    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Vector3_N;
	    set(v: Vector3): this;
	    setValue(x: number, y: number, z: number): this;
	}
	export class Vector2_N extends Vector2 {
	    get x(): number;
	    set x(val: number);
	    get y(): number;
	    set y(val: number);
	    constructor(dirtyCb?: DirtyCallback,dirtyCbTarget?: any, array?: Float32Array, offset?: number);
	    /**
	     * 仅引擎内部使用，创建一个带脏标记的Vector
	     *
	     * @static
	     * @param {Float32Array} array
	     * @param {DirtyCallback} dirtyCb
	     * @param {Object} target
	     * @returns {Vector2}
	     * @memberof Vector2_N
	     */
	    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Vector2_N;
	    set(v: Vector2): this;
	    setValue(x: number, y: number): this;
	}
	export class BoundBall_N extends BoundBall {
	    get center(): V3ReadOnly;
	    set center(val: V3ReadOnly);
	    get radius(): number;
	    set radius(val: number);
	    constructor(dirtyCb?: DirtyCallback,dirtyCbTarget?: any, array?: Float32Array, offset?: number);
	    /**
	     * 仅引擎内部使用，创建一个带脏标记的Vector
	     *
	     * @static
	     * @param {Float32Array} array
	     * @param {DirtyCallback} dirtyCb
	     * @param {Object} target
	     * @returns {BoundBall}
	     * @memberof BoundBall_N
	     */
	    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): BoundBall_N;
	    setValue(center: Vector3, radius: number): this;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/rect' {
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	export default class Rect {
	    get xMin(): number;
	    set xMin(val: number);
	    get yMin(): number;
	    set yMin(val: number);
	    get width(): number;
	    set width(val: number);
	    get height(): number;
	    set height(val: number);
	    get xMax(): number;
	    get yMax(): number;
	    constructor(xMin?: number, yMin?: number, width?: number, height?: number);
	    /**
	     * 使用一个数组创建
	     * 此操作会拷贝一份数组
	     *
	     * @static
	     * @param {number[]} array
	     * @returns {Rect}
	     * @memberof Rect
	     */
	    static createFromArray(array: number[]): Rect;
	    getCenter(): Vector2;
	    set(rect: Rect): void;
	    transformByPositionScale(position: Vector2, scale: Vector2): void;
	    /**
	     * 拷贝该向量
	     *
	     * @returns {Rect} 拷贝出来的对象
	     * @memberof Rect
	     */
	    clone(): Rect;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/type' {
	export function IsFunction(obj: any): obj is Function;
	export function IsObject(obj: any): obj is object;
	export function IsString(obj: any): obj is string;
	export function IsNumber(obj: any): obj is number;
	export function IsBoolean(obj: any): obj is boolean;
	export function IsUndefined(obj: any): obj is undefined;
	export function hasOwnProperty(target: any, key: string): boolean;
	export function isPrimitiveValue(target: any): boolean;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/gameUtil' {
	export function requestID(): number;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource' {
	 type BaseLoadContext = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base').default;
	/**
	 * @export
	 * @class BaseResource
	 */
	export default class BaseResource {
	    /**
	     * 运行时的唯一资源id。
	     * @private
	     * @type {number}
	     * @memberof BaseResource
	     */
	    id: number;
	    /**
	     * 编辑器中使用的资源id。
	     * @type {string}
	     * @memberof BaseResource
	     */
	    resourceID?: string;
	    groupID?: string;
	    /**
	     * 资源的基类，弱引用逻辑。
	     * @memberof BaseResource
	     */
	    constructor();
	    /**
	     * 资源的反序列化方法。
	     * @static
	     * @param {*} resourceDefinition 资源描述文件。
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {BaseResource}
	     * @memberof BaseResource
	     */
	    static DeserializeResource(resourceDefinition: any, loadContext: BaseLoadContext, dependencies: string[]): BaseResource;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/compiled.game' {
	export const DeserializeFailFlag: any;
	export default function Deserialize(json: any, result: any, context: any, builtContext: any): any;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/deserialize' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { SerializableCtor } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array'; type BaseLoadContext = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base').default;
	export function GetClass(className: string): Nullable<SerializableCtor>;
	export interface ISerializedObject {
	    type: string;
	    data: any;
	}
	export class SerializeHelper {
	    static Context: Nullable<{
	        [key: string]: any[];
	    }>;
	    static ContextMap: Nullable<{
	        [key: string]: string;
	    }>;
	    static BuiltContext: Nullable<{
	        [key: string]: SmartArray<any>;
	    }>;
	    /**
	     * 实例化一个资源
	     * @param type 资源类型
	     * @param resourceDescription 主描述文件
	     * @param loadContext
	     */
	    static DeserializeResource(type: string, resourceDescription: any, loadContext: BaseLoadContext, dependencies?: string[], uuid?: string): BaseResource;
	    static EnterContext(context: any, contextMap: any): void;
	    static LeaveContext(): void;
	    /**
	     * 反序列化一个对象。
	     * @param {any} fileData 被序列化的对象的数据
	     * @optional @param {any} target 是否已经有反序列化的实例对象，某些情况比如Component需要首先调用Entity.protoptype.addComponent的方法产生实例后才能给这个实例的每个属性赋值，这时候就用的到这个参数。
	     * @optional @param {boolean} targetIsResource scriptableAsset的情况下，资源也要走通用序列还模版的能力 不能直接返回uuid
	     */
	    static Deserialize(fileData: any, target: any, targetIsResource?: boolean): any;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render/buildinVertexLayout' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	interface IVertexLayoutRawItem {
	    name: string;
	    byteSize: number;
	    format: Kanata.EVertexFormat;
	    bufferIndex: number;
	    usage: Kanata.EVertexLayoutUsage;
	}
	interface IVertexLayoutRawItemMap {
	    [key: string]: IVertexLayoutRawItem;
	} class BuildInVertexLayoutFactory {
	    constructor(rawItemMap: IVertexLayoutRawItemMap);
	    /**
	     * 通过一个key得到vertexLayout
	     *
	     * @param {string} key 顶点格式，用逗号分割，例如 POSITION,NORMAL,UV
	     * @returns {VertexLayout}
	     * @memberof BuildInVertexLayoutFactory
	     */
	    getVertexLayout(key: string): Kanata.VertexLayout;
	}
	export const buildInVertexLayoutFactory3D: BuildInVertexLayoutFactory;
	export const buildin2DVertexLayout: Kanata.VertexLayout;
	export const buildin23DVertexLayout: Kanata.VertexLayout;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import BoundBall from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall';
	import BoundBox from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBox';
	import { DeepImmutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export interface ISubMesh {
	    /**
	     * 子mesh的顶点偏移。
	     */
	    offset: number;
	    /**
	     * 子mesh的顶点数量。
	     */
	    length: number;
	    /**
	     * 子mesh的材质索引。
	     */
	    materialIndex: number;
	}
	/**
	 * 曲面资源。
	 */
	export default class Mesh extends BaseResource {
	    /**
	     * 从VertexLayout、VB、IB创建一个Mesh。
	     *
	     * @param vertexLayout 顶点结构。
	     * @param vArrayBuffer 顶点数据。
	     * @param iArrayBuffer 顶点索引。
	     * @param indexType 顶点索引类型
	     */
	    static createFromDynamicArrayBuffer(vertexLayout: Kanata.VertexLayout, vArrayBuffer: ArrayBuffer, iArrayBuffer: ArrayBuffer, indexType?: Kanata.EIndexType): Mesh;
	    static readonly MAX_BONECOUNT = 96;
	    /**
	     * 获取VertexLayout。
	     */
	    get vertexLayout(): Kanata.VertexLayout;
	    /**
	     * 获取IndexBuffer。
	     */
	    get indexBuffer(): Kanata.IndexBuffer;
	    /**
	     * 获取VertexBuffer。
	     */
	    get vertexBuffer(): Kanata.VertexBuffer;
	    /**
	     * 获取IndexData。
	     * 这种类型的索引数据用于合批，只对于开启了`dynamicBatch`的Renderer有效。
	     * 注意如果已经获取过`indexBuffer`，将无效。
	     */
	    get indexData(): Kanata.IndexData | null;
	    /**
	     * 获取VertexData。
	     * 这种类型的顶点数据用于合批，只对于开启了`dynamicBatch`的Renderer有效。
	     * 注意如果已经获取过`vertexBuffer`，将无效。
	     */
	    get vertexData(): Kanata.VertexData | null;
	    /**
	     * 包围球，只读。
	     */
	    get boundBall(): DeepImmutable<BoundBall>;
	    /**
	     * 包围盒，只读。
	     */
	    get boundBox(): DeepImmutable<BoundBox>;
	    /**
	     * 构造一个Mesh。
	     * 请不要直接使用，而是使用`Mesh.createFromDynamicArrayBuffer`。
	     */
	    constructor(vertexLayout: Kanata.VertexLayout, vBuffer: ArrayBufferView, iBuffer: ArrayBufferView, indexType?: Kanata.EIndexType);
	    /**
	     * 更新VertexBuffer。
	     * 仅在获取了`vertexBuffer`后有效。
	     */
	    uploadVertexBuffer(offset: number, buffer: ArrayBufferView): void;
	    /**
	     * 更新IndexBuffer。
	     * 仅在获取了`indexBuffer`后有效。
	     */
	    uploadIndexBuffer(offset: number, buffer: ArrayBufferView): void;
	    /**
	     * 获得Mesh的骨骼数量
	     */
	    getBoneCount(): number;
	    /**
	     * 获取当前mesh有多少subMesh
	     */
	    getSubMeshCount(): number;
	    /**
	     * 获取指定序号的subMesh的索引起始点
	     *
	     * @returns {number} 索引起始点,返回-1代表SubMesh不存在
	     */
	    getIndiceStart(subMeshIndex: number): number;
	    /**
	     * 获取指定序号的subMesh的索引长度
	     *
	     * @returns {number} 索引长度，返回-1代表SubMesh不存在
	     */
	    getIndiceLength(subMeshIndex: number): number;
	    /**
	     * 获取指定序号的subMesh的材质序号
	     *
	     * @returns {number} 材质序号，返回-1代表subMesh不存在
	     */
	    getMaterialIndex(subMeshIndex: number): number;
	    /**
	     * 获取VertexLayout。
	     */
	    getVertexLayout(): Kanata.VertexLayout;
	    /**
	     * 修改subMesh。
	     *
	     * @param length 索引长度
	     * @param offset 索引起始偏移
	     */
	    modifySubMesh(subMeshIndex: number, length: number, offset: number): boolean;
	    /**
	     * 增加subMesh。
	     *
	     * @param length 索引长度
	     * @param offset 索引起始偏移
	     */
	    addSubMesh(length: number, offset: number, materialIndex?: number): void;
	    /**
	     *  动态更新包围球。
	     */
	    setBoundBall(center: V3ReadOnly, radius: number): void;
	    /**
	     *  动态更新包围盒。
	     */
	    setBoundBox(center: V3ReadOnly, size: V3ReadOnly): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/materials/buildinShaderDesc' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	export const MAX_ADD_LIGHT = 4;
	/**
	 * 渲染类型。
	 */
	export enum EnumRendererType {
	    Mesh = 0,
	    SkinnedMesh16 = 1,
	    SkinnedMesh32 = 2,
	    SkinnedMesh48 = 3,
	    SkinnedMesh64 = 4,
	    SkinnedMesh80 = 5,
	    SkinnedMesh96 = 6,
	    SkinnedAnimation = 7,
	    Particle = 8,
	    Trail = 9,
	    UI = 10,
	    UI3D = 11,
	    PostProcess = 12
	}
	/**
	 * 通过渲染类型获取默认的PerObject的UniformBlock。
	 */
	export function getUniformBlockDescByRendererType(type: EnumRendererType): Kanata.UniformDescriptor;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/enum' {
	export function GenerateEnumObjectFromTypescript<T>(this: void, object: T): T;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	/**
	 * 支持的纹理来源类型。
	 */
	export type TextureSource = Kanata.IImage | HTMLCanvasElement | ArrayBufferView;
	/**
	 * 纹理Filter模式。
	 */
	export enum TextureFilterMode {
	    POINT = 0,
	    BILINEAR = 1,
	    TRILINEAR = 2
	} enum ETextureFormatOrig {
	    NONE = 1,
	    RGBA8 = 2,
	    RGB8 = 3,
	    RGBA4 = 4,
	    R5G6B5 = 5,
	    R5G5B5A1 = 6,
	    R10G10B10A2 = 7,
	    RGBA32F = 8,
	    RGBA16F = 9,
	    R32F = 10,
	    R16F = 11,
	    L8 = 12,
	    DXT1 = 13,
	    DXT3 = 14,
	    DXT5 = 15,
	    DEPTH = 16,
	    DEPTHSTENCIL = 17,
	    PVRTC2_RGB = 18,
	    PVRTC4_RGB = 19,
	    PVRTC2_RGBA = 20,
	    PVRTC4_RGBA = 21,
	    ETC2_RGB8 = 22,
	    ETC2_SRGB8 = 23,
	    ETC1_RGB8 = 24,
	    PIXELFORMAT_PVR_CCZ = 25,
	    PIXELFORMAT_PVR_GZ = 26,
	    PIXELFORMAT_ETC2_RGBA8 = 27,
	    ASTC = 28
	}
	export function convertTextureFormat(format: ETextureFormatOrig): Kanata.ETextureFormat;
	/**
	 * 贴图资源。
	 */
	export default class Texture extends BaseResource {
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect' {
	import { EnumRendererType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/materials/buildinShaderDesc';
	import { EffectAsset, IMaterialPassRenderStates } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource'; type NonOptionalKeys<T> = {
	    [K in keyof T]-?: T[K];
	};
	export const NativeDefaultRenderStates: NonOptionalKeys<IMaterialPassRenderStates>;
	export const DefaultRenderStates: NonOptionalKeys<IMaterialPassRenderStates>;
	/**
	 * 特效资源，供Material使用。
	 */
	export default class Effect extends BaseResource {
	    readonly description: EffectAsset;
	    static RendererType: Readonly<typeof EnumRendererType>;
	    /**
	     * 特效名称。
	     */
	    get name(): string;
	    /**
	     * 有几个Pass。
	     */
	    get passCount(): number | undefined;
	    /**
	     * 是否支持开启Instance。
	     */
	    get supportInstance(): boolean;
	    /**
	     * 根据特效配置生成特效资源。
	     * @param description 特效配置。
	     */
	    constructor(description: EffectAsset);
	    static AddBeforeConstructorCbList(cb: (resourceDescription: EffectAsset) => any): void;
	    static AddAfterConstructorCbList(cb: (effect: Effect) => any): void;
	    /**
	     * 预编译
	     */
	    warmUp(): boolean;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/pools' {
	/**
	 * pools.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/9/2020, 2:14:32 PM
	 */
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext'; class Pool<ObjClz extends Kanata.IHandle> {
	    constructor(allocateFunc: () => ObjClz, releaseFunc: (obj: ObjClz) => void, initSize: number, enlargeSize: number);
	    get(): ObjClz;
	    release(obj: ObjClz): void;
	} abstract class Pools<Descriptor extends Kanata.IHandle | undefined, ObjClz extends Kanata.IHandle> {
	    allocate(descriptor: Descriptor, size?: number): void;
	    has(descriptor: Descriptor): boolean;
	    get(descriptor: Descriptor): ObjClz;
	    release(descriptor: Descriptor, obj: ObjClz): void;
	} class UniformBlockPools extends Pools<Kanata.UniformDescriptor, Kanata.UniformBlock> {
	    allocate(descriptor: Kanata.UniformDescriptor, size?: number): void;
	} class MaterialPools extends Pools<undefined, Kanata.Material> {
	}
	export const uniformBlockPools: UniformBlockPools;
	export const materialPools: MaterialPools;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { IMaterialPassRenderStates } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect';
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Vector4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext'; type Expand<T> = T extends infer O ? {
	    [K in keyof O]: O[K];
	} : never; type NonFunctionPropertyNames<T> = keyof Omit<T, {
	    [K in keyof T]: T[K] extends Function ? K : never;
	}[keyof T]>; type MaterialRenderStatesKeys = Expand<NonFunctionPropertyNames<IMaterialPassRenderStates>>;
	export const MaterialResourceShaderDefinationKeys: Array<MaterialRenderStatesKeys>;
	/**
	 * 材质资源。
	 */
	export default class Material extends BaseResource {
	    static BlendFactor: typeof Kanata.EBlendFactor;
	    static BlendOp: typeof Kanata.EBlendEquation;
	    static CullMode: typeof Kanata.ECullMode;
	    static StencilOp: typeof Kanata.EStencilOp;
	    static CompareFunc: typeof Kanata.ECompareFunc;
	    static PrimitiveType: typeof Kanata.EPrimitiveType;
	    static ColorMask: typeof Kanata.EColorMask;
	    /**
	     * 是否开启Instance，需要基于的Effect支持Instance。
	     */
	    get useInstance(): boolean;
	    set useInstance(value: boolean);
	    /**
	     * 该材质的Effect。
	     * 当更换材质Effect时，相同名字的shaderProperties和texture会被拷贝，不同名字的值被丢弃
	     */
	    get effect(): Effect;
	    set effect(effect: Effect);
	    /**
	     * 渲染顺序，相机按照renderQueue从小到大的顺序进行渲染。
	     * 注：renderQueue>=2500时，被认为是一个透明物体，渲染时会按物体到相机距离从远到近进行渲染。
	     */
	    get renderQueue(): number;
	    set renderQueue(val: number);
	    /**
	     * 当使用MeshRenderer.getMaterialAtIndex时，会生成一份拷贝材质，该属性指向原材质。
	     */
	    get sourceMaterial(): Nullable<Material>;
	    set renderStates(states: IMaterialPassRenderStates);
	    /**
	     * 创建材质对象，可在构造函数传入effect，也可在创建后赋值。
	     * 材质必须设置effect才可以正常使用。
	     *
	     * const mat = new engine.Material(effect1);
	     * const mat2 = new engine.Material();
	     * mat2.effect = effect1;
	     *
	     * @param {fromPool} 如果使用池，则必须自己调用`releaseToPool`方法！
	     * @memberof Material
	     */
	    constructor(effect?: Effect, marcos?: {
	        [name: string]: string | number | boolean;
	    }, fromPool?: boolean);
	    /**
	     * 拷贝自身，生成一份新的材质数据
	     */
	    clone(): Material;
	    /**
	     * 获取一个Float
	     */
	    getFloat(key: string): Nullable<number>;
	    /**
	     * 设置一个Float
	     *
	     * @returns 是否设置成功
	     */
	    setFloat(key: string, value: number): boolean;
	    /**
	     * 设置一个Vector
	     *
	     * @returns 是否设置成功
	     */
	    setVector(key: string, value: Vector2 | Vector3 | Vector4): boolean;
	    /**
	     * 获取一个Vector值的拷贝
	     */
	    getVector(key: string): Nullable<Vector2 | Vector3 | Vector4>;
	    /**
	     * 设置一个参数
	     * deprecated,使用setVector代替
	     *
	     * @returns 是否设置成功
	     */
	    setParam(key: string, value: Vector2 | Vector3 | Vector4): boolean;
	    /**
	     * 设置一张贴图
	     *
	     * @param mode 0-color,1-depth,2-stencil
	     * @returns 是否设置成功
	     */
	    setTexture(key: string, value?: Texture, mode?: number): boolean;
	    resetTexture(key: string): Texture | null;
	    /**
	     * 获取材质中已设置的贴图
	     */
	    getTexture(key: string): Nullable<Texture>;
	    /**
	     * 设置渲染状态
	     * 只有标记了 useMaterialRenderStates 的Pass会受到影响
	     */
	    setRenderState(key: string, value: number | boolean): boolean;
	    /**
	     * 获取渲染状态
	     */
	    getRenderState(key: string): number | boolean;
	    /**
	     * 设置宏。
	     */
	    setRenderDefinition(key: string, value: boolean): void;
	    /**
	     * 获取宏。
	     */
	    getRenderDefinition(key: string): boolean;
	    /**
	     * @deprecated
	     */
	    setRenderDefination(key: string, value: boolean): void;
	    /**
	     * 对于创建时使用了`fromPool`的材质，需要手动调用此方法将其销毁。
	     */
	    releaseToPool(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate' {
	 type DelegateHandler<S, E> = (sender: S, eventArgs: E) => any;
	export class Delegate<S, E> {
	    add(handler: DelegateHandler<S, E>, clearable?: boolean): void;
	    remove(handler: DelegateHandler<S, E>): void;
	    invoke(context: S, eventArgs: E): void;
	    clear(): void;
	    dispose(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/touch' {
	export enum RawTouchEvents {
	    TouchStart = "touchstart",
	    TouchEnd = "touchend",
	    TouchMove = "touchmove",
	    TouchCancel = "touchcancel"
	}
	export function SetupTouchListeners(): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen' {
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	/**
	 * @export
	 * @class Screen
	 */
	export default class Screen {
	    /**
	     * 屏幕分辨率变更事件监听器。
	     */
	    readonly resolutionChangeEvent: Emitter<void>;
	    /**
	     * 屏幕宽。
	     */
	    get width(): number;
	    /**
	     * 屏幕高。
	     */
	    get height(): number;
	    constructor(width: number,height: number);
	    /**
	     * 设置分辨率、
	     * 该接口一般不会由开发者手动调用。
	     */
	    setResolution(width: number, height: number): void;
	    /**
	     * 分辨率高。
	     */
	    get resolutionHeight(): number;
	    /**
	     * 分辨率宽。
	     */
	    get resolutionWidth(): number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UILayer' {
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	export type Entity2D = Entity & {
	    transform2D: Transform2D;
	};
	export default class UILayer extends Renderable2D {
	    priority: number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMask' {
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	export type Entity2D = Entity & {
	    transform2D: Transform2D;
	};
	export default class UIMask extends Component {
	    readonly priority: number;
	    /**
	     * 默认值为false，UIMask是否反向裁剪
	     *
	     * @type {boolean}
	     * @memberof UIMask
	     */
	    get reverse(): boolean;
	    set reverse(val: boolean);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMaskManager' {
	export default class UIMaskManager {
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderWalker' {
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	export type Type2DRenderComp = Renderable2D | MeshRenderer;
	export default class RenderWalker {
	    constructor();
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIRenderManager' {
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import UILayer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UILayer';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	export type Type2DRenderComp = Renderable2D | MeshRenderer | UILayer;
	export class RootNode {
	    constructor(entity: Entity2D, isUITreeRoot?: boolean, initRenderLength?: number);
	    setSourceParentRootDirty(): void;
	}
	export default class UIRenderMananger {
	    constructor();
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render/UICameraRenderProcess' {
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import UICamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICamera';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { RootNode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIRenderManager';
	export default class UICameraRenderProcess {
	    get renderList(): Kanata.ScalableList;
	    constructor(camera: UICamera);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame' {
	import Rect from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/rect';
	import Vector4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { SpriteframeResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	/**
	 *
	 * @export
	 * @class SpriteFrame
	 * @extends {BaseResource}
	 */
	export default class SpriteFrame extends BaseResource {
	    /**
	     * 贴图。
	     * @type {Nullable<Texture2D>}
	     * @memberof SpriteFrame
	     */
	    get texture(): Nullable<Texture2D>;
	    /**
	     * 贴图在图集中的区域。
	     * @type {Rect}
	     * @memberof SpriteFrame
	     */
	    get rect(): Rect;
	    /**
	     * 贴图在图集中的边框大小。
	     * @readonly
	     * @type {Vector4}
	     * @memberof SpriteFrame
	     */
	    get trim(): Vector4;
	    /**
	     * 九宫格裁剪位置在Rect中的相对位置。
	     * @type {Rect}
	     * @memberof SpriteFrame
	     */
	    get slicedRect(): Rect;
	    /**
	     * 图片资源反序列化方法。
	     * @static
	     * @param {SpriteframeResourceDescription} resourceDescription 资源配置。
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {SpriteFrame}
	     * @memberof SpriteFrame
	     */
	    static DeserializeResource(resourceDescription: SpriteframeResourceDescription, loadContext: BaseLoadContext): SpriteFrame;
	    /**
	     * 从贴图资源创建图片资源。
	     * @static
	     * @param {Texture2D} texture
	     * @param {Rect} [rect]
	     * @param {Rect} [slicedRect]
	     * @param {Vector4} [trim]
	     * @returns {SpriteFrame}
	     * @memberof SpriteFrame
	     */
	    static createFromTexture(texture: Texture2D | RenderTexture, rect?: Rect, slicedRect?: Rect, trim?: Vector4): SpriteFrame;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/open-data/compile' {
	interface Scope {
	    [key: string]: any;
	}
	export type Evaluate = (scope?: Scope) => any;
	export type Compile = (expression: string) => Evaluate;
	export default function createParser(global: Scope): Compile;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph' {
	import BitmapFont from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/bitmapFont';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	export const getFontString: (italic: boolean, bold: boolean, fontSize?: number, fontFamily?: string) => string;
	export interface IGlyph {
	    character?: string;
	    offsetX: number;
	    offsetY: number;
	    bearingX: number;
	    bearingY: number;
	    advance: number;
	    width: number;
	    height: number;
	    uvs: number[];
	    texture: number | Texture2D;
	    bitmapFont?: BitmapFont;
	}
	export interface IBatchGlyph {
	    index: number;
	    characterCount: number;
	    strokeCount: number;
	    shadowCount: number;
	    glyphs: IGlyph[];
	    next?: IBatchGlyph;
	    isUnderineBatch?: boolean;
	    isSpriteBatch?: boolean;
	    isBlankBatch?: boolean;
	}
	export const GetBatchGlyph: () => IBatchGlyph;
	export const FindBatchGlyphByIndex: (srcBatchs: IBatchGlyph, index: number) => IBatchGlyph | null; class GlyphSet {
	    has(character: string, font: string): boolean;
	    set(character: string, font: string, glyph: IGlyph): void;
	    get(character: string, font?: string): IGlyph | undefined;
	    getUnderline(): IGlyph | {
	        offsetX: number;
	        offsetY: number;
	        bearingX: number;
	        bearingY: number;
	        advance: number;
	        width: number;
	        height: number;
	        scale: number;
	        texture: number;
	        uvs: number[];
	    };
	    getByFontStyle(character: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string): IGlyph | undefined;
	} const _default: GlyphSet;
	export default _default;
	export class GlyphInfoSet {
	    set(character: string, font: string, glyph: Kanata.IGlyphInfo): void;
	    get(character: string, font?: string): Kanata.IGlyphInfo | undefined;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/bitmapFont' {
	import { IGlyph } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { BitmapFontResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	/**
	 * 位图字体资源。
	 * @export
	 * @class BitmapFont
	 * @extends {BaseResource}
	 */
	export default class BitmapFont extends BaseResource {
	    /**
	     * 位图字体资源的反序列化方法。
	     * @static
	     * @param {BitmapFontResourceDescription} resourceDescription
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {BitmapFont}
	     * @memberof BitmapFont
	     */
	    static DeserializeResource(resourceDescription: BitmapFontResourceDescription, loadContext: BaseLoadContext): BitmapFont;
	    /**
	     * 是否允许动态改变字号
	     * @type {{ TypeNames.Boolean }}
	     * @memberof BitmapFont
	     */
	    allowChangeFontSize: boolean;
	    /**
	     * 是否允许动态改变颜色
	     * @type {{ TypeNames.Boolean }}
	     * @memberof BitmapFont
	     */
	    allowChangeFontColor: boolean;
	    /**
	     * 字符在字符集中的信息。
	     * @type {{ [character: string]: Glyph }}
	     * @memberof BitmapFont
	     */
	    spriteSheet: {
	        [character: string]: IGlyph;
	    };
	    /**
	     * 字体大小。
	     * @type {(number | null)}
	     * @memberof BitmapFont
	     */
	    fontSize: number | null;
	    /**
	     * 是否为启用状态。
	     * @type {boolean}
	     * @memberof BitmapFont
	     */
	    enabled: boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/font' {
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { FontResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	/**
	 * 字体资源。
	 * @export
	 * @class Font
	 * @extends {BaseResource}
	 */
	export default class Font extends BaseResource {
	    /**
	     * 所有已知的字体集合。
	     * @static
	     * @memberof Font
	     */
	    static FontFamilies: Set<string>;
	    /**
	     * 字体名称。
	     * @type {string}
	     * @memberof Font
	     */
	    fontFamily: string;
	    ttfFileId: string;
	    /**
	     * 字体资源的反序列化方法。
	     * @static
	     * @param {FontResourceDescription} resourceDescription
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {Font}
	     * @memberof Font
	     */
	    static DeserializeResource(resourceDescription: FontResourceDescription, loadContext: BaseLoadContext): Font;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/enum' {
	export enum TextAlign {
	    Default = 0,
	    Left = 1,
	    Center = 2,
	    Right = 3
	}
	export enum TextVAlign {
	    Default = 0,
	    Top = 1,
	    Middle = 2,
	    Bottom = 3
	}
	export enum TextRenderMode {
	    NoCache = 0,
	    Cache = 1
	}
	export enum OverflowType {
	    Auto = 0,
	    Hidden = 1
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/pool' {
	interface TMetrics {
	    totalAlloc: number;
	    totalFree: number;
	}
	export default class Pool<T extends object> {
	    metrics: TMetrics;
	    constructor(cls: {
	        new (...args: any[]): T;
	    }, args?: any[]);
	    alloc(): T;
	    free(obj: T): void;
	    collect(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/decorator' {
	export const typing: {
	    guard: <T extends new (...args: any[]) => {}>(constructor: T, name?: string | undefined) => any;
	    readonly: PropertyDecorator & ParameterDecorator;
	    autobind: MethodDecorator;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/device' {
	/**
	 * 当前环境。
	 */
	export enum Environment {
	    Unknown = "Unknown",
	    Browser = "Browser",
	    Devtool = "Devtool",
	    Mobile = "Mobile"
	}
	/**
	 * 当前平台。
	 */
	export enum Platform {
	    Unknown = "Unknown",
	    Android = "Android",
	    IOS = "IOS",
	    WINDOWS = "WINDOWS"
	}
	export enum GroupPlatform {
	    ETC2 = "etc2",
	    ETC1 = "etc1",
	    PVR = "pvr",
	    ASTC = "astc",
	    S3TC = "s3tc",
	    IOS = "ios",
	    DEFAULT = "default"
	}
	export class Device {
	    /**
	     * 当前屏幕高度。
	     */
	    readonly screenHeight: number;
	    /**
	     * 当前屏幕宽度。
	     */
	    readonly screenWidth: number;
	    /**
	     * 当前像素高度。
	     */
	    readonly pixelHeight: number;
	    /**
	     * 当前像素宽度。
	     */
	    readonly pixelWidth: number;
	    /**
	     * 当前像素比例。
	     */
	    readonly pixelRatio: number;
	    /**
	     * 当前环境。
	     */
	    readonly environment: Environment;
	    /**
	     * 当前平台。
	     */
	    readonly platform: Platform;
	    constructor();
	    /**
	     * 获取压缩纹理支持。
	     */
	    getGroupPlatform(): GroupPlatform;
	    /**
	     * 是否在工具内。
	     */
	    isDevtool(): boolean;
	} const device: Device;
	export default device;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph/gfx' {
	import { IGlyph } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph';
	export const queryGlyph: (character: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string) => IGlyph | null;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph/query' {
	import BitmapFont from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/bitmapFont';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { IBatchGlyph, IGlyph } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph';
	export const charCodeHash: {};
	export enum CharCodeState {
	    Normal = 0,
	    Emoji = 1,
	    C0 = 2
	}
	export const getCharCodeState: (character: string) => CharCodeState;
	export const batchGlyphPush: (glyph: IGlyph, batchGlyph: IBatchGlyph) => IBatchGlyph; const queryGlyph: (character: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string, bitmapFont?: Nullable<BitmapFont>) => IGlyph | null; const queryBatchGlyph: (characters: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string, bitmapFont?: Nullable<BitmapFont>) => IBatchGlyph; const measureText: (characters: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string) => {
	    width: number;
	    height: number;
	};
	export { queryGlyph, queryBatchGlyph, measureText };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/typesetting' {
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import { OverflowType, TextAlign, TextVAlign } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/enum';
	import { IBatchGlyph, IGlyph } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph';
	export enum EWrapMode {
	    FixWidth = 0,
	    FixHeight = 1,
	    AutoWidth = 2,
	    AutoHeight = 3,
	    Stretch = 4
	}
	export enum ENodeType {
	    Character = 0,
	    Image = 1,
	    Animation = 2,
	    Node = 3
	}
	export enum EBreakTokenAlign {
	    Left = 0,
	    Center = 1,
	    Right = 2
	}
	export enum EBreakTokenVAlign {
	    Top = 0,
	    Middle = 1,
	    Bottom = 2
	}
	export interface IBaseTextStyle {
	    id: number;
	    fontFamily: string;
	    size: number;
	    color: number;
	    bold: boolean;
	    italic: boolean;
	    spacing: number;
	    stroke: number;
	    strokeColor: number;
	    underline: number;
	    underlineColor: number;
	    shadowOffset: Vector2;
	    shadowColor: number;
	    applyGradient: boolean;
	    gradientTop: number;
	    gradientBottom: number;
	    linkid?: number;
	    nodeid?: number;
	}
	export const GetBaseTextStyle: (fontFamily: string, size: number, color: number, bold: boolean, italic: boolean, spacing: number, stroke: number, strokeColor: number, underline: number, underlineColor: number, shadowOffset: Vector2, shadowColor: number, applyGradient: boolean, gradientTop: number, gradientBottom: number, linkid?: number | undefined, nodeid?: number | undefined) => IBaseTextStyle;
	export interface INodeData {
	    type: ENodeType;
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	    batchIndex: number;
	    next?: INodeData;
	    linkNext?: INodeData;
	    useBreakToken?: boolean;
	    subBreakToken?: boolean;
	    subBreakTokenCount?: number;
	    breakTokenAlign?: EBreakTokenAlign;
	    breakTokenVAlign?: EBreakTokenVAlign;
	    breakHeight?: number;
	    style?: IBaseTextStyle;
	    linkid?: number;
	    nodeid?: number;
	    nodesizex?: number;
	    nodesizey?: number;
	    stopFlag?: boolean;
	}
	export interface ICharacterData extends INodeData {
	    character: string;
	    glyph: IGlyph;
	}
	export interface IExternNodeData extends INodeData {
	    nodeid: number;
	    bindTransform?: Transform2D;
	}
	export interface ITypesettingData {
	    id: number;
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	    wrapWidth: number;
	    wrapHeight: number;
	    paddingLeft: number;
	    paddingTop: number;
	    paddingRight: number;
	    paddingBottom: number;
	    fontSize: number;
	    rowsNumber: number;
	    align: TextAlign;
	    valign: TextVAlign;
	    spacing: number;
	    lineSpace: number;
	    wrapMode: EWrapMode;
	    overflowMode: OverflowType;
	    bitmapFontUseFontSize: boolean;
	    bitmapFontUseFontColor: boolean;
	    batchs?: IBatchGlyph;
	    characterStart?: ICharacterData;
	    characterEnd?: ICharacterData;
	    characterLineStart?: ICharacterData;
	    offsetX: number;
	    offsetY: number;
	    lineSizeX: number;
	    lineSizeY: number;
	    lineCount: number;
	    baseLineTopHeight: number;
	    baseLineBottomHeight: number;
	}
	export const GetTypesettingData: (x: number, y: number, width: number, height: number, wrapWidth: number, wrapHeight: number, paddingLeft: number, paddingTop: number, paddingRight: number, paddingBottom: number, fontSize: number, align: TextAlign, valign: TextVAlign, spacing: number, lineSpace: number, wrapMode: EWrapMode, overflowMode: OverflowType, bitmapFontUseFontSize: boolean, bitmapFontUseFontColor: boolean, batchs?: IBatchGlyph | undefined) => ITypesettingData;
	export const SetTypesettingDataValue: (tsData: ITypesettingData, x: number, y: number, width: number, height: number, wrapWidth: number, wrapHeight: number, paddingLeft: number, paddingTop: number, paddingRight: number, paddingBottom: number, fontSize: number, align: TextAlign, valign: TextVAlign, spacing: number, lineSpace: number, wrapMode: EWrapMode, overflowMode: OverflowType, bitmapFontUseFontSize: boolean, bitmapFontUseFontColor: boolean) => void;
	export const FreeTypesettingData: (tsData: ITypesettingData) => void;
	export const GetCharacterData: (character: string, x: number, y: number, width: number, height: number, batchIndex: number, glyph: IGlyph) => ICharacterData;
	export const GetCharacterDataByCharacter: (character: string, batchGlyph: IBatchGlyph) => Nullable<ICharacterData>;
	export const GetBestFitFontSize: (characters: string, batchs: IBatchGlyph, fontSize: number, lineSpace: number, wrapWidth: number, wrapHeight: number, wordWrap: boolean) => number;
	export const LayoutLine: (tsData: ITypesettingData) => void;
	export const BreakLine: (tsData: ITypesettingData) => void;
	export const Typesetting: (characters: string, tsData: ITypesettingData) => void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/fillRenderData' {
	import { BlendType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { IRenderData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import { IBatchGlyph } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph';
	import { ICharacterData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/typesetting';
	export function startFill(srcBatchs: IBatchGlyph): void;
	/**
	 * 阴影 -> 字符 -> 下划线
	 */
	export function fillRenderData(offsetX: number, offsetY: number, characterStart: ICharacterData, characterEnd: Nullable<ICharacterData>, srcBatchs: IBatchGlyph, renderDatas: IRenderData, positionSize: number, underline: number, shadowOffset: Vector2, stroke: number, fontSize: number, bitmapFontUseFontSize: boolean): void;
	export function fillRenderDataColor(characterStart: ICharacterData, characterEnd: Nullable<ICharacterData>, renderDatas: IRenderData, positionSize: number, renderable2DColor: number, srcFontColor: number, blentType: BlendType, applyGradient: boolean, gradientTop: number, gradientBottom: number, underline: number, underlineColor: number, shadowOffset: Vector2, shadowColor: number, stroke: number, strokeColor: number, bitmapFontUseFontColor: boolean): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/UILabel' {
	import BitmapFont from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/bitmapFont';
	import Font from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/font';
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Immutable, Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import OpenData from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/open-data';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import { OverflowType, TextAlign, TextVAlign } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/enum';
	import { EWrapMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/typesetting';
	export default class UILabel extends Renderable2D {
	    readonly entity: Entity2D;
	    get fontColor(): Color | string;
	    set fontColor(val: Color | string);
	    get text(): string | OpenData;
	    set text(val: string | OpenData);
	    get fontSize(): number;
	    set fontSize(val: number);
	    get italic(): boolean;
	    set italic(val: boolean);
	    get bold(): boolean;
	    set bold(val: boolean);
	    get fontFamily(): string;
	    set fontFamily(val: string);
	    get font(): Nullable<Font>;
	    set font(font: Nullable<Font>);
	    get bitmapFont(): Nullable<BitmapFont>;
	    set bitmapFont(bitmapFont: Nullable<BitmapFont>);
	    get bitmapFontUseFontSize(): boolean;
	    set bitmapFontUseFontSize(val: boolean);
	    get bitmapFontUseFontColor(): boolean;
	    set bitmapFontUseFontColor(val: boolean);
	    get spacing(): number;
	    set spacing(val: number);
	    get lineSpace(): number;
	    set lineSpace(val: number);
	    get align(): TextAlign;
	    set align(val: TextAlign);
	    get valign(): TextVAlign;
	    set valign(val: TextVAlign);
	    get wordWrap(): boolean;
	    set wordWrap(val: boolean);
	    get bestFit(): boolean;
	    set bestFit(val: boolean);
	    get autoSize(): boolean;
	    set autoSize(val: boolean);
	    /**
	     * 文本越界处理方式
	     *
	     * @type {OverflowType}
	     * @memberof UILabel
	     */
	    set overflow(val: OverflowType);
	    get overflow(): OverflowType;
	    get stroke(): number;
	    set stroke(val: number);
	    get strokeColor(): Color;
	    set strokeColor(val: Color);
	    get shadowOffset(): Vector2;
	    set shadowOffset(val: Vector2);
	    get shadowColor(): Color;
	    set shadowColor(val: Color);
	    /**
	     * 下划线的宽度
	     * @memberof UILabel
	     */
	    get underline(): number;
	    set underline(val: number);
	    /**
	     * 下划线的颜色
	     * @memberof UILabel
	     */
	    get underlineColor(): Color;
	    set underlineColor(val: Color);
	    get applyGradient(): boolean;
	    set applyGradient(val: boolean);
	    get gradientTop(): Color;
	    set gradientTop(val: Color);
	    get gradientBottom(): Color;
	    set gradientBottom(val: Color);
	    set paddingLeft(val: number);
	    get paddingLeft(): number;
	    set paddingTop(val: number);
	    get paddingTop(): number;
	    set paddingRight(val: number);
	    get paddingRight(): number;
	    set paddingBottom(val: number);
	    get paddingBottom(): number;
	    get metrics(): Immutable<{
	        width: number;
	        height: number;
	        innerWidth: number;
	        innerHeight: number;
	        outerWidth: number;
	        outerHeight: number;
	        rowsNumber: number;
	        layoutWidth?: number;
	        layouHeight?: number;
	    }>;
	    /**
	     * 获取行数
	     *
	     * @readonly
	     * @type {number}
	     * @memberof UILabel
	     */
	    get rowsNumber(): number;
	    /**
	     * 富文本越界处理方式枚举类型
	     *
	     * @static
	     * @memberof UIRichText
	     */
	    static overflowType: typeof OverflowType;
	    static OverflowType: typeof OverflowType;
	    static DefaultFontFamily: string;
	    static DefaultFontSize: number;
	    queryDirty: boolean;
	    constructor(entity: Entity2D);
	    resetProperties(): void;
	    setTextDirty(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/input/keyboard' {
	 type KeyboardInputComponent = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/KeyboardInputComponent').default;
	export class KeyboardManager {
	    constructor();
	    showKeyboard(keyboardInput: KeyboardInputComponent, config: engineWX.ShowKeyboardArgument): void;
	    hideKeyboard(keyboardInput: KeyboardInputComponent, config?: engineWX.HideKeyboardArgument): void;
	    updateKeyboard(keyboardInput: KeyboardInputComponent, config: engineWX.UpdateKeyboardArgument): void;
	} const _default: KeyboardManager;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/KeyboardInputComponent' {
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component'; enum KeyboardEventNames {
	    KEYBOARD_INPUT = "onKeyboardInput",
	    KEYBOARD_CONFIRM = "onKeyboardConfirm",
	    KEYBOARD_COMPLETE = "onKeyboardComplete"
	}
	/**
	 * 键盘输入组件。
	 * @export
	 * @class KeyboardInputComponent
	 * @extends {Component}
	 */
	export default class KeyboardInputComponent extends Component {
	    /**
	     * 键盘事件类型。
	     * @static
	     * @type {typeof KeyboardEventNames}
	     * @memberof KeyboardInputComponent
	     */
	    static KEYBOARD_EVENTS: typeof KeyboardEventNames;
	    onKeyboardShow: Delegate<KeyboardInputComponent, {}>;
	    onKeyboardInput: Delegate<KeyboardInputComponent, engineWX.KeyboardEvent>;
	    onKeyboardConfirm: Delegate<KeyboardInputComponent, engineWX.KeyboardEvent>;
	    onKeyboardComplete: Delegate<KeyboardInputComponent, engineWX.KeyboardEvent>;
	    showKeyboard(config: engineWX.ShowKeyboardArgument): void;
	    updateKeyboard(config: engineWX.UpdateKeyboardArgument): void;
	    hideKeyboard(config?: engineWX.HideKeyboardArgument): void;
	    invokeKeyboardShow(): void;
	    invokeKeyboardInput(res: engineWX.KeyboardEvent): void;
	    invokeKeyboardConfirm(res: engineWX.KeyboardEvent): void;
	    invokeKeyboardComplete(res: engineWX.KeyboardEvent): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UITextInput' {
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Touchable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import UILabel from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/UILabel';
	import { TextAlign } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/enum';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	export enum TextInputType {
	    Default = 0,
	    Text = 1,
	    Password = 2
	}
	export default class UITextInput extends Touchable {
	    readonly entity: Entity2D;
	    readonly priority: number;
	    get label(): Nullable<UILabel>;
	    set label(value: Nullable<UILabel>);
	    get type(): TextInputType;
	    set type(val: TextInputType);
	    get prompt(): string;
	    set prompt(val: string);
	    get promptColor(): Color;
	    set promptColor(val: Color);
	    get maxChar(): number;
	    set maxChar(val: number);
	    get multiline(): boolean;
	    set multiline(val: boolean);
	    get align(): TextAlign;
	    set align(val: TextAlign);
	    get text(): string;
	    set text(value: string);
	    onTextChange: Delegate<UITextInput, {
	        text: string;
	    }>;
	    editable: boolean;
	    constructor(entity: Entity2D);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/open-data/safe' {
	 const _safe: (object: any) => void; const safe: () => void; const ExpressionGlobal: {
	    JSON: JSON;
	    parseInt: typeof parseInt;
	    parseFloat: typeof parseFloat;
	};
	export { _safe, safe, ExpressionGlobal };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/open-data' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame'; type PrimitiveType = number | string | boolean | null | undefined | {
	    [key: string]: PrimitiveType;
	};
	interface Scope {
	    [key: string]: PrimitiveType;
	} type AvatarSize = 46 | 64 | 96 | 132 | 640;
	interface IOpenData {
	    value(expression: string): OpenData;
	}
	interface IOpenDataArray {
	    length: number;
	    [index: number]: IOpenData;
	    sort(expression: string, descending: boolean, scope?: Scope): IOpenDataArray;
	}
	export default class OpenData implements IOpenData {
	    static getUserCloudStorage: (argument: {
	        keyList: string[];
	    }) => LitePromise<OpenData>;
	    static getFriendCloudStorage: (argument: {
	        keyList: string[];
	        avatarSize: AvatarSize;
	        filterSelf: boolean;
	    }) => LitePromise<OpenDataArray>;
	    static getGroupCloudStorage: (argument: {
	        shareTicket: string;
	        keyList: string[];
	        avatarSize: AvatarSize;
	        filterSelf: boolean;
	    }) => LitePromise<OpenDataArray>;
	    static getPotentialFriendList: (argument: {
	        avatarSize: AvatarSize;
	    }) => LitePromise<OpenDataArray>;
	    static getGroupInfo: (argument: {
	        openGId: string;
	    }) => LitePromise<OpenData>;
	    static getUserCloudStorageKeys: () => LitePromise<OpenData>;
	    static checkPermission: (api: string) => boolean;
	    constructor(data: any);
	    value(expression: string, scope?: Scope): OpenData;
	    spriteFrame(): LitePromise<OpenData>;
	    openid(content: string): LitePromise<string>;
	    share(argument: {
	        title: string;
	        imageUrl: string;
	        imageUrlId: string;
	    }): LitePromise<unknown>;
	    modifyInteractiveStorage(argument: {
	        key: string;
	        opNum: number;
	        operation: "add";
	        title: string;
	        imageUrl: string;
	        imageUrlId: string;
	        quiet: boolean;
	    }): LitePromise<unknown>;
	} class OpenDataArray implements IOpenDataArray {
	    get length(): number;
	    [index: number]: OpenData;
	    constructor(array: Array<Object>);
	    sort(expression: string, descending?: boolean, scope?: Scope): OpenDataArray;
	    find(expression: string, scope?: Scope): OpenData;
	}
	export const getString: (value: string | OpenData) => string;
	export const getBoolean: (value: boolean | OpenData) => boolean;
	export const getSpriteFrame: (value: SpriteFrame | OpenData | null) => SpriteFrame | null;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/sprite/filled' {
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	export enum UISpriteFillDirectionType {
	    Horizontal = 0,
	    Vertical = 1,
	    Radial90 = 2,
	    Radial180 = 3,
	    Radial360 = 4
	}
	export const filled: {
	    fillPosition(vertexData: Float32Array, vertexOffset: number, positionSize: number, vLeft: number, vRight: number, vBottom: number, vTop: number, vWidth: number, vHeight: number, fillDir: UISpriteFillDirectionType, fillAmount: number, invertFill: boolean): void;
	    fillUV(vertexData: Float32Array, vertexOffset: number, positionSize: number, vLeft: number, vRight: number, vBottom: number, vTop: number, vWidth: number, vHeight: number, flipX: boolean, flipY: boolean, spriteFrame: SpriteFrame, fillDir: UISpriteFillDirectionType): void;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/sprite/simple' {
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	/**
	 *  1---2
	 *  |   |
	 *  0---3
	 */
	export const simple: {
	    vetexCount: number;
	    fillPosition(vertexData: Float32Array, vertexOffset: number, positionSize: number, vLeft: number, vRight: number, vBottom: number, vTop: number): void;
	    fillUV(vertexData: Float32Array, vertexOffset: number, positionSize: number, vLeft: number, vRight: number, vBottom: number, vTop: number, vWidth: number, vHeight: number, flipX: boolean, flipY: boolean, spriteFrame: SpriteFrame): void;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/sprite/sliced' {
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	import { UISpriteFillDirectionType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/sprite/filled';
	/**
	 *  0---1---2---3
	 *  |   |   |   |
	 *  4---5---6---7
	 *  |   |   |   |
	 *  8---9--10---11
	 *  |   |   |   |
	 * 12--13--14---15
	 */
	export const sliced: {
	    vetexCount: number;
	    fillPosition(vertexData: Float32Array, vertexOffset: number, positionSize: number, vLeft: number, vRight: number, vBottom: number, vTop: number, vWidth: number, vHeight: number, flipX: boolean, flipY: boolean, spriteFrame: SpriteFrame, fillDir: UISpriteFillDirectionType, fillAmount: number, invertFill: boolean): void;
	    fillUV(vertexData: Float32Array, vertexOffset: number, positionSize: number, flipX: boolean, flipY: boolean, spriteFrame: SpriteFrame): void;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/sprite/tiled' {
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	/**
	 *  1---2
	 *  |   | * N
	 *  0---3
	 */
	export const tiled: {
	    fillPosition(vertexData: Float32Array, vertexOffsetSrc: number, positionSize: number, vLeft: number, vRight: number, vBottom: number, vTop: number, vWidth: number, vHeight: number, spriteFrame: SpriteFrame, tileScale: number): void;
	    fillUV(vertexData: Float32Array, vertexOffset: number, positionSize: number, vLeft: number, vRight: number, vBottom: number, vTop: number, vWidth: number, vHeight: number, spriteFrame: SpriteFrame, tileScale: number): void;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UISprite' {
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	import { BoundsChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import OpenData from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/open-data';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D'; enum UISpriteType {
	    Simple = 0,
	    Sliced = 1,
	    Tiled = 2,
	    Filled = 3
	} enum UISpriteFlipType {
	    Nothing = 0,
	    Horizontally = 1,
	    Vertically = 2,
	    Both = 3
	} enum UISpriteFillDirectionType {
	    Horizontal = 0,
	    Vertical = 1,
	    Radial90 = 2,
	    Radial180 = 3,
	    Radial360 = 4
	}
	/**
	 * 图片组件。
	 * @export
	 * @class UISprite
	 * @extends {Renderable2D}
	 */
	export default class UISprite extends Renderable2D {
	    /**
	     * 图片的显示类型。
	     * @memberof UISprite
	     */
	    set type(type: UISpriteType);
	    get type(): UISpriteType;
	    /**
	     * 图片的翻转类型。
	     * @memberof UISprite
	     */
	    set flip(flip: UISpriteFlipType);
	    get flip(): UISpriteFlipType;
	    /**
	     * 图片tiled模式下的缩放。
	     * @type {number}
	     * @memberof UISprite
	     */
	    get tileScale(): number;
	    set tileScale(tileScale: number);
	    /**
	     * 图片填充模式下的填充方式。
	     * @type {UISpriteFillDirectionType}
	     * @memberof UISprite
	     */
	    get fillDir(): UISpriteFillDirectionType;
	    set fillDir(fillDir: UISpriteFillDirectionType);
	    /**
	     * 图片填充模式下的填充程度，范围0~1。
	     * @type {number}
	     * @memberof UISprite
	     */
	    get fillAmount(): number;
	    set fillAmount(fillAmount: number);
	    /**
	     * 图片填充模式下是否反向填充。
	     * @type {boolean}
	     * @memberof UISprite
	     */
	    get invertFill(): boolean;
	    set invertFill(invertFill: boolean);
	    /**
	     * 图片资源。
	     * @type {Nullable<SpriteFrame>}
	     * @memberof UISprite
	     */
	    get spriteFrame(): Nullable<SpriteFrame | OpenData>;
	    set spriteFrame(value: Nullable<SpriteFrame | OpenData>);
	    /**
	     * 是否使用灰阶。
	     * @type {boolean}
	     * @memberof UISprite
	     */
	    get grayScale(): boolean;
	    set grayScale(val: boolean);
	    /**
	     * 图片显示类型枚举值。
	     * @static
	     * @memberof UISprite
	     */
	    static Type: Readonly<typeof UISpriteType>;
	    /**
	     * 图片翻转类型枚举值。
	     * @static
	     * @memberof UISprite
	     */
	    static FlipType: Readonly<typeof UISpriteFlipType>;
	    /**
	     * 图片填充方式枚举值。
	     * @static
	     * @memberof UISprite
	     */
	    static FillDirectionType: Readonly<typeof UISpriteFillDirectionType>;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/OpenDataContainer' {
	import { TouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Touchable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import UISprite from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UISprite';
	import { RawTouchEvents } from '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/touch';
	export const CROSS_CONTEXT_TOUCH_TYPE = "shared-render-touch";
	export interface ISharedTouchInfo {
	    touchEvent: RawTouchEvents;
	    relatedPosX: number;
	    relatedPosY: number;
	    renterTextureWidth: number;
	    renterTextureHeight: number;
	}
	export default class OpenDataContainer extends Touchable {
	    readonly entity: Entity2D;
	    get useTouch(): boolean;
	    set useTouch(val: boolean);
	    get renderSprite(): Nullable<UISprite>;
	    constructor(entity: Entity2D);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICamera' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { BoundsChangeEventType, UILayerChangeType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import { TouchManager } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import { M4ReadOnly, V2ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	import { Emitter, Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { RawTouchEvents } from '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/touch';
	import UICameraRenderProcess from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/UICameraRenderProcess';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import TouchInputComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import { Type2DRenderComp } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderWalker';
	import UICanvas from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICanvas';
	import { ISharedTouchInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/OpenDataContainer';
	/**
	 * 2D相机组件。
	 * @export
	 * @class UICamera
	 * @extends {BaseCamera}
	 */
	export default class UICamera extends BaseCamera {
	    readonly entity: Entity2D;
	    /**
	     * @override
	     */
	    get cullingMask(): number;
	    set cullingMask(cullingMask: number);
	    /**
	     * @legacy
	     * 在工具内部使用，应该可以直接替换成cullingMask
	     */
	    get uiCanvas(): Nullable<UICanvas>;
	    get projectionMatrix2D(): M4ReadOnly;
	    get viewMatrix2D(): M4ReadOnly;
	    get viewMatrixInverse2D(): M4ReadOnly;
	    static RECEIVE_SHARD_TOUCH: (info: ISharedTouchInfo[]) => void;
	    touchable: boolean;
	    readonly touchManager: TouchManager;
	    readonly touchEvent: Emitter<RawTouchEvents, TouchEvent>;
	    constructor(entity: Entity2D);
	    updateTree(): void;
	    /**
	     * 将事件坐标转换为UICanvas世界坐标
	     *
	     * @param {V2ReadOnly} eventPosition 事件坐标，Y轴向下
	     * @param {Vector2} [dst] 若传入，则输出计算结果到该向量
	     * @returns {Vector2} UICanvas坐标，Y轴向上
	     * @memberof UICamera
	     */
	    convertEventPositionToUICanvas(eventPosition: V2ReadOnly, dst?: Vector2): Vector2;
	    /**
	     * 将事件坐标转换为齐次裁剪坐标
	     *
	     * @param {V2ReadOnly} eventPosition 事件坐标，Y轴向下
	     * @param {Vector2} [dst] 若传入，则输出计算结果到该向量
	     * @returns {Vector2} 齐次裁剪坐标
	     * @memberof UICamera
	     */
	    convertEventPositionToClip(point: V2ReadOnly, dst?: Vector2): Vector2;
	    /**
	     * 将齐次裁剪坐标转换为UICanvas世界坐标
	     *
	     * @param {V2ReadOnly} eventPosition 齐次裁剪坐标
	     * @param {Vector2} [dst] 若传入，则输出计算结果到该向量
	     * @returns {Vector2} UICanvas坐标，Y轴向上
	     * @memberof UICamera
	     */
	    convertClipPositionToCanvas(point: V2ReadOnly, dest?: Vector2): Vector2;
	    draw(renderList: Kanata.ScalableList, lightMode: string): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch' {
	import TouchInputComponent, { TouchEventNames } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import UICamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICamera';
	import UIMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMask';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	import { RawTouchEvents } from '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/touch';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { DeepImmutable, Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter'; type Component = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/component').default;
	interface ITouchStatus {
	    startWorldPosition: [number, number];
	    startClient: [number, number];
	    maxMovement: [number, number];
	    position: [number, number];
	    isStarted: boolean;
	    isOver: boolean;
	}
	interface ITouchInfo {
	    index: number;
	    component: Nullable<TouchInputComponent>;
	    mask: Nullable<UIMask>;
	    renderable: Nullable<Renderable2D>;
	}
	export type TouchPoint = Touch & {
	    readonly position: DeepImmutable<Vector2>;
	    readonly worldPosition: DeepImmutable<Vector2>;
	    readonly startWorldPosition: DeepImmutable<Vector2>;
	};
	export type TouchInputEvent = Readonly<{
	    readonly type: TouchEventNames;
	    readonly touches: DeepImmutable<Array<TouchPoint>>;
	    allowThrough: boolean;
	    originalEvent: TouchEvent;
	    stopTouchThrough(): void;
	}>;
	export const EventTypeNamesToCallbackNames: {
	    [key in TouchEventNames]: string;
	};
	export class TouchManager {
	    readonly uiCamera: UICamera;
	    get onEventTrigger(): Delegate<Component, TouchInputEvent>;
	    enableTouchForRenderableOnly: boolean;
	    constructor(uiCamera: UICamera);
	    markComponentDataNeedUpdate(): void;
	    update(): void;
	    traverse(): void;
	    dispose(): void;
	    forceTouchEndExcept(event: TouchEvent, touchInputComponent: Nullable<TouchInputComponent>): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent' {
	import { TouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Rect from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/rect';
	/**
	 * 触摸事件类型枚举值。
	 * @export
	 * @enum {number}
	 */
	export enum TouchEventNames {
	    TOUCH_START = "TOUCH_START",
	    TOUCH_END = "TOUCH_END",
	    TOUCH_MOVE = "TOUCH_MOVE",
	    TOUCH_ENTER = "TOUCH_ENTER",
	    TOUCH_LEAVE = "TOUCH_LEAVE",
	    TOUCH_OVER = "TOUCH_OVER",
	    TOUCH_CANCEL = "TOUCH_CANCEL",
	    CLICK = "CLICK",
	    TOUCH_OUT = "TOUCH_OUT",
	    TOUCH_UP = "TOUCH_UP"
	}
	/**
	 * 触摸响应类。
	 * @export
	 * @class Touchable
	 * @extends {Component}
	 */
	export class Touchable extends Component {
	    /**
	     * 物体对象。
	     * @type {Entity2D}
	     * @memberof Touchable
	     */
	    readonly entity: Entity2D;
	    /**
	     * 触摸开始事件。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchStart(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸结束事件，只有触发过触摸开始事件才可能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchEnd(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸移动事件，只有触发过触摸开始事件才可能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchMove(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸进入事件，只有触发过触摸开始事件才可能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchEnter(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸离开事件，只有触发过触摸开始事件才可能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchLeave(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸掠过事件，没有触发过触摸开始事件才能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchOver(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸取消事件，只有触发过触摸开始事件才可能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchCancel(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸掠过后移出事件，没有触发过触摸开始事件才能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchOut(): Delegate<this, TouchInputEvent>;
	    /**
	     * 触摸掠过后移出事件，没有触发过触摸开始事件才能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onTouchUp(): Delegate<this, TouchInputEvent>;
	    /**
	     * 点击事件，只有触发过触摸开始事件才可能触发。
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof Touchable
	     */
	    get onClick(): Delegate<this, TouchInputEvent>;
	}
	/**
	 * 2D点击组件，负责点击判定和事件分发。
	 * @export
	 * @class TouchInputComponent
	 * @extends {Touchable}
	 */
	export default class TouchInputComponent extends Touchable {
	    /**
	     * 触摸事件类型枚举值。
	     * @static
	     * @type {typeof TouchEventNames}
	     * @memberof TouchInputComponent
	     */
	    static TOUCH_EVENTS: typeof TouchEventNames;
	    /**
	     * 是否允许事件穿透。
	     * @type {boolean}
	     * @memberof TouchInputComponent
	     */
	    touchThrough: boolean;
	    /**
	     * 点击判定区域。
	     * @type {Nullable<Rect>}
	     * @memberof TouchInputComponent
	     */
	    hitArea: Nullable<Rect>;
	    /**
	     * 点击判定的移动阈值，超出阈值则不视为点击事件。
	     * @type {number}
	     * @memberof TouchInputComponent
	     */
	    clickMovementThreshold: number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICanvas' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Entity2D, Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import { DeepImmutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import TouchInputComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { UIAdaptationType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import { UILayerChangeType, Renderable2DEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	export default class UICanvas extends MeshRenderer {
	    readonly entity: Entity3D & Entity2D;
	    static readonly AdaptationType: Readonly<typeof UIAdaptationType>;
	    /**
	     * 正交模式，屏幕适配的模式
	     */
	    get adaptationType(): UIAdaptationType;
	    set adaptationType(val: UIAdaptationType);
	    get designResolution(): Vector2;
	    set designResolution(designSize: Vector2);
	    get deviceResolution(): Vector2;
	    set deviceResolution(resolution: Vector2);
	    /**
	     * @duplicate
	     */
	    get resolution(): DeepImmutable<Vector2>;
	    /**
	     * @deprecated
	     */
	    get UITreeRoot(): Transform2D;
	    readonly treeDirtyEvent: Emitter<void, void>;
	    readonly treeChangeEvent: Emitter<UILayerChangeType, Entity2D>;
	    readonly interactiveDirtyEvent: Emitter<void>;
	    readonly forceTouchEndExceptEvent: Emitter<TouchEvent, Nullable<TouchInputComponent>>;
	    constructor(entity: Entity3D & Entity2D);
	    markTreeDirty(): void;
	    markLayerRootDirtyByTransform2D(transform2D: Transform2D): void;
	    addUILayerRoot(rootEntity: Entity2D): void;
	    removeUILayerRoot(rootEntity: Entity2D): void;
	    refreshUILayerRoot(rootEntity: Entity2D): void;
	    markUILayerRootDirty(rootEntity: Entity2D): void;
	    markUILayerRootVisbleDirty(rootEntity: Entity2D): void;
	    markInteractiveDirty(): void;
	    getShaderDef(marcos: {
	        [name: string]: string | number | boolean;
	    }): string | number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMaterialManager' {
	/**
	 * UIMaterialManager.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/4/2020, 4:00:15 PM
	 */
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect'; class FakeKanataMaterial extends Kanata.Material {
	    getHash(hash: number): number;
	    copyStateTo(mat: Kanata.Material): void;
	}
	export class FakeMaterial {
	    textures: {
	        [key: string]: Texture | number;
	    };
	    get isDirty(): boolean;
	    set isDirty(val: boolean);
	    get kanataMaterial(): FakeKanataMaterial;
	    get valid(): boolean;
	    get effect(): Effect;
	    set effect(effect: Effect);
	    constructor(effect: Effect);
	    setTexture(key: string, value: Texture): void;
	    setFontTexture(key: string, id: number): void;
	    getTexture(key: string): Texture;
	    getFontTexture(key: string): number;
	    setRenderState(key: string, value: number | boolean): void;
	    copyStateTo(mat: Kanata.Material): void;
	    getPreHash(): number;
	    getHash(): number;
	}
	export default class UIMaterialManager {
	    static TABLE: {
	        [hash: string]: [Kanata.Material, number];
	    };
	    static CREATE_FAKE(effect: Effect): FakeMaterial;
	    static GET(fakeMaterial: FakeMaterial): Kanata.Material;
	    static RELEASE(fakeMaterial: FakeMaterial): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D' {
	import { BoundsChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import Color, { BlendType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import UICanvas from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICanvas';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { FakeMaterial } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMaterialManager';
	export const UI3D_VERTEX_BATCH_DESC: Kanata.VertexDataDescriptor;
	export enum EMaterial2DType {
	    Image2D = 0,
	    Text2D = 1,
	    GrayScale2D = 2
	}
	export enum BlendMode {
	    Normal = 0,
	    Additive = 1,
	    SoftAdditive = 2,
	    Multiply = 3,
	    Multiply2X = 4,
	    Screen = 5,
	    LinearDodge = 6
	}
	export const GetBatchableVertexBuffer: (vertexNum: number, is3D: boolean) => Kanata.VertexData;
	export interface IRenderData {
	    material?: FakeMaterial;
	    vDataViewU32?: Uint32Array;
	    vDataViewF32?: Float32Array;
	    vData?: Kanata.VertexData;
	    iData?: Kanata.IndexData;
	    vertexNum?: number;
	    indiceNum?: number;
	    next?: IRenderData;
	    index?: number;
	    materialType?: EMaterial2DType;
	}
	export const FindRenderDataByIndex: (srcDatas: IRenderData, index: number) => IRenderData | null;
	export const GetRenderDate: (indiceBufferView: Uint16Array, vertexNum: number, indiceNum: number, is3D: boolean) => IRenderData;
	/**
	 * 所有需要绘制的2D组件都需要继承自此类，负责管理材质，加速模块的对象以及颜色等信息。
	 */
	export default class Renderable2D extends Component {
	    /**
	     * 渲染组件是否具体渲染
	     *
	     * @type {boolean}
	     * @overload
	     * @memberof Renderable2D
	     */
	    set visible(val: boolean);
	    get visible(): boolean;
	    /**
	     * 渲染组件在同级的渲染顺序
	     *
	     * @type {number}
	     * @overload
	     * @memberof Renderable2D
	     */
	    set zOrder(val: number);
	    get zOrder(): number;
	    /**
	     *  当前渲染元素的混合方式
	     *
	     * @type {BlendMode}
	     * @overload
	     * @memberof Renderable2D
	     */
	    set blendMode(val: BlendMode);
	    get blendMode(): BlendMode;
	    /**
	     *  设定二维元素材质（仅拷贝）
	     *
	     * @type {Nullable<Material>}
	     * @overload
	     * @memberof Renderable2D
	     */
	    set material(val: Nullable<Material>);
	    get material(): Nullable<Material>;
	    /**
	     * 渲染组件本身的颜色，用于与渲染元素进行颜色混合
	     *
	     * @type {Color}
	     * @memberof Renderable2D
	     */
	    set color(val: Color);
	    get color(): Color;
	    set alpha(val: number);
	    get alpha(): number;
	    /**
	     * 渲染组件继承父渲染组件颜色，颜色混合的方式
	     *
	     * @type {BlendType}
	     * @overload
	     * @memberof Renderable2D
	     */
	    set colorBlendType(val: BlendType);
	    get colorBlendType(): BlendType;
	    get isMask(): boolean;
	    get cullingMask(): number;
	    /**
	     * @deprecated
	     */
	    set cullingMask(val: number);
	    /**
	     * 二维渲染叠加混合方式
	     * @static
	     * @memberof Renderable2D
	     */
	    static BlendMode: Readonly<typeof BlendMode>;
	    /**
	     * 继承混合颜色的方式
	     * @static
	     * @memberof Renderable2D
	     */
	    static BlendType: Readonly<typeof BlendType>;
	    readonly entity: Entity2D;
	    readonly priority: number;
	    getMaterialCount(): number;
	    getMaterialAtIndex(index?: number): FakeMaterial | null;
	    /**
	     * 对外暴露的，将渲染元素对应RenderDraw的顶点数据置脏逻辑
	     *
	     */
	    setVertexDirty(): void;
	    /**
	     * 对外暴露的，将渲染元素对应RenderDraw的材质信息置脏
	     */
	    setMaterialDirty(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/decorators/editorDecorators' {
	/**
	 * ceated by janzen
	 * 主要是给工具用的decorators。
	 * 虽然是给工具用的，实际上是调用的是工具的代码。在真机上是空实现。
	 * 但是因为要写在用户的scripts里面，用户的脚本需要调用这个接口，所以要保证真机也能运行，这个接口就要通过engine来暴露，只不过在真机是空实现。
	 *
	 */
	export function CreateAssetMenu(fileName?: string, menuName?: string, order?: number): ClassDecorator;
	export function EditorWindow(name: string, windowLabel: string): ClassDecorator;
	/**
	 * 给tutorial检查器用的
	 * @param name
	 * @returns
	 */
	export function Criterion(criterionName?: string): ClassDecorator;
	/**
	 * 在scriptComponent 的property上面标示这是一个使用特定名字的自定义vue的标记
	 * @param name 标示使用的自定义vue的name
	 */
	export function PropInspector(name: string): ClassDecorator;
	export function Inspector(typeName: string): ClassDecorator;
	export function InsepctorName(typeName: string): (classCtor: any) => void;
	export function CustomBuildComponent(typeName: string): ClassDecorator;
	export function CustomComponentInspector(typeName: string): ClassDecorator;
	export function CustomPropertyInspector(typeName: string): ClassDecorator;
	export function UseSerializedData(typeName: string): ClassDecorator;
	export function SerializedData(typeName: string): ClassDecorator;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/Canvas2D' {
	import Mesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh';
	import { Entity2D, Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { Renderable2DEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event'; enum EnumRendererMode {
	    WorldSpace = 0,
	    BillBorad = 1
	}
	export default class Canvas2D extends MeshRenderer {
	    readonly entity: Entity3D & Entity2D;
	    /**
	     * 图片填充方式枚举值。
	     * @static
	     * @memberof UISprite
	     */
	    static RenderMode: Readonly<typeof EnumRendererMode>;
	    /**
	     * Canvas的是否使用subMesh渲染
	     *
	     * @type {boolean}
	     * @memberof Canvas2D
	     */
	    get useSubMesh(): boolean;
	    set useSubMesh(useSubMesh: boolean);
	    /**
	     * billBoard类型
	     * @type {EnumRendererMode}
	     * @memberof Canvas2D
	     */
	    get renderMode(): EnumRendererMode;
	    set renderMode(renderMode: EnumRendererMode);
	    /**
	     * Canvas的是否使用subMesh渲染
	     *
	     * @type {number}
	     * @memberof Canvas2D
	     */
	    get proportionalScale(): number;
	    set proportionalScale(proportionalScale: number);
	    constructor(entity: Entity3D & Entity2D);
	    markSubMatrixDirty(): void;
	    markTreeDirty(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { ChildChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	export default abstract class TransformBase extends Component {
	    /**
	     * 组件本身是否active
	     *
	     * @type {boolean}
	     * @overload
	     * @memberof Component
	     */
	    get active(): boolean;
	    set active(value: boolean);
	    /**
	     * 父节点
	     *
	     * @readonly
	     * @memberof TransformBase
	     */
	    get parent(): Nullable<TransformBase>;
	    /**
	     * 子节点数量
	     *
	     * @readonly
	     * @memberof TransformBase
	     */
	    get childrenCount(): number;
	    get children(): TransformBase[];
	    /**
	     * 世界矩阵变更事件监听器
	     *
	     * @type {Emitter<TransformBase>}
	     * @memberof TransformBase
	     */
	    get worldMatrixDirtyEvent(): Emitter<void>;
	    /**
	     * active状态变更事件监听器
	     *
	     * @type {Emitter<TransformBase>}
	     * @memberof TransformBase
	     */
	    get activeInHierarchyChangedEvent(): Emitter<void>;
	    /**
	     * 增删节点事件监听器
	     *
	     * @type {Emitter<TransformBase, ChildChangeEventType>}
	     * @memberof TransformBase
	     */
	    get childChangeEvent(): Emitter<ChildChangeEventType, TransformBase>;
	    /**
	     * 找子节点
	     * create by clairli
	     * @param {childName} 子节点名称
	     */
	    findChildByName(childName: string): Nullable<TransformBase>;
	    /**
	     * 获取同级索引
	     *
	     * @returns {number}
	     * @memberof TransformBase
	     */
	    getSiblingIndex(): number;
	    /**
	     * 设置同级索引
	     *
	     * @param {number} index 同级索引序号
	     * @returns
	     * @memberof TransformBase
	     */
	    setSiblingIndex(index: number): void;
	    /**
	     * 遍历子节点
	     *
	     * @param {(child: TransformBase) => any} cb 回调函数
	     * @returns
	     * @memberof TransformBase
	     */
	    travelChild(cb: (child: TransformBase) => any): void;
	    destroy(): void;
	    /**
	     * 在当前节点前插入新的节点, 新插入的节点世界矩阵不变
	     * @param {TransformBase} child 要插入的节点
	     * @returns {boolean} 是否插入成功
	     * @memberof TransformBase
	     */
	    abstract immovableBefore(child: TransformBase): boolean;
	    /**
	     * 在当前节点后插入新的节点, 新插入的节点世界矩阵不变
	     * @param {TransformBase} child 要插入的节点
	     * @returns {boolean} 是否插入成功
	     * @memberof TransformBase
	     */
	    abstract immovableAfter(child: TransformBase): boolean;
	    /**
	     * 把当前节点添加到指定的parent节点里，作为其子节点。 当前节点世界矩阵不变
	     * @param {TransformBase} parent 要插入的节点
	     * @returns {boolean} 是否插入成功
	     * @memberof TransformBase
	     */
	    abstract immovableAppendTo(parent: TransformBase): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D' {
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4';
	import Quaternion from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion';
	import { M4ReadOnly, QuatReadOnly, V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Canvas2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/Canvas2D';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	/**
	 * @export
	 * @class Transform3D
	 * @extends {TransformBase}
	 */
	export default class Transform3D extends TransformBase {
	    readonly entity: Entity3D;
	    /**
	     * 本地位置
	     *
	     * @type {Vector3}
	     * @memberof Transform3D
	     */
	    get position(): Vector3;
	    set position(val: Vector3);
	    /**
	     * 本地旋转，用四元数表示
	     *
	     * @type {Quaternion}
	     * @memberof Transform3D
	     */
	    get quaternion(): Quaternion;
	    set quaternion(val: Quaternion);
	    /**
	     * 本地旋转，用欧拉角表示
	     *
	     * @type {Vector3}
	     * @memberof Transform3D
	     */
	    get euler(): Vector3;
	    set euler(val: Vector3);
	    /**
	     * 本地缩放
	     *
	     * @type {Vector3}
	     * @memberof Transform3D
	     */
	    get scale(): Vector3;
	    set scale(val: Vector3);
	    /**
	     * 本地RTS矩阵，只读
	     *
	     * @readonly
	     * @type {M4ReadOnly}
	     * @memberof Transform3D
	     */
	    get localMatrix(): M4ReadOnly;
	    /**
	     * 世界RTS矩阵，只读
	     *
	     * @readonly
	     * @type {M4ReadOnly}
	     * @memberof Transform3D
	     */
	    get worldMatrix(): M4ReadOnly;
	    /**
	     * 世界位置，只读
	     *
	     * @readonly
	     * @type {Vector3}
	     * @memberof Transform3D
	     */
	    get worldPosition(): Vector3;
	    set worldPosition(v: Vector3);
	    /**
	     * 世界空间缩放，只读
	     *
	     * @readonly
	     * @type {V3ReadOnly}
	     * @memberof Transform3D
	     */
	    get worldScale(): V3ReadOnly;
	    /**
	     * 世界空间旋转，用矩阵表示
	     *
	     * @readonly
	     * @type {M4ReadOnly}
	     * @memberof Transform3D
	     */
	    get worldRotationMatrix(): M4ReadOnly;
	    /**
	     * 世界空间旋转，用四元数表示
	     *
	     * @readonly
	     * @type {QuatReadOnly}
	     * @memberof Transform3D
	     */
	    get worldQuaternion(): QuatReadOnly;
	    /**
	     * 世界空间旋转，用欧拉角表示
	     *
	     * @readonly
	     * @type {V3ReadOnly}
	     * @memberof Transform3D
	     */
	    get worldEuler(): V3ReadOnly;
	    /**
	     * 世界空间前方向，只读
	     *
	     * @readonly
	     * @type {V3ReadOnly}
	     * @memberof Transform3D
	     */
	    get forward(): V3ReadOnly;
	    /**
	     * 世界空间上方向，只读
	     *
	     * @readonly
	     * @type {V3ReadOnly}
	     * @memberof Transform3D
	     */
	    get up(): V3ReadOnly;
	    /**
	     * 世界空间右方向，只读
	     *
	     * @readonly
	     * @type {V3ReadOnly}
	     * @memberof Transform3D
	     */
	    get right(): V3ReadOnly;
	    /**
	     * local尺寸
	     *
	     * @type {Vector2}
	     * @memberof Transform3D
	     */
	    get size(): Vector2;
	    set size(val: Vector2);
	    /**
	     * local尺寸x分量
	     *
	     * @type {number}
	     * @memberof Transform3D
	     */
	    get sizeX(): number;
	    set sizeX(val: number);
	    /**
	     * local尺寸y分量
	     *
	     * @type {number}
	     * @memberof Transform3D
	     */
	    get sizeY(): number;
	    set sizeY(val: number);
	    /**
	     * local锚点
	     *
	     * @type {Vector2}
	     * @memberof Transform3D
	     */
	    get anchor(): Vector2;
	    set anchor(val: Vector2);
	    /**
	     * local锚点
	     * 也支持通过pivot获取和设置
	     * @type {Vector2}
	     * @memberof Transform3D
	     */
	    get pivot(): Vector2;
	    set pivot(val: Vector2);
	    /**
	     * 本地锚点x分量
	     *
	     * @type {number}
	     * @memberof Transform3D
	     */
	    get anchorX(): number;
	    set anchorX(val: number);
	    /**
	     * 本地锚点y分量
	     *
	     * @type {number}
	     * @memberof Transform3D
	     */
	    get anchorY(): number;
	    set anchorY(val: number);
	    /**
	     * 请使用engine.game.createEntity3D(name)创建3D对象
	     *
	     * @param {Entity3D} entity
	     * @param {Float32Array} [_rawNativeValue]
	     * @param {Float32Array} [_raw]
	     * @param {number} [_offset]
	     * @memberof Transform3D
	     */
	    constructor(entity: Entity3D,rawNativeValue?: Float32Array);
	    /**
	     * 在当前节点前插入新的节点, 新插入的节点世界矩阵不变
	     * @param {Transform3D} child 要插入的节点
	     * @returns {boolean} 是否插入成功
	     * @memberof Transform3D
	     */
	    immovableBefore(child: Transform3D): boolean;
	    /**
	     * 在当前节点后插入新的节点, 新插入的节点世界矩阵不变
	     * @param {Transform3D} child 要插入的节点
	     * @returns {boolean} 是否插入成功
	     * @memberof Transform3D
	     */
	    immovableAfter(child: Transform3D): boolean;
	    /**
	     * 把当前节点添加到指定的parent节点里，作为其子节点。 当前节点世界矩阵不变
	     * @param {Transform3D} parent 当前节点移动后的parent
	     * @returns {boolean} 是否插入成功
	     * @memberof Transform3D
	     */
	    immovableAppendTo(parent: Transform3D): boolean;
	    /**
	     * 添加子节点，若子节点已存在父节点，则会先移除其父节点
	     * 子节点必须是Transform3D
	     *
	     * @param {Transform3D} child 子节点
	     * @returns {boolean} 添加是否成功
	     * @memberof Transform3D
	     */
	    addChild(child: Transform3D): boolean;
	    /**
	     * 添加子节点到指定index，若子节点已存在父节点，则会先移除其父节点
	     * 子节点必须是Transform3D
	     *
	     * @param {Transform3D} child 子节点
	     * @param {number} index index顺序
	     * @returns {boolean} 添加是否成功
	     * @memberof Transform3D
	     */
	    addChildAtIndex(child: Transform3D, index: number): boolean;
	    /**
	     * 移除子节点
	     *
	     * @param {Transform3D} child 子节点
	     * @returns {boolean} 是否移除成功
	     * @memberof Transform3D
	     */
	    removeChild(child: Transform3D): boolean;
	    /**
	     * 将世界坐标转换为本地坐标系坐标
	     *
	     * @param {V3ReadOnly} worldPosition 世界坐标
	     * @param {Vector3} [dst] 是否将计算结果输出到Dst
	     * @returns {Vector3} 本地坐标系坐标
	     * @memberof Transform3D
	     */
	    convertWorldPositionToLocal(worldPosition: V3ReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 对自身做旋转变换。
	     *
	     * @param {Vector3} rotation 旋转幅度。
	     * @param {boolean} [isLocal] 是否局部空间。
	     * @param {boolean} [isRadian] 是否弧度制。
	     * @memberof Transform3D
	     */
	    rotate(rotation: V3ReadOnly, isLocal?: boolean, isRadian?: boolean): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/OBB' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	export default class OBB {
	    constructor();
	    setValues(cenX: number, cenY: number, cenZ: number, forward: Vector3, w: number, h: number, d: number): void;
	    get center(): Vector3;
	    set center(pos: Vector3);
	    get width(): number;
	    set width(w: number);
	    get height(): number;
	    set height(h: number);
	    get depth(): number;
	    set depth(d: number);
	    setForward(forward: Vector3): void;
	    get AxisX(): Vector3;
	    get AxisY(): Vector3;
	    get AxisZ(): Vector3;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/intersection' {
	import BoundBall from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall';
	import OBB from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/OBB';
	export function spheresIntersect(ballA: BoundBall, ballB: BoundBall): boolean;
	export function OBBIntersectSphere(obb: OBB, ball: BoundBall): boolean;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/baseLight' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	export default class BaseLight extends Component {
	    readonly entity: Entity3D;
	    isMainLight: boolean;
	    get intensity(): number;
	    set intensity(val: number);
	    get color(): Vector3;
	    set color(val: Vector3);
	    constructor(entity: Entity3D);
	    setAsMainLight(): void;
	    setAsLocalLight(): void;
	    affectEntity(entity: Entity): boolean;
	    affectBoundMesh(meshRenderer: MeshRenderer): boolean;
	    /**
	     * 将光源移除场景，并从meshRenderer的局部光源列表中删除
	     */
	    removeFromScene(): void;
	    /**
	     * 将光源加入场景，记录在受影响的meshRenderer中
	     */
	    addToScene(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/pointLight' {
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import BoundBall from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall';
	import BaseLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/baseLight';
	/**
	 * @public
	 */
	export default class PointLight extends BaseLight {
	    readonly entity: Entity3D;
	    get range(): number;
	    set range(val: number);
	    get intensity(): number;
	    set intensity(val: number);
	    get fallOff(): number;
	    set fallOff(val: number);
	    get position(): import('engine').Vector3;
	    constructor(entity: Entity3D);
	    addAffectObject(object: MeshRenderer): void;
	    removeAffectObject(object: MeshRenderer): void;
	    affectEntity(entity: Entity): boolean;
	    affectBoundMesh(meshRenderer: MeshRenderer): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/spotLight' {
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import PointLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/pointLight';
	/**
	 * @public
	 */
	export default class SpotLight extends PointLight {
	    readonly entity: Entity3D;
	    /**
	     * 聚光源range
	     *
	     * @type {number}
	     * @memberof SpotLight
	     */
	    get range(): number;
	    set range(val: number);
	    get spotAngle(): number;
	    set spotAngle(val: number);
	    get direction(): V3ReadOnly;
	    get cosAngle(): number;
	    get invCosDiff(): number;
	    constructor(entity: Entity3D);
	    affectBoundMesh(meshRenderer: MeshRenderer): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/directionalLight' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import BaseLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/baseLight';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	/**
	 * @public
	 */
	export default class DirectionalLight extends BaseLight {
	    readonly entity: Entity3D;
	    /**
	     * 阴影强度
	     *
	     * @type {number}
	     * @memberof DirectionalLight
	     */
	    shadowStrength: number;
	    /**
	     * 平行光方向，只读，修改无效
	     *
	     * @readonly
	     * @type {Vector3}
	     * @memberof DirectionalLight
	     */
	    get direction(): Vector3;
	    constructor(entity: Entity3D);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import BoundBall from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall';
	import Vector4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4';
	import { Entity2D, Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import Mesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	/**
	 * ForwardAdd流程的剔除信息。
	 */
	export interface LightUniformInfo {
	    lightPosFA: Float32Array;
	    lightColorFA: Float32Array;
	    lightAttenFA: Float32Array;
	    spotDirFA: Float32Array;
	}
	/**
	 * Mesh剔除类型。
	 */
	export enum EMeshCullType {
	    Default = 0,
	    /** 强制剔除，不进入剔除结果 */
	    Force = 1,
	    /** 永不剔除，直接进入剔除结果 */
	    Never = 2
	}
	/**
	 * 模型渲染组件。
	 */
	export default class MeshRenderer extends Component {
	    readonly entity: Entity3D | Entity2D;
	    protected get lightFAUniforms(): LightUniformInfo;
	    /**
	     * 上一帧是否被任意相机渲染。
	    */
	    get lastFrameVisible(): boolean;
	    /**
	     * 设置该MeshRenderer渲染的Mesh。
	     */
	    get mesh(): Nullable<Mesh>;
	    set mesh(val: Nullable<Mesh>);
	    /**
	     * 世界坐标系下的包围球。
	     */
	    get worldBoundBall(): BoundBall;
	    set lightMap(val: Nullable<Texture2D>);
	    /**
	     * 光照贴图的scaleOffset
	     * 暂时不支持 meshRenderer.lightMapScaleOffset.x = 1这种写法
	     */
	    get lightMapScaleOffset(): Vector4;
	    set lightMapScaleOffset(l: Vector4);
	    /**
	     * 是否投射阴影
	     */
	    get castShadow(): boolean;
	    set castShadow(s: boolean);
	    /**
	     * 是否接收阴影
	     */
	    get receiveShadow(): boolean;
	    set receiveShadow(s: boolean);
	    /**
	     * 剔除掩码，由entity的layer计算得出。
	     * 剔除时将使用该值与Camera的cullingMask做按位与，有值时才渲染。
	     */
	    get cullingMask(): number;
	    /**
	     * @deprecated
	     */
	    set cullingMask(value: number);
	    /**
	     * 光照贴图索引。
	     */
	    get lightMapIndex(): number;
	    set lightMapIndex(s: number);
	    /**
	     * 是否开启3D Batch。
	     */
	    get dynamicBatch(): boolean;
	    set dynamicBatch(val: boolean);
	    setLightsUniformDirty(): void;
	    refreshLightsUniformFA(): void;
	    /**
	     * 获取当前材质数量。
	     */
	    get materialCount(): number;
	    /**
	     * 获取共享主材质。
	     */
	    get sharedMaterial(): Nullable<Material>;
	    /**
	     * 主材质。
	     */
	    get material(): Nullable<Material>;
	    set material(material: Nullable<Material>);
	    /**
	     * 请使用entity.addComponent(engine.MeshRenderer)来创建
	     */
	    constructor(entity: Entity3D | Entity2D);
	    /**
	     * 获取第index位材质，当第一次获取成功时，该材质会被拷贝，并将替换材质。
	     */
	    getMaterialAtIndex(index: number): Nullable<Material>;
	    /**
	     * 获取第index位材质的sharedMaterial，此操作不会进行材质拷贝。
	     */
	    getSharedMaterialAtIndex(index: number): Nullable<Material>;
	    /**
	     * 增加材质。
	     */
	    addMaterial(material: Material): void;
	    /**
	     * 设置第n个位置的材质。
	     */
	    setMaterialAtIndex(material: Nullable<Material>, index: number): void;
	    minimizeMaterialsToShortest(): void;
	    addToRenderList(list: Uint32Array, index: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/gradientColor' {
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	interface IColorViewdata {
	    location: number;
	    r: number;
	    g: number;
	    b: number;
	    a: number;
	}
	export interface ISerializeData {
	    mode: GradientColor.GradientMode;
	    alpha: number[];
	    color: number[];
	} class GradientColor {
	    /**
	     * 获取渐变色中precent位置的透明度。
	     *
	     * @static
	     * @param {number} percent 取值范围 0-1。
	     * @param {GradientColor} gColor
	     * @returns {number}
	     * @memberof GradientColor
	     */
	    static GetAlpha(percent: number, gColor: GradientColor): number;
	    /**
	     * 获取渐变色中precent位置的颜色，只保证RGB返回正确的值，alpha获取可以使用GetAlpha静态方法。
	     *
	     * @static
	     * @param {number} percent 取值范围 0-1。
	     * @param {GradientColor} gColor
	     * @param {Color} [dst]
	     * @returns {Color} 其中RGB三个通道的值可信，Alpha值不是最终的值。
	     * @memberof GradientColor
	     */
	    static GetColor(percent: number, gColor: GradientColor, dst?: Color): Color;
	    /**
	     * 获取渐变色中precent位置的颜色。
	     * @static
	     * @param {number} percent 取值范围 0-1。
	     * @param {GradientColor} gColor
	     * @param {Color} [dst]
	     * @returns {Color}
	     * @memberof GradientColor
	     */
	    static GetMixedColor(percent: number, gColor: GradientColor, dst?: Color): Color;
	    /**
	     * 通过Color的数组来创建渐变色。
	     * @static
	     * @param {Color[]} colors
	     * @returns {GradientColor}
	     * @memberof GradientColor
	     */
	    static CreateFromColorArr(colors: Color[]): GradientColor;
	    /**
	     * 根据颜色（RGB）以及透明度（A）的数组信息来创建渐变色。
	     *
	     * @static
	     * @param {Array<GradientColor.IGradientPoint<Color>>} colorsInfo
	     * @param {Array<GradientColor.IGradientPoint<number>>} alphasInfo
	     * @returns {GradientColor}
	     * @memberof GradientColor
	     */
	    static CreateFromColorAlphaInfos(colorsInfo: Array<GradientColor.IGradientPoint<Color>>, alphasInfo: Array<GradientColor.IGradientPoint<number>>): GradientColor;
	    /**
	     * 渐变色模式。
	     * @type {GradientColor.GradientMode}
	     * @memberof GradientColor
	     */
	    mode: GradientColor.GradientMode;
	    constructor(alphaRaw?: Float32Array, colorRaw?: Float32Array);
	    /**
	     * 颜色关键点数量。
	     *
	     * @readonly
	     * @memberof GradientColor
	     */
	    get colorPointCount(): number;
	    /**
	     * 透明度关键点数量。
	     *
	     * @readonly
	     * @memberof GradientColor
	     */
	    get alphaPointCount(): number;
	    /**
	     * 设置透明度信息。
	     *
	     * @param {Array<GradientColor.IGradientPoint<number>>} alphasInfo
	     * @returns
	     * @memberof GradientColor
	     */
	    setAlphasInfo(alphasInfo: Array<GradientColor.IGradientPoint<number>>): void;
	    /**
	     * 设置颜色信息（RGB）。
	     *
	     * @param {(Array<GradientColor.IGradientPoint<Color> | IColorViewdata>)} colorsInfo
	     * @returns
	     * @memberof GradientColor
	     */
	    setColorsInfo(colorsInfo: Array<GradientColor.IGradientPoint<Color> | IColorViewdata>): void;
	    /**
	     * 拷贝渐变色
	     * @returns {GradientColor}
	     * @memberof GradientColor
	     */
	    clone(): GradientColor;
	    /**
	     * 通过渐变色获取对应的color和alpha的数组。
	     * @returns {GradientColor.IGradientColorInfo}
	     * @memberof GradientColor
	     */
	    getGradientColorInfo(): GradientColor.IGradientColorInfo;
	} namespace GradientColor {
	    /** 渐变色信息接口 */
	    interface IGradientColorInfo {
	        /** 颜色关键点 */
	        colors: GradientPointColor[];
	        /** 透明度关键点 */
	        alphas: GradientPointAlpha[];
	    }
	    interface IGradientPoint<T extends number | Color> {
	        /** 渐变色关键点的位置，取值范围[0,1] */
	        location: number;
	        /** 渐变色关键点的值 */
	        value: T;
	    }
	    /** 渐变色关键点透明值类型 */
	    type GradientPointAlpha = IGradientPoint<number>;
	    /** 渐变色关键点颜色值类型 */
	    type GradientPointColor = IGradientPoint<Color>;
	    /** 渐变模式 */
	    enum GradientMode {
	        /** 线性插值。 */
	        Blend = 1,
	        /** 取区间的起始值 */
	        Fixed = 2
	    }
	}
	export default GradientColor;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hermiteCurve' {
	export interface ISerializeData {
	    x: number[];
	    y: number[];
	    in: number[];
	    out: number[];
	} class HermiteCurve {
	    /**
	     * 根据创建关键点，创建曲线。
	     * @static
	     * @param {CurvePoint[]} points
	     * @returns {HermiteCurve}
	     * @memberof HermiteCurve
	     */
	    static CreateFromPoints(points: HermiteCurve.CurvePoint[], multiplier?: number): HermiteCurve;
	    /** 定点数量。 */
	    get keyPointCount(): number;
	    constructor(raw?: Float32Array);
	    /**
	     * 设置曲线关键点。
	     *
	     * @param {Array<HermiteCurve.CurvePoint>} points
	     * @memberof HermiteCurve
	     */
	    setPoints(points: Array<HermiteCurve.CurvePoint>): void;
	    /**
	     * 计算曲线插值结果。
	     * 插值计算参考 https://www.cubic.org/docs/hermite.htm 。
	     *
	     * @param {number} x 取值范围[0,1]
	     * @returns {number}
	     * @memberof HermiteCurve
	     */
	    get(x: number): number;
	    /**
	     * 获取曲线的关键点。
	     *
	     * @param {number} [multiplier=1]
	     * @returns {HermiteCurve.CurvePoint[]}
	     * @memberof HermiteCurve
	     */
	    getCurvePoints(multiplier?: number): HermiteCurve.CurvePoint[];
	    /**
	     * 拷贝曲线。
	     * @returns {HermiteCurve}
	     * @memberof HermiteCurve
	     */
	    clone(withMultiplier?: boolean): HermiteCurve;
	    /**
	     * 判断两个HermiteCurve的值是否相同。
	     *
	     * @param {HermiteCurve} target
	     * @returns {boolean}
	     * @memberof HermiteCurve
	     */
	    equal(target: HermiteCurve): boolean;
	} namespace HermiteCurve {
	    interface CurvePoint {
	        /** 曲线关键点所在的时间点，取值范围0-1。 */
	        x: number;
	        /** 曲线关键点的值。 */
	        y: number;
	        /** 曲线关键点的inTangent */
	        in: number;
	        /** 曲线关键点的outTangent */
	        out: number;
	    }
	    interface CurvePointsWithMultiplier {
	        /** 曲线的关键点。 */
	        curvePoints: CurvePoint[];
	        /** 曲线y值所需乘的倍数。 */
	        multiplier: number;
	    }
	}
	export default HermiteCurve;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty' {
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import GradientColor from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/gradientColor';
	import HermiteCurve from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hermiteCurve';
	export const randomBetween: (v1: number, v2: number, randomSeed?: number) => number; abstract class AdvancedProperty {
	    abstract get(t?: number): any;
	    abstract getRaw(): Float32Array;
	    abstract getMax(): any;
	    abstract clone(): AdvancedProperty;
	    abstract getUniformType(): Float32Array | Float32Array[];
	    abstract getUniformArrayData(): number[] | Array<number[]>;
	}
	export { GradientColor, HermiteCurve }; namespace AdvancedPropertyClass {
	    class ConstantProperty extends AdvancedProperty {
	        /**
	         * 常数值
	         *
	         * @type {number}
	         * @memberof ConstantProperty
	         */
	        value: number;
	        constructor(value?: number);
	        get(t?: number): number;
	        /**
	         * 获取最大值，也就是常数值本身
	         *
	         * @returns {number}
	         * @memberof ConstantProperty
	         */
	        getMax(): number;
	        /**
	         * 把value赋给一个dst中的第一个值
	         *
	         * @param {Float32Array} [dst]
	         * @returns {Float32Array}
	         * @memberof ConstantProperty
	         */
	        getRaw(dst?: Float32Array): Float32Array;
	        clone(): ConstantProperty;
	        getUniformType(dst?: Float32Array): Float32Array;
	        getUniformArrayData(dst?: number[]): number[];
	    }
	    class CurveProperty extends AdvancedProperty {
	        static HermiteCurve: typeof HermiteCurve;
	        curve: HermiteCurve;
	        constructor(curve?: HermiteCurve);
	        get(t: number): number;
	        getRaw(dst?: Float32Array): Float32Array;
	        getMax(): number;
	        getUniformType(dst?: Float32Array): Float32Array;
	        clone(): CurveProperty;
	        getUniformArrayData(dst?: number[]): number[];
	    }
	    class GradientProperty extends AdvancedProperty {
	        static initGradientProperty(): GradientProperty;
	        gColor: GradientColor;
	        constructor(gColor?: GradientColor);
	        get(percent: number): Color;
	        getRaw(dst?: Float32Array): Float32Array;
	        getMax(): any;
	        getUniformType(colorDst?: Float32Array, alphaDst?: Float32Array): Float32Array[];
	        getUniformArrayData(colorDst?: number[], alphaDst?: number[]): Array<number[]>;
	        clone(): GradientProperty;
	    }
	    class OneColorProperty extends AdvancedProperty {
	        color: Color;
	        constructor(color?: Color);
	        get(): Color;
	        getRaw(dst?: Float32Array): Float32Array;
	        getMax(): any;
	        getUniformType(): never[];
	        clone(): OneColorProperty;
	        getUniformArrayData(): never[];
	    }
	    class TwoConstantsProperty extends AdvancedProperty {
	        min: number;
	        max: number;
	        constructor(min?: number, max?: number);
	        get(t?: number): number;
	        getRaw(dst?: Float32Array): Float32Array;
	        getMax(): number;
	        getUniformType(dst?: Float32Array): Float32Array;
	        getUniformArrayData(dst?: number[]): number[];
	        clone(): TwoConstantsProperty;
	    }
	    class TwoCurvesProperty extends AdvancedProperty {
	        min: HermiteCurve;
	        max: HermiteCurve;
	        constructor(min?: HermiteCurve, max?: HermiteCurve);
	        get(t: number): number;
	        getRaw(dst?: Float32Array): Float32Array;
	        getMax(): number;
	        clone(): TwoCurvesProperty;
	        getUniformType(dst?: Float32Array): Float32Array;
	        getUniformArrayData(dst?: number[]): number[];
	    }
	    class TwoGradientsProperty extends AdvancedProperty {
	        min: GradientColor;
	        max: GradientColor;
	        constructor(min?: GradientColor, max?: GradientColor);
	        get(percent: number): Color;
	        getRaw(dst?: Float32Array): Float32Array;
	        getMax(): any;
	        getUniform(colorDst1: Float32Array | number[], alphaDst1: Float32Array | number[], colorDst2: Float32Array | number[], alphaDst2: Float32Array | number[]): number[][] | Float32Array[];
	        clone(): TwoGradientsProperty;
	        getUniformType(colorDst1?: Float32Array, alphaDst1?: Float32Array, colorDst2?: Float32Array, alphaDst2?: Float32Array): Float32Array[];
	        getUniformArrayData(colorDst1?: number[], alphaDst1?: number[], colorDst2?: number[], alphaDst2?: number[]): number[][];
	    }
	    class TwoColorsProperty extends AdvancedProperty {
	        min: Color;
	        max: Color;
	        constructor(min?: Color, max?: Color);
	        get(): Color;
	        getRaw(dst?: Float32Array): Float32Array;
	        getMax(): any;
	        getUniformType(): never[];
	        clone(): TwoColorsProperty;
	        getUniformArrayData(): never[];
	    }
	}
	export default AdvancedPropertyClass;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/boxShape' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { default as ParticleShape } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/shape'; enum EEmitFromBox {
	    Volume = 1,
	    Shell = 2,
	    Edge = 3
	} class ParticleBoxShape extends ParticleShape {
	    /**
	     * 粒子从盒子的哪个位置喷射。
	     * @type {ParticleBoxShape.EmitFromBox}
	     * @memberof ParticleBoxShape
	     */
	    get emitFrom(): ParticleBoxShape.EmitFromBox;
	    set emitFrom(val: ParticleBoxShape.EmitFromBox);
	    set boxThickness(val: Vector3);
	} namespace ParticleBoxShape {
	    export import EmitFromBox = EEmitFromBox;
	}
	export default ParticleBoxShape;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/arcShape' {
	import { ArcMode, ParticleShape } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/shape';
	export default class ParticleArcShape extends ParticleShape {
	    /**
	     * 弧半径。
	     * @type {number}
	     * @memberof ParticleArcShape
	     */
	    get radius(): number;
	    set radius(val: number);
	    /**
	     * 弧半径厚度。
	     * @type {number}
	     * @memberof ParticleArcShape
	     */
	    get radiusThickness(): number;
	    set radiusThickness(val: number);
	    /**
	     * 弧角度。
	     * @type {number}
	     * @memberof ParticleArcShape
	     */
	    get arc(): number;
	    set arc(val: number);
	    /**
	     * 发射模式。
	     * @type {ArcMode}
	     * @memberof ParticleArcShape
	     */
	    get arcMode(): ArcMode;
	    set arcMode(val: ArcMode);
	    /**
	     * 0 to 1 控制粒子角度间隔，值为0将允许粒子在任何角度生成，0.1将仅在形状周围以10%间隔产生粒子；非ArcMode.Random时有效。
	     * @type {number}
	     * @memberof ParticleArcShape
	     */
	    get arcSpread(): number;
	    set arcSpread(val: number);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/circleShape' {
	import ParticleArcShape from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/arcShape';
	import { ArcMode as ArcModeEnum } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/shape'; class ParticleCircleShape extends ParticleArcShape {
	} namespace ParticleCircleShape {
	    const ArcMode: typeof ArcModeEnum;
	}
	export default ParticleCircleShape;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/coneShape' {
	import ParticleArcShape from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/arcShape'; enum EEmitFromCone {
	    Base = 1,
	    Volume = 2
	} class ParticleConeShape extends ParticleArcShape {
	    /**
	     * 圆锥的角度
	     * @type {number}
	     * @memberof ParticleConeShape
	     */
	    get angle(): number;
	    set angle(val: number);
	    /**
	     * 圆锥母线长度
	     * @type {number}
	     * @memberof ParticleConeShape
	     */
	    get length(): number;
	    set length(val: number);
	    /**
	     * 粒子发射的位置
	     * @type {ParticleConeShape.EmitFromCone}
	     * @memberof ParticleConeShape
	     */
	    get emitFrom(): ParticleConeShape.EmitFromCone;
	    set emitFrom(val: ParticleConeShape.EmitFromCone);
	} namespace ParticleConeShape {
	    export import EmitFromCone = EEmitFromCone;
	}
	export default ParticleConeShape;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hemiSphereShape' {
	import ParticleArcShape from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/arcShape';
	import { ArcMode as ArcModeEnum } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/shape'; class ParticleHemiSphereShape extends ParticleArcShape {
	} namespace ParticleHemiSphereShape {
	    const ArcMode: typeof ArcModeEnum;
	}
	export default ParticleHemiSphereShape;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/sphereShape' {
	import ParticleArcShape from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/arcShape';
	import { ArcMode as ArcModeEnum } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/shape'; class ParticleSphereShape extends ParticleArcShape {
	} namespace ParticleSphereShape {
	    const ArcMode: typeof ArcModeEnum;
	}
	export default ParticleSphereShape;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule' {
	import type Particle from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle';
	interface ParticleModule {
	} abstract class ParticleModule {
	    static configToArray(config: any, offset: number, bufferData?: number[]): void;
	    constructor(particle: Particle);
	}
	export default ParticleModule;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleEmitterShape' {
	import ParticleBoxShapeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/boxShape';
	import ParticleCircleShapeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/circleShape';
	import ParticleConeShapeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/coneShape';
	import ParticleHemiSphereShapeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hemiSphereShape';
	import ParticleSphereShapeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/sphereShape';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; class ParticleEmitterShape extends ParticleModule {
	    /**
	     * 发射器形状。
	     *
	     * @type {(ParticleBoxShapeClass | ParticleConeShapeClass | ParticleHemiSphereShapeClass | ParticleSphereShapeClass | ParticleCircleShapeClass)}
	     * @memberof ParticleEmitterShape
	     */
	    shape?: ParticleBoxShapeClass | ParticleConeShapeClass | ParticleHemiSphereShapeClass | ParticleSphereShapeClass | ParticleCircleShapeClass;
	    constructor(particle: Particle);
	} namespace ParticleEmitterShape {
	    /**
	       * 盒形发射器。
	       */
	    export import ParticleBoxShape = ParticleBoxShapeClass;
	    /**
	     * 圆锥形发射器。
	     */
	    export import ParticleConeShape = ParticleConeShapeClass;
	    /**
	     * 环形发射器。
	     */
	    export import ParticleCircleShape = ParticleCircleShapeClass;
	    /**
	     * 半球形发射器。
	     */
	    export import ParticleHemiSphereShape = ParticleHemiSphereShapeClass;
	    /**
	     * 球形发射器。
	     */
	    export import ParticleSphereShape = ParticleSphereShapeClass;
	}
	export default ParticleEmitterShape;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/shape' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { IParticleEmitterShapeOffsetMap } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/interface'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default;
	export enum ArcMode {
	    Random = 1,
	    Loop = 2,
	    PingPong = 3,
	    BurstSpread = 4
	}
	export class ParticleShape {
	    static ArcMode: typeof ArcMode;
	    static GetShapeDefaultOffsetMap(): {
	        position: {
	            type: string;
	            realBuffer: Float32Array;
	            rawDataOffset: number;
	        };
	        rotation: {
	            type: string;
	            realBuffer: Float32Array;
	            rawDataOffset: number;
	        };
	        scale: {
	            type: string;
	            realBuffer: Float32Array;
	            rawDataOffset: number;
	        };
	    };
	    set position(val: Vector3);
	    set rotation(val: Vector3);
	    /**
	     * 发射器形状的缩放。(仅在BoxShape中有效)
	     * @type {Vector3}
	     * @memberof ParticleShape
	     */
	    get scale(): Vector3;
	    set scale(val: Vector3);
	}
	export default ParticleShape;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/interface' {
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/bufferManager' {
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleColorByLife' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; type GradientProperty = AdvancedPropertyClass.GradientProperty; const GradientProperty: typeof AdvancedPropertyClass.GradientProperty; type TwoGradientsProperty = AdvancedPropertyClass.TwoGradientsProperty; const TwoGradientsProperty: typeof AdvancedPropertyClass.GradientProperty;
	export enum ColorProperties {
	    gColor = "gColor"
	} class ParticleColorByLife extends ParticleModule {
	    constructor(particle: Particle);
	    /**
	     * 渐变色信息。
	     * @type {(GradientProperty | TwoGradientsProperty)}
	     * @memberof ParticleColorByLife
	     */
	    get gColor(): GradientProperty | TwoGradientsProperty;
	    set gColor(val: GradientProperty | TwoGradientsProperty);
	} namespace ParticleColorByLife {
	}
	export default ParticleColorByLife;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleRenderer' {
	import Mesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; enum ERenderMode {
	    /** 不渲染。 */
	    None = 0,
	    /** 始终面向相机。*/
	    Billboard = 1,
	    /** 始终以粒子运动的方向为轴旋转。*/
	    StretchedBillboard = 2,
	    /** 始终垂直于Y轴。*/
	    HorizontalBillboard = 3,
	    /** 始终沿Y轴旋转。*/
	    VerticalBillboard = 4,
	    /** Mesh类型的粒子，需要给ParticleRenderer上设置mesh属性。*/
	    Mesh = 5
	} enum ERenderAlignment {
	    /** 粒子始终垂直于相机的Forward。*/
	    View = 1,
	    /** 粒子与世界轴对齐，也就是世界z轴。*/
	    World = 2,
	    /** 粒子与entity的Transform组件对齐，也就是与entity的z轴对齐。*/
	    Local = 3,
	    /** 粒子始终垂直于相机的worldPosition到粒子的worldPosition的向量。*/
	    Facing = 4
	} class ParticleRenderer extends ParticleModule {
	    /**
	     * 根据速度计算粒子的大小在速度方向的拉伸长度（仅在strechedBillboard可用）。
	     * @type {number}
	     * @memberof ParticleRenderer
	     */
	    get speedScale(): number;
	    set speedScale(val: number);
	    /**
	     * 沿着粒子速度方向按比例拉伸粒子的当前尺寸。将此值设置为0会使粒子消失，有效长度为0。（仅在strechedBillboard可用）
	     * @type {number}
	     * @memberof ParticleRenderer
	     */
	    get lengthScale(): number;
	    set lengthScale(val: number);
	    /**
	     * 粒子的mesh，若renderMode为Mesh，则必须对此属性赋值
	     * @type {Mesh | undefined}
	     * @memberof ParticleRenderer
	     */
	    get mesh(): Mesh | undefined;
	    set mesh(val: Mesh | undefined);
	    /**
	     * 粒子渲染模式
	     * @type {ParticleRenderer.RenderMode}
	     * @memberof ParticleRenderer
	     */
	    get renderMode(): ParticleRenderer.RenderMode;
	    set renderMode(val: ParticleRenderer.RenderMode);
	    /**
	     * 对齐方式，决定Billboard粒子的朝向。
	     * @type {ParticleRenderer.RenderAlignment}
	     * @memberof ParticleRenderer
	     */
	    get renderAlignment(): ParticleRenderer.RenderAlignment;
	    set renderAlignment(val: ParticleRenderer.RenderAlignment);
	    constructor(particle: Particle);
	} namespace ParticleRenderer {
	    /** 渲染模式。 */
	    export import RenderMode = ERenderMode;
	    /** 渲染朝向。 */
	    export import RenderAlignment = ERenderAlignment;
	}
	export default ParticleRenderer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleRotationByLife' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; type ConstantProperty = AdvancedPropertyClass.ConstantProperty; type CurveProperty = AdvancedPropertyClass.CurveProperty; type TwoConstantsProperty = AdvancedPropertyClass.TwoConstantsProperty; type TwoCurvesProperty = AdvancedPropertyClass.TwoCurvesProperty; type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
	export enum RotationProperties {
	    separateAxes = "separateAxes",
	    x = "x",
	    y = "y",
	    z = "z"
	} class ParticleRotationByLife extends ParticleModule {
	    /**
	     * 旋转时是否三个轴分开计算。
	     * @type {boolean}
	     * @memberof ParticleRotationByLife
	     */
	    get separateAxes(): boolean;
	    set separateAxes(val: boolean);
	    /**
	     * separateAxes开启时，x轴的旋转角度的变化情况。
	     * @type {(AdvancedProperty | undefined)}
	     * @memberof ParticleRotationByLife
	     */
	    get x(): AdvancedProperty | undefined;
	    set x(val: AdvancedProperty | undefined);
	    /**
	     * separateAxes开启时，y轴的旋转角度的变化情况。
	     * @type {(AdvancedProperty | undefined)}
	     * @memberof ParticleRotationByLife
	     */
	    get y(): AdvancedProperty | undefined;
	    set y(val: AdvancedProperty | undefined);
	    /**
	     * separateAxes开启时，z轴的旋转角度的变化情况。
	     * separateAxes不开启时，默认旋转角度的变化情况。
	     * @type {(AdvancedProperty | undefined)}
	     * @memberof ParticleRotationByLife
	     */
	    get z(): AdvancedProperty;
	    set z(val: AdvancedProperty);
	    constructor(particle: Particle);
	} namespace ParticleRotationByLife {
	}
	export default ParticleRotationByLife;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleCommon' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; type ConstantProperty = AdvancedPropertyClass.ConstantProperty; type CurveProperty = AdvancedPropertyClass.CurveProperty; type TwoConstantsProperty = AdvancedPropertyClass.TwoConstantsProperty; type TwoCurvesProperty = AdvancedPropertyClass.TwoCurvesProperty; enum EScalingMode {
	    /** 粒子大小受WorldScale的影响。*/
	    Hierarchy = 0,
	    /** 粒子大小不受WorldScale影响，受到LocalScale影响。*/
	    Local = 1,
	    /** 粒子大小不受WorldScale和LocalScale影响。*/
	    Shape = 2
	} enum ESimulationSpace {
	    /** 粒子喷射后在Local空间。*/
	    Local = 0,
	    /** 粒子喷射后在World空间。*/
	    World = 1
	} class ParticleCommon extends ParticleModule {
	    /**
	     * 是否开启XYZ三个方向的大小设置。
	     * @type {boolean}
	     * @memberof ParticleCommon
	     */
	    get startSize3D(): boolean;
	    set startSize3D(val: boolean);
	    /**
	     * 是否开启XYZ三个方向的旋转设置。
	     * @type {boolean}
	     * @memberof ParticleCommon
	     */
	    get startRotation3D(): boolean;
	    set startRotation3D(val: boolean);
	    /**
	     * 缩放模式设置。
	     * @type {ParticleCommon.ScalingMode}
	     * @memberof ParticleCommon
	     */
	    get scalingMode(): ParticleCommon.ScalingMode;
	    set scalingMode(val: ParticleCommon.ScalingMode);
	    /**
	     * 模拟粒子在世界空间或本地空间。
	     * @type {ParticleCommon.SimulationSpace}
	     * @memberof ParticleCommon
	     */
	    get simulationSpace(): ParticleCommon.SimulationSpace;
	    set simulationSpace(val: ParticleCommon.SimulationSpace);
	    /**
	     * 粒子的生命时长（单位 秒）。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined)}
	     * @memberof ParticleCommon
	     */
	    get startLifetime(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
	    set startLifetime(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
	    /**
	     * 每个粒子的初始大小。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startSize(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startSize(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 开启startSize3D时，粒子在x轴的大小。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startSizeX(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startSizeX(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 开启startSize3D时，粒子在y轴的大小。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startSizeY(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startSizeY(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 开启startSize3D时，粒子在z轴的大小。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startSizeZ(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startSizeZ(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 开启startRotation3D时，粒子在x轴的旋转值（角度）。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startRotationX(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startRotationX(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 开启startRotation3D时，粒子在y轴的旋转值（角度）。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startRotationY(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startRotationY(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 开启startRotation3D时，粒子在z轴的旋转值（角度）。
	     * 不开启startRotation3D时，粒子的初始旋转角度，即startRotation。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startRotationZ(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startRotationZ(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 兼容旧版本逻辑，新版本没有startRotation属性，旧版本的startRotation对应新版本的startRotationZ。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined)}
	     * @memberof ParticleCommon
	     */
	    get startRotation(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
	    set startRotation(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
	    /**
	     * 粒子初始颜色。
	     * @type {(OneColorProperty | GradientProperty | TwoColorsProperty | TwoGradientsProperty)}
	     * @memberof ParticleCommon
	     */
	    get startColor(): AdvancedPropertyClass.GradientProperty | AdvancedPropertyClass.OneColorProperty | AdvancedPropertyClass.TwoGradientsProperty | AdvancedPropertyClass.TwoColorsProperty | undefined;
	    set startColor(val: AdvancedPropertyClass.GradientProperty | AdvancedPropertyClass.OneColorProperty | AdvancedPropertyClass.TwoGradientsProperty | AdvancedPropertyClass.TwoColorsProperty | undefined);
	    /**
	     * 粒子初始速度。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleCommon
	     */
	    get startSpeed(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set startSpeed(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    constructor(particle: Particle);
	} namespace ParticleCommon {
	    /**
	     * 粒子的缩放模式。
	     */
	    export import ScalingMode = EScalingMode;
	    /**
	     * 粒子模拟的空间。
	     */
	    export import SimulationSpace = ESimulationSpace;
	}
	export default ParticleCommon;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/emitterBurst' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	export enum BurstProperties {
	    count = "count",
	    time = "time",
	    cycles = "cycles",
	    probability = "probability",
	    interval = "interval"
	} class ParticleEmitterBurst {
	    /**
	     * 触发的时间/s
	     * @type {number}
	     * @memberof ParticleEmitterBurst
	     */
	    get time(): number;
	    set time(val: number);
	    /**
	     * 每次发射的粒子数
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleEmitterBurst
	     */
	    get count(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set count(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    get countInitVal(): number;
	    get countMaxVal(): number;
	    /**
	     * 循环次数，0=infinite
	     * @type {number}
	     * @memberof ParticleEmitterBurst
	     */
	    get cycles(): number;
	    set cycles(val: number);
	    /**
	     * 触发的可能性，为0是，当做是1处理，因为unity 2017版本以前没有这个字段
	     * @type {number}
	     * @memberof ParticleEmitterBurst
	     */
	    get probability(): number;
	    set probability(val: number);
	    /**
	     * 每次循环的间隔/s，必须大于0
	     * @type {number}
	     * @memberof ParticleEmitterBurst
	     */
	    get interval(): number;
	    set interval(val: number);
	    /**
	     * 判断当前时刻要发射几个粒子
	     * @param roundDuration 发射器当前轮次的时间
	     * @returns number 要发射点粒子数
	     */
	    trigger(roundDuration: number): number;
	    reset(): void;
	} namespace ParticleEmitterBurst {
	}
	export default ParticleEmitterBurst;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleEmitter' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleEmitterBurstClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/emitterBurst';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; class ParticleEmitter extends ParticleModule {
	    /**
	     * 发射器每秒排放的粒子数。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined)}
	     * @memberof ParticleEmitter
	     */
	    get rateOverTime(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined;
	    set rateOverTime(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.CurveProperty | AdvancedPropertyClass.TwoConstantsProperty | AdvancedPropertyClass.TwoCurvesProperty | undefined);
	    /**
	     * 延迟多少s发射第一个粒子 只影响第一个发出的粒子时间。
	     * @type {(ConstantProperty | TwoConstantsProperty | undefined)}
	     * @memberof ParticleEmitter
	     */
	    get startDelay(): AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.TwoConstantsProperty;
	    set startDelay(val: AdvancedPropertyClass.ConstantProperty | AdvancedPropertyClass.TwoConstantsProperty);
	    /**
	     * 粒子是否在onAwake时自动播放。
	     * @type {boolean}
	     * @memberof ParticleEmitter
	     */
	    get playOnAwake(): boolean;
	    set playOnAwake(val: boolean);
	    /**
	     * 一次喷射周期的时常（单位秒）。
	     * @type {number}
	     * @memberof ParticleEmitter
	     */
	    get duration(): number;
	    set duration(val: number);
	    /**
	     * 粒子是否循环播放。
	     * @type {boolean}
	     * @memberof ParticleEmitter
	     */
	    get looping(): boolean;
	    set looping(val: boolean);
	    /**
	     * 设置最大的粒子数量。
	     * @type {number}
	     * @memberof ParticleEmitter
	     */
	    get maxParticles(): number;
	    set maxParticles(val: number);
	    /**
	     * 播放粒子。
	     * @type {boolean}
	     * @memberof ParticleEmitter
	     */
	    get start(): boolean;
	    set start(val: boolean);
	    set startTotalTime(val: number);
	    /**
	     * 爆炸发射器。
	     * 用于某些时刻，同时发射粒子。
	     */
	    get bursts(): ParticleEmitterBurstClass[];
	    set bursts(val: ParticleEmitterBurstClass[]);
	    constructor(particle: Particle);
	} namespace ParticleEmitter {
	    export import ParticleEmitterBurst = ParticleEmitterBurstClass;
	}
	export default ParticleEmitter;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleSizeByLife' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; type ConstantProperty = AdvancedPropertyClass.ConstantProperty; type CurveProperty = AdvancedPropertyClass.CurveProperty; type TwoConstantsProperty = AdvancedPropertyClass.TwoConstantsProperty; type TwoCurvesProperty = AdvancedPropertyClass.TwoCurvesProperty; type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
	export enum SizeProperties {
	    separateAxes = "separateAxes",
	    x = "x",
	    y = "y",
	    z = "z"
	} class ParticleSizeByLife extends ParticleModule {
	    /**
	     * 是否分开计算三个轴向上粒子的大小。
	     * @type {boolean}
	     * @memberof ParticleSizeByLife
	     */
	    get separateAxes(): boolean;
	    set separateAxes(val: boolean);
	    /**
	     * separateAxes开启时，表示x轴上粒子大小的变化情况。
	     * separateAxes未开启时，表示xyz轴上粒子大小的变化情况。
	     * @type {AdvancedProperty}
	     * @memberof ParticleSizeByLife
	     */
	    get x(): AdvancedProperty;
	    set x(val: AdvancedProperty);
	    /**
	     * separateAxes开启时，表示y轴上粒子大小的变化情况。
	     * @type {AdvancedProperty}
	     * @memberof ParticleSizeByLife
	     */
	    get y(): AdvancedProperty | undefined;
	    set y(val: AdvancedProperty | undefined);
	    /**
	     * separateAxes开启时，表示z轴上粒子大小的变化情况。
	     * @memberof ParticleSizeByLife
	     */
	    get z(): AdvancedProperty | undefined;
	    set z(val: AdvancedProperty | undefined);
	    constructor(particle: Particle);
	} namespace ParticleSizeByLife {
	}
	export default ParticleSizeByLife;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleSpeedByLife' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; type ConstantProperty = AdvancedPropertyClass.ConstantProperty; type CurveProperty = AdvancedPropertyClass.CurveProperty; type TwoConstantsProperty = AdvancedPropertyClass.TwoConstantsProperty; type TwoCurvesProperty = AdvancedPropertyClass.TwoCurvesProperty; type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
	export enum SpeedProperties {
	    x = "x",
	    y = "y",
	    z = "z"
	} class ParticleSpeedByLife extends ParticleModule {
	    /**
	     * x轴上粒子速度的值。
	     * @type {AdvancedProperty}
	     * @memberof ParticleSpeedByLife
	     */
	    get x(): AdvancedProperty;
	    set x(val: AdvancedProperty);
	    /**
	     * y轴上粒子速度的值。
	     * @type {AdvancedProperty}
	     * @memberof ParticleSpeedByLife
	     */
	    get y(): AdvancedProperty;
	    set y(val: AdvancedProperty);
	    /**
	     * z轴上粒子速度的值。
	     * @type {AdvancedProperty}
	     * @memberof ParticleSpeedByLife
	     */
	    get z(): AdvancedProperty;
	    set z(val: AdvancedProperty);
	    constructor(particle: Particle);
	} namespace ParticleSpeedByLife {
	}
	export default ParticleSpeedByLife;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleSpeedLimitByLife' {
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; type ConstantProperty = AdvancedPropertyClass.ConstantProperty; type CurveProperty = AdvancedPropertyClass.CurveProperty; type TwoConstantsProperty = AdvancedPropertyClass.TwoConstantsProperty; type TwoCurvesProperty = AdvancedPropertyClass.TwoCurvesProperty; type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
	export enum SpeedLimitProperties {
	    separateAxes = "separateAxes",
	    dampen = "dampen",
	    x = "x",
	    y = "y",
	    z = "z"
	} class ParticleSpeedLimitByLife extends ParticleModule {
	    /**
	     * 每个轴上的速度下限是否分开。
	     * @type {boolean}
	     * @memberof ParticleSpeedLimitByLife
	     */
	    get separateAxes(): boolean;
	    set separateAxes(val: boolean);
	    /**
	     * x轴上的速度下限。
	     * @type {(AdvancedProperty | undefined)}
	     * @memberof ParticleSpeedLimitByLife
	     */
	    get x(): AdvancedProperty | undefined;
	    set x(val: AdvancedProperty | undefined);
	    /**
	     * y轴上的速度下限。
	     * @type {(AdvancedProperty | undefined)}
	     * @memberof ParticleSpeedLimitByLife
	     */
	    get y(): AdvancedProperty | undefined;
	    set y(val: AdvancedProperty | undefined);
	    /**
	     * z轴上的速度下限。
	     * @type {(AdvancedProperty | undefined)}
	     * @memberof ParticleSpeedLimitByLife
	     */
	    get z(): AdvancedProperty;
	    set z(val: AdvancedProperty);
	    /**
	     * 阻尼值[0 - 1]，值越大，速度下降的越快。
	     * @type {number}
	     * @memberof ParticleSpeedLimitByLife
	     */
	    get dampen(): number;
	    set dampen(val: number);
	    constructor(particle: Particle);
	} namespace ParticleSpeedLimitByLife {
	}
	export default ParticleSpeedLimitByLife;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleTextureSheetAnimation' {
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule'; type Particle = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle').default; type ConstantProperty = AdvancedPropertyClass.ConstantProperty; type CurveProperty = AdvancedPropertyClass.CurveProperty; type TwoConstantsProperty = AdvancedPropertyClass.TwoConstantsProperty; type TwoCurvesProperty = AdvancedPropertyClass.TwoCurvesProperty; enum EAnimationType {
	    WholeSheet = 1,
	    SingleRow = 2
	} class ParticleTextureSheetAnimation extends ParticleModule {
	    /**
	     * 贴图的行列个数，x表示列数，y表示行数。
	     * @type {Vector2}
	     * @memberof ParticleTextureSheetAnimation
	     */
	    get tiles(): Vector2;
	    set tiles(val: Vector2);
	    /**
	     * 动画类型。
	     * @type {AnimationType}
	     * @memberof ParticleTextureSheetAnimation
	     */
	    get animationType(): ParticleTextureSheetAnimation.AnimationType;
	    set animationType(val: ParticleTextureSheetAnimation.AnimationType);
	    /**
	     * 贴图动画序列数的变化曲线。
	     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
	     * @memberof ParticleTextureSheetAnimation
	     */
	    get frameOverTime(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
	    set frameOverTime(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty);
	    /**
	     * 初始序列帧数。
	     * @type {(ConstantProperty | TwoConstantsProperty)}
	     * @memberof ParticleTextureSheetAnimation
	     */
	    get startFrame(): ConstantProperty | TwoConstantsProperty;
	    set startFrame(val: ConstantProperty | TwoConstantsProperty);
	    /**
	     * 在粒子生命周期中的循环次数。
	     * @type {number}
	     * @memberof ParticleTextureSheetAnimation
	     */
	    get cycles(): number;
	    set cycles(val: number);
	    /**
	     * 当animationType是AnimationType.SingleRow时，是否使用随机行数。
	     */
	    get randomRow(): boolean;
	    set randomRow(val: boolean);
	    /**
	     * 当animationType是AnimationType.SingleRow时，指定初始的行数。
	     */
	    get row(): number;
	    set row(val: number);
	    constructor(particle: Particle);
	} namespace ParticleTextureSheetAnimation {
	    /** 动画类型 */
	    export import AnimationType = EAnimationType;
	    /** @internal */
	}
	export default ParticleTextureSheetAnimation;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleVertexLayout' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext'; const particleVertexLayout: Kanata.VertexLayout;
	export default particleVertexLayout;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/executeMode' {
	/**
	 * create by janzen
	 * 只在editor运行的component,可以用来做辅助开发使用。
	 */
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	export enum EditorExecuteMode {
	    Game = "GAME",
	    Editor = "EDITOR",
	    All = "ALL"
	}
	export function getEnv(): EditorExecuteMode;
	export function executeInEditMode(): ClassDecorator;
	export function executeInGameMode(): ClassDecorator;
	export function executeInAllMode(): ClassDecorator;
	export function hideInHierarchy(): ClassDecorator;
	export function mainScreenCameraInEditorMode(): ClassDecorator;
	export function setMainScreenCameraInEditorMode(cameraComp: BaseCamera, value?: boolean): void;
	export function getMainScreenCameraInEditorMode(cameraComp: BaseCamera): any;
	export function findEntityExecuteMode(entity: Entity): EditorExecuteMode;
	export function findExecuteMode(comp: Component): EditorExecuteMode;
	export function entityShowInHierarchy(entity: Entity): boolean;
	/**
	 * 根据comp的属性来判断是否应该在当前环境运行
	 */
	export function shouldComponentModeActivate(comp: Component): boolean;
	export function stopInPauseMode(): (classCtor: Function) => void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle' {
	import { EnumRendererType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/materials/buildinShaderDesc';
	import { Entity2D, Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import AdvancedPropertyClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import ParticleColorByLifeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleColorByLife';
	import ParticleCommonClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleCommon';
	import ParticleEmitterClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleEmitter';
	import ParticleEmitterShapeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleEmitterShape';
	import ParticleRendererClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleRenderer';
	import ParticleRotationByLifeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleRotationByLife';
	import ParticleSizeByLifeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleSizeByLife';
	import ParticleSpeedByLifeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleSpeedByLife';
	import ParticleSpeedLimitByLifeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleSpeedLimitByLife';
	import ParticleTextureSheetAnimationClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/modules/particleTextureSheetAnimation';
	import ParticleModule from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particleModule';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext'; class Particle extends MeshRenderer {
	    readonly entity: Entity3D | Entity2D;
	    constructor(entity: Entity3D | Entity2D);
	    /**
	     * 是否启用烘培模式。
	     */
	    get useBakedMode(): boolean;
	    set useBakedMode(val: boolean);
	    /**
	     * 粒子是否正在播放中。
	     */
	    get isPlaying(): boolean;
	    /**
	     * 播放粒子组件。
	     * @param {boolean} [withChildren=true] 是否播放子节点中的所有粒子组件。
	     * @memberof Particle
	     */
	    play(withChildren?: boolean): void;
	    /**
	     * 停止播放粒子组件。
	     * @param {boolean} [withChildren=true] 是否停止播放子节点中的所有粒子组件。
	     * @memberof Particle
	     */
	    stop(withChildren?: boolean): void;
	    modules: Map<typeof ParticleModule, ParticleModule>;
	    /**
	     * 粒子组件的通用模块。
	     * 用于控制粒子的初始速度、初始颜色、初始旋转、初始大小等属性。
	    */
	    common: ParticleCommonClass;
	    /**
	     * 粒子组件的发射器模块。
	     * 用于设定粒子发射相关的属性，如发射间隔时间、粒子系统持续时间、发射是否循环等。
	     */
	    emitter: ParticleEmitterClass;
	    /**
	     * 粒子组件的渲染模块。
	     * 用于设定粒子渲染相关的参数。
	     */
	    renderer: ParticleRendererClass;
	    /**
	     * 粒子组件的发射器形状模块。
	     * 用于设定粒子发射器的类型，可以决定粒子的初始方向、初始位置。
	     */
	    emitterShape?: ParticleEmitterShapeClass;
	    /**
	     * 粒子组件的旋转模块。
	     * 用于控制粒子生命周期中旋转的变化。
	     */
	    rotationByLife?: ParticleRotationByLifeClass;
	    /**
	     * 粒子组件的大小模块。
	     * 用于控制粒子生命周期中大小的变化。
	     */
	    sizeByLife?: ParticleSizeByLifeClass;
	    /**
	     * 粒子组件的速度模块。
	     * 用于控制粒子生命周期中速度的变化。
	     */
	    speedByLife?: ParticleSpeedByLifeClass;
	    /**
	     * 粒子组件的速度限制变化模块。
	     * 用于控制粒子生命周期中速度的限制。
	     */
	    speedLimitByLife?: ParticleSpeedLimitByLifeClass;
	    /**
	     * 粒子组件的颜色模块。
	     * 用于控制粒子生命周期中颜色的变化。
	     */
	    colorByLife?: ParticleColorByLifeClass;
	    /**
	     * 粒子组件的贴图动画模块类。
	     * 用于控制粒子生命周期中的贴图动画。
	     */
	    textureSheetAnimation?: ParticleTextureSheetAnimationClass;
	} namespace Particle {
	    /**
	     * 粒子组件中用到的复杂类型的类。
	     * 如ConstantProperty / TwoConstants / CurveProperty / TwoCurvesProperty / OneColorProperty / TwoColorsProperty / GradientProperty / TwoGradientsProperty。
	     */
	    export import AdvancedProperty = AdvancedPropertyClass;
	    /**
	     * 粒子组件的通用模块类。
	     * 用于控制粒子的初始速度、初始颜色、初始旋转、初始大小等属性。
	     */
	    export import ParticleCommon = ParticleCommonClass;
	    /**
	     * 粒子组件的发射器模块类。
	     * 用于设定粒子发射相关的属性，如发射间隔时间、粒子系统持续时间、发射是否循环等。
	     */
	    export import ParticleEmitter = ParticleEmitterClass;
	    /**
	     * 粒子组件的发射器形状模块类。
	     * 用于设定粒子发射器的类型，可以决定粒子的初始方向、初始位置。
	     */
	    export import ParticleEmitterShape = ParticleEmitterShapeClass;
	    /**
	     * 粒子组件的渲染模块类。
	     * 用于设定粒子渲染相关的参数。
	     */
	    export import ParticleRenderer = ParticleRendererClass;
	    /**
	     * 粒子组件的颜色模块类。
	     * 用于控制粒子生命周期中颜色的变化。
	     */
	    export import ParticleColorByLife = ParticleColorByLifeClass;
	    /**
	     * 粒子组件的旋转模块类。
	     * 用于控制粒子生命周期中旋转的变化。
	     */
	    export import ParticleRotationByLife = ParticleRotationByLifeClass;
	    /**
	     * 粒子组件的大小模块类。
	     * 用于控制粒子生命周期中大小的变化。
	     */
	    export import ParticleSizeByLife = ParticleSizeByLifeClass;
	    /**
	     * 粒子组件的速度模块类。
	     * 用于控制粒子生命周期中速度的变化。
	     */
	    export import ParticleSpeedByLife = ParticleSpeedByLifeClass;
	    /**
	     * 粒子组件的速度限制变化模块类。
	     * 用于控制粒子生命周期中速度的限制。
	     */
	    export import ParticleSpeedLimitByLife = ParticleSpeedLimitByLifeClass;
	    /**
	     * 粒子组件的贴图动画模块类。
	     * 用于控制粒子生命周期中的贴图动画。
	     */
	    export import ParticleTextureSheetAnimation = ParticleTextureSheetAnimationClass;
	}
	export default Particle;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types' {
	/**
	 * 力（或力矩）的类型，物理组件中某些接口会用到。
	 * @category Physics
	 * @see {@link Rigidbody.addForce} {@link Rigidbody.addTorque}
	 */
	export enum ForceMode {
	    /**
	     * 持续性的力。
	     */
	    Force = 0,
	    /**
	     * 只持续一帧的力。
	     */
	    Impulse = 1,
	    /**
	     * 只持续一帧的力，无视物体的{@link Rigidbody.mass | 质量}（mass=1）。
	     *
	     * \**其实就是在下一帧修改物体速度。*
	     */
	    VelocityChange = 2,
	    /**
	     * 持续性的力，无视物体的{@link Rigidbody.mass | 质量}（mass=1）。
	     *
	     * \**其实就是每帧修改物体速度。*
	     */
	    Acceleration = 4
	}
	/**
	 * 发生碰撞时摩擦系数和弹性系数的结合方式。
	 * @category Physics
	 * @see {@link PhysicMaterial.frictionCombine} {@link PhysicMaterial.bounceCombine}
	 */
	export enum CombineMode {
	    Average = 0,
	    Mininum = 1,
	    Multiply = 2,
	    Maximum = 3
	}
	/**
	 * 对刚体（在某个轴上的）位移和旋转的限制。
	 *
	 * @category Physics
	 * @see {@link Rigidbody.rotationConstraints} {@link Rigidbody.positionConstraints}
	 */
	export enum RigidbodyConstraints {
	    None = 0,
	    FreezePositionX = 1,
	    FreezePositionY = 2,
	    FreezePositionZ = 4,
	    FreezeRotationX = 8,
	    FreezeRotationY = 16,
	    FreezeRotationZ = 32,
	    FreezePosition = 7,
	    FreezeRotation = 56,
	    FreezeAll = 63
	}
	/**
	 * 胶囊碰撞体的朝向。
	 *
	 * @category Physics
	 */
	export enum CapsuleColliderDirection {
	    "X-Axis" = 0,
	    "Y-Axis" = 1,
	    "Z-Axis" = 2
	}
	/**
	 * @category Physics
	 */
	export enum PhysMeshCookingFlag {
	    None = 0,
	    InflateConvexMesh = 1,
	    CookForFasterSimulation = 2,
	    EnableMeshCleaning = 4,
	    WeldColocatedVertices = 8
	}
	/**
	 * @category Physics
	 */
	export enum CollisionDetectionMode {
	    Discrete = 0,
	    Continuous = 1,
	    ContinuousDynamic = 2,
	    ContinuousSpeculative = 3
	}
	/**
	 * @category Physics
	 */
	export enum QueryTriggerInteraction {
	    UseGlobal = 0,
	    Ignore = 1,
	    Collide = 2
	}
	/**
	 * @category Physics
	 */
	export enum CollisionFlags {
	    None = 0,
	    Sides = 1,
	    Above = 2,
	    Below = 4
	}
	/**
	 * @category Physics
	 */
	export enum ColliderType {
	    None = 0,
	    Box = 1,
	    CharacterController = 2,
	    Capsule = 3,
	    Mesh = 4,
	    Sphere = 5
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/utils' {
	/**
	 * get/set某属性时, 如果已经有nativeComp, 就从nativeComp中取(通过toPhysics来转化成引擎可用的类型);
	 * 如果没有nativeComp(未初始化或无物理引擎), 就从对象内的缓存__propertyKey中来取.
	 * __propertyKey的初始值通过另一个decorater(@defaultValue)来设置, 如果未设置会get出undefined.
	 * **重要:** vector类型的属性, 一定要先设置@defaultValue, 否则直接get会出错.
	 * 同时, 在创建nativeComp的时刻, 万一之前用户已经手动set过属性的值了(这种情况下会set到__propertyKey里先缓存着),
	 * 那么需要将__propertyKey里的值替换到真正的nativeComp中, 这个功能首先需要将@defaultValue(v, init)的第二项init设置成true,
	 * 然后再调用applyParams来替换.
	 * @author shanexyzhou
	 * @param nativeName 私有成员nativeComp的名字
	 * @returns decorator
	 */
	export function genProxy(nativeName: string): (type?: any) => (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
	export function validate(pred: (v: any) => boolean): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
	export function defaultValue(v: any, init?: boolean): (target: object, propertyKey: string) => void;
	export function applyParams(obj: object, native: object): void;
	/**
	   * 反序列化，调整字节顺序，并且转为一维数组
	   * @param {*} str 长度为8的字符串，每个字符为0-f
	   *  转化为32个bit(4个字节)，每个字节长度字符串要reverse一下，等到0-31的配置
	   * ffffffff -> [1,1,1,1,1,1,1,1...]
	   */
	export function deserializeBytes(str: string): number[];
	/**
	 * 将string转为二位数组（矩阵）
	 * 长度为256的字符串,每个字符为16进制表示，表示32*32矩阵的值
	 * @param {*} str 长度为256的字符串（每个字符为0-F)
	 */
	export function tranStringToMatrix(str?: string): number[][];
	export function getArrayBufferCollisionMatrix(str: string): Uint32Array;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/booleanVector3' {
	export default class BooleanVector3 {
	    constructor(b1?: any, b2?: any, b3?: any);
	    get x(): boolean;
	    set x(val: boolean);
	    get y(): boolean;
	    set y(val: boolean);
	    get z(): boolean;
	    set z(val: boolean);
	    /**
	     * 拷贝该向量
	     *
	     * @returns {Rect} 拷贝出来的对象
	     * @memberof Rect
	     */
	    clone(): BooleanVector3;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/physicsNotFound' {
	export default function engineNativeError(): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/rigidbody' {
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import { ForceMode, CollisionDetectionMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	import BooleanVector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/booleanVector3';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Quaternion from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion';
	/**
	 * 刚体组件。
	 *
	 * 让物体在物理系统中成为一个有质量的刚体。只有添加了这个组件之后，物体才有可能在物理系统的*物理模拟*阶段发生位移和旋转。
	 * @category Physics
	 */
	export default class Rigidbody extends Component {
	    readonly priority: number;
	    /**
	     * 物体的质量。
	     * @limit mass > 0
	     * @default 1
	     * @see {@link setDensity}
	     */
	    get mass(): number;
	    set mass(v: number);
	    /**
	     * 线性阻尼。
	     * 影响物体的{@link velocity | 线性速度}。
	     * @limit linearDamping >= 0
	     * @default 0
	     */
	    get linearDamping(): number;
	    set linearDamping(v: number);
	    /**
	     * 角速度阻尼。
	     * 影响物体的{@link angularVelocity | 角速度}。
	     * @limit angularDamping >= 0
	     * @default 0.05
	     */
	    get angularDamping(): number;
	    set angularDamping(v: number);
	    /**
	     * 该刚体是否受重力影响。
	     */
	    get useGravity(): boolean;
	    set useGravity(v: boolean);
	    /**
	     * 是否为*运动学(Kinematic)* 刚体。
	     * 设置为*运动学*刚体后，除非手动调用{@link movePosition}，否则物体不会在*物理模拟*阶段发生位移或旋转。可以理解为，刚体的行为完全在用户的控制之下。
	     * @default false
	     */
	    get isKinematic(): boolean;
	    set isKinematic(v: boolean);
	    /**
	     * @unimplemented
	     * @default true
	     */
	    get detectCollisions(): boolean;
	    set detectCollisions(v: boolean);
	    /**
	     * 设置刚体的碰撞检测模式。
	     * 详见{@link CollisionDetectionMode}。
	     * @default {@link CollisionDetectionMode.Discrete}
	     */
	    get collisionDetectionMode(): CollisionDetectionMode;
	    set collisionDetectionMode(v: CollisionDetectionMode);
	    private get constraints();
	    private set constraints(value);
	    /**
	     * 限制物体的旋转（X轴，Y轴，Z轴）。
	     * @default [false, false, false]
	     */
	    get rotationConstraints(): BooleanVector3;
	    set rotationConstraints(v: BooleanVector3);
	    /**
	     * 限制物体的位移（X轴，Y轴，Z轴）。
	     * @default [false, false, false]
	     */
	    get positionConstraints(): BooleanVector3;
	    set positionConstraints(v: BooleanVector3);
	    /**
	     * 直接获取或修改刚体在*物理系统*中的位置。
	     * 物理系统中的位置是独立于节点系统中的Transform的，详见{@link //TODO}。
	     *
	     * \**如果你不清楚修改这一项的后果，请不要手动修改它。修改{@link Transform3D.position}来代替。*
	     */
	    get position(): Vector3;
	    set position(v: Vector3);
	    /**
	     * 直接获取或修改刚体在*物理系统*中的旋转（以四元数表示）。
	     * 物理系统中的旋转是独立于节点系统中的Transform的，详见{@link //TODO}。
	     *
	     * \**如果你不清楚修改这一项的后果，请不要手动修改它。修改{@link Transform3D.euler}或{@link Transform3D.quaternion}来代替。*
	     */
	    get rotation(): Quaternion;
	    set rotation(v: Quaternion);
	    /**
	     * 刚体的角速度。
	     */
	    get angularVelocity(): Vector3;
	    set angularVelocity(v: Vector3);
	    /**
	     * 刚体的质心相对于LocalTransform的偏移量。
	     * 如果不手动设置这一项，会自动根据刚体附着的碰撞体来计算质心。
	     * @see {@link resetCenterOfMass}
	     */
	    get centerOfMass(): Vector3;
	    set centerOfMass(v: Vector3);
	    /**
	     * 是否允许*物理模拟*过程中对刚体进行旋转。
	     * @default true
	     */
	    get freezeRotation(): boolean;
	    set freezeRotation(v: boolean);
	    /**
	     * 刚体的转动惯量。
	     * 如果不手动设置的话，会自动根据刚体上附着的碰撞体计算得出。
	     * @see {@link resetInertiaTensor}
	     */
	    get inertiaTensor(): number;
	    set inertiaTensor(v: number);
	    /**
	     * 最大角速度（弧度）。
	     * @default 7
	     */
	    get maxAngularVelocity(): number;
	    set maxAngularVelocity(v: number);
	    /**
	     * 最大分离速度。
	     * *物理模拟*解决碰撞（相交）的过程中，最大能允许的分离速度。
	     * @default Infinity
	     */
	    get maxDepenetrationVelocity(): number;
	    set maxDepenetrationVelocity(v: number);
	    /**
	     * 设置刚体进入休眠的动能阈值，动能的计算过程中会剔除质量大小的影响。
	     * 关于休眠的定义，详见{@link //TODO}。
	     * @default 0.005
	     */
	    get sleepThreshold(): number;
	    set sleepThreshold(v: number);
	    /**
	     * 设置*物理模拟*过程中解决碰撞的迭代次数。
	     * 更高的迭代次数，会消耗更多性能，产生更自然的物理碰撞效果。
	     * 如果发现静息状态的刚体（比如说放在地面上），会发生抖动，可以考虑提高这项数值。
	     *
	     * @limit solverIterations > 0
	     * @default 6
	     */
	    get solverIterations(): number;
	    set solverIterations(v: number);
	    /**
	     * 设置*物理模拟*过程中计算碰撞后速度的迭代次数。
	     * 更高的迭代次数，会消耗更多性能，产生更准确的分离速度。
	     *
	     * @limit solverVelocityIterations > 0
	     * @default 1
	     */
	    get solverVelocityIterations(): number;
	    set solverVelocityIterations(v: number);
	    /**
	     * 刚体的线性速度。
	     *
	     * \**修改这一项会造成速度突变，一般情况下可以使用{@link addForce}来代替。*
	     */
	    get velocity(): Vector3;
	    set velocity(v: Vector3);
	    /**
	     * @returns 刚体质心在世界坐标中的位置。
	     */
	    getWorldCenterOfMass(): Vector3;
	    /**
	     * 为刚体施加力，会影响刚体的{@link velocity | 线性速度}。
	     * @param force 世界坐标下矢量形式的力，作用在物体质心上。
	     * @param mode 力的类型。
	     */
	    addForce(force: Vector3, mode: ForceMode): void;
	    /**
	     * 为刚体施加力矩，会影响刚体的{@link angularVelocity | 角速度}。
	     * @param torque 世界坐标下矢量形式的力矩。
	     * @param mode 力矩的类型。
	     */
	    addTorque(torque: Vector3, mode: ForceMode): void;
	    /**
	     * @returns 刚体是否处于休眠状态。
	     * @see {@link sleep}
	     */
	    isSleeping(): boolean;
	    /**
	     * 强迫刚体进入休眠状态（至少一帧），休眠状态详见{@link //todo}。
	     * \**如果下一帧发生碰撞则会立刻醒来。*
	     */
	    sleep(): void;
	    /**
	     * 强制唤醒刚体（离开休眠状态）。
	     * @see {@link sleep}
	     */
	    wakeUp(): void;
	    /**
	     * 生成一次模拟爆炸的力。
	     * 爆炸范围可以视作一个球状物体，如果球体和刚体产生*相交*，则会在刚体上产生推力。
	     * 推力的大小和*相交点*与球心的距离有关，推力的方向从球心指向相交点，推力作用位于*相交点*。
	     *
	     * 视刚体有无附着的碰撞体，分为两种情况：
	     * + 无碰撞体（或爆炸球心在刚体碰撞体内）
	     *   相交的判定使用刚体的质心；相交点也取刚体的质心。
	     * + 有碰撞体
	     *   相交的判定使用刚体的所有碰撞体；相交点取碰撞体距离球心最近的那一点。
	     * @param explosionForce 爆炸力的大小。
	     * @param explosionPosition 爆炸球体的球心位置。
	     * @param explosionRadius 爆炸球体的半径。
	     * @param upwardsModifier 使用相对数值来修改推力的*作用位置*的y坐标。
	     * @param mode 力的类型。
	     * @limit explosionForce > 0
	     */
	    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number, mode: ForceMode): void;
	    /**
	     * 为刚体施加力，会影响刚体的{@link velocity | 线性速度}和{@link angularVelocity | 角速度}。
	     * @param force 世界坐标下矢量形式的力，作用在position位置上。
	     * @param position 力的作用位置。
	     * @param mode 力的类型。
	     */
	    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
	    /**
	     * 为刚体施加力，会影响刚体的{@link velocity | 线性速度}。
	     * @param force **局部**坐标下矢量形式的力，作用在物体质心上。
	     * @param mode 力的类型。
	     */
	    addRelativeForce(force: Vector3, mode: ForceMode): void;
	    /**
	     * 为刚体施加力矩，会影响刚体的{@link angularVelocity | 角速度}。
	     * @param torque **局部**坐标下矢量形式的力矩。
	     * @param mode 力矩的类型。
	     */
	    addRelativeTorque(torque: Vector3, mode: ForceMode): void;
	    /**
	     * 测试刚体**表面上**距离某点最近的位置。
	     * 如果给予的position在刚体内部，会返回position。
	     * 如果刚体无附着的碰撞体，会返回[Infinity, Infinity, Infinity]。
	     */
	    closestPointOnBounds(position: Vector3): Vector3;
	    /**
	     * 获取刚体内某一点在世界坐标下的速度。
	     * @param worldPoint 世界坐标下的位置（其实在刚体外也可以）。
	     */
	    getPointVelocity(worldPoint: Vector3): Vector3;
	    /**
	     * 获取刚体内某一点在**局部**坐标下的速度。
	     * @param relativePoint **局部**坐标下的位置（其实在刚体外也可以）。
	     */
	    getRelativePointVelocity(relativePoint: Vector3): Vector3;
	    /**
	     * 对于***非**运动学刚体*来说，等于直接修改{@link position}；
	     * 对于*运动学刚体*来说，位置变化会在下一帧生效。可以视作物体在这一帧的*物理模拟*中沿直线路径**移动**到了目的地。
	     * @param position 位移的终点
	     * @see {@link isKinematic}
	     */
	    movePosition(position: Vector3): void;
	    /**
	     * @unimplemented 暂未支持，请使用{@link rotation}属性或{@link Transform3D.quaternion}代替。
	     */
	    moveRotation(rotation: Quaternion): void;
	    /**
	     * 手动触发，根据刚体附着的碰撞体重新计算刚体的质心。
	     * @see {@link centerOfMass}
	     */
	    resetCenterOfMass(): void;
	    /**
	     * 手动触发，根据刚体附着的碰撞体重新计算刚体的转动惯量。
	     * @see {@link inertiaTensor}
	     */
	    resetInertiaTensor(): void;
	    /**
	     * 根据给定的密度和刚体附着的碰撞体，来计算刚体的质量。
	     * @see {@link mass}
	     */
	    setDensity(density: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/physicMaterial' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { CombineMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	/**
	 * 物理材质，应用在{@link Collider.material}上。
	 * @category Physics
	 * @category Asset
	 */
	export default class PhysicMaterial extends BaseResource {
	    /**
	     * 动摩擦系数。
	     * @limit 0 <= dynamicFriction <= 1
	     * @default 0.6
	     */
	    get dynamicFriction(): number;
	    set dynamicFriction(value);
	    /**
	     * 静摩擦系数
	     * @limit 0 <= staticFriction <= 1
	     * @default 0.6
	     */
	    get staticFriction(): number;
	    set staticFriction(value);
	    /**
	     * 弹性系数，决定碰撞时的能量损失比例。
	     *
	     * 弹性系数 = 1时，碰撞无能量损失。
	     * @limit 0 <= bounciness <= 1
	     * @default 0
	     */
	    get bounciness(): number;
	    set bounciness(value);
	    /**
	     * 如何结合发生碰撞的两个物体的摩擦系数。
	     * @default {@link CombineMode.Average}
	     */
	    get frictionCombine(): CombineMode;
	    set frictionCombine(v: CombineMode);
	    /**
	     * 如何结合发生碰撞的两个物体的弹性系数。
	     * @default {@link CombineMode.Average}
	     */
	    get bounceCombine(): CombineMode;
	    set bounceCombine(v: CombineMode);
	    /**
	     * @param nativeMaterial 脚本创建资源时，请**不要**提供这一项。
	     */
	    constructor(nativeMaterial?: phys3D.Material);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/bounds' {
	import Vector3, { Vector3_READONLY } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3'; const boundsMap: WeakMap<phys3D.Bounds, ReadonlyBounds>;
	export { boundsMap }; class BaseBounds {
	    protected constructor();
	    /**
	     * 给定一个点point，求包围盒上与该点最近的点。
	     */
	    closestPoint(point: Vector3): Vector3;
	    /**
	     * 判断点point是否在包围盒内。
	     */
	    contains(point: Vector3): boolean;
	    /**
	     * 判断是否与另一个包围盒相交。
	     */
	    intersects(bounds: BaseBounds): boolean;
	    /**
	     * 求包围盒与某点point的最近距离的平方。
	     */
	    sqrDistance(point: Vector3): number;
	}
	/**
	 * 代表一个平行于轴的长方体包围盒（Axis-aligned bounding box, AABB）。
	 *
	 * 只会在物理系统中生成，无法修改大小、位置。
	 * 想要手动新建Bounds，请使用{@link Bounds}。
	 *
	 * \**文档内请勾选右上角Inherited来查看所有属性。*
	 *
	 * @category Physics
	 */
	export class ReadonlyBounds extends BaseBounds {
	    get center(): Vector3_READONLY;
	    get extents(): Vector3_READONLY;
	    get min(): Vector3_READONLY;
	    get max(): Vector3_READONLY;
	    get size(): Vector3_READONLY;
	}
	/**
	 * 代表一个平行于轴的长方体包围盒（Axis-aligned bounding box, AABB）。
	 *
	 * 一般在物理系统中生成，某些类的方法会返回{@link ReadonlyBounds}。
	 * 也可以自己新建Bounds实例，使用内部的某些方法来简便计算。
	 *
	 * \**文档内请勾选右上角Inherited来查看所有属性。*
	 */
	export class Bounds extends BaseBounds {
	    /**
	     *
	     */
	    constructor(center?: Vector3, size?: Vector3);
	    /**
	     * 包围盒的中心点于LocalTransform的偏移。
	     * @default (0, 0, 0)
	     */
	    get center(): Vector3;
	    set center(v: Vector3);
	    /**
	     * extents永远是{@link size}的一半。
	     * @default (0.5, 0.5, 0.5)
	     */
	    get extents(): Vector3;
	    set extents(v: Vector3);
	    /**
	     * 包围盒坐标最小的顶点。
	     * @default (-0.5, -0.5, -0.5)
	     */
	    get min(): Vector3;
	    set min(v: Vector3);
	    /**
	     * 包围盒坐标最大的顶点。
	     * @default (0.5, 0.5, 0.5)
	     */
	    get max(): Vector3;
	    set max(v: Vector3);
	    /**
	     * 包围盒的大小。
	     * @default (1, 1, 1)
	     */
	    get size(): Vector3;
	    set size(v: Vector3);
	    /**
	     * 将包围盒的长宽高（size）都扩展amount的长度。
	     */
	    expand(amount: number): void;
	    /**
	     * 设置包围盒的{@link min}和{@link max}。
	     */
	    setMinMax(min: Vector3, max: Vector3): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/charactercontroller' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import { CollisionFlags } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	import PhysicMaterial from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/physicMaterial';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/physicevent';
	import { IControllerColliderHit } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/controllerColliderHit';
	/**
	 * 物理角色控制器。
	 *
	 * 在物理世界中代表一个具有胶囊碰撞体的刚体，无需和{@link Rigidbody}一起使用。
	 * 这个刚体不会发生旋转，胶囊体永远是竖直的朝向。
	 *
	 * 类似于勾选了{@link Rigidbody.isKinematic | isKinematic}的Rigidbody，这个刚体不会受到*物理模拟*的影响，用户对这个刚体的位移具有完全的控制力。
	 * 但是与*运动学刚体*不同的是，物理角色控制器可以在{@link move | 移动(move)}的过程中被其他碰撞体阻挡，就好像一个角色在充满障碍物的地图上走路一样。
	 * 除此之外，物理角色控制器还能模拟上斜坡和上台阶的行为。
	 *
	 * @category Physics
	 * @see //TODO
	 */
	export default class CharacterController extends Collider {
	    /**
	     * @unused 物理角色控制器无法设置isTrigger属性。
	     * @default false
	     */
	    get isTrigger(): boolean;
	    set isTrigger(v: boolean);
	    /**
	     * @unused 物理角色控制器无法使用物理材质。
	     */
	    get material(): PhysicMaterial | undefined;
	    set material(m: PhysicMaterial | undefined);
	    set scale(v: Vector3);
	    /**
	     * 碰撞体相对于LocalTransform中心点的偏移。
	     * @default (0, 0, 0)
	     */
	    get center(): Vector3;
	    set center(v: Vector3);
	    /**
	     * 获取在上一次{@link move | move()}中发生碰撞的部位。
	     */
	    get collisionFlags(): CollisionFlags;
	    /**
	     * @unimplemented
	     */
	    get detectCollisions(): boolean;
	    set detectCollisions(v: boolean);
	    /**
	     * @ignore
	     * @unused
	     */
	    get enableOverlapRecovery(): boolean;
	    set enableOverlapRecovery(v: boolean);
	    /**
	     * 胶囊碰撞体的长度（包括两侧半球的半径）。
	     * @default 2
	     */
	    get height(): number;
	    set height(v: number);
	    /**
	     * 在上一次{@link move | move()}后，碰撞体是否站在地板上。
	     */
	    get isGrounded(): boolean;
	    /**
	     * {@link move | move()}过程中最小移动距离。
	     * @default 0.01
	     */
	    get minMoveDistance(): number;
	    set minMoveDistance(v: number);
	    /**
	     * 碰撞体胶囊两侧半球的半径。
	     * @default 0.5
	     */
	    get radius(): number;
	    set radius(v: number);
	    /**
	     * 设置碰撞距离，效果同{@link Collider.contactOffset}。
	     * @limit skinWidth >= 0
	     * @default 0.1
	     */
	    get skinWidth(): number;
	    set skinWidth(v: number);
	    /**
	     * 物理角色控制器能行走的最大坡度，单位为角度。
	     * @default 45
	     */
	    get slopeLimit(): number;
	    set slopeLimit(v: number);
	    /**
	     * 物理角色控制器上台阶时能跨上的最大高度。
	     * @limit stepOffset >= 0
	     * @default 0.5
	     */
	    get stepOffset(): number;
	    set stepOffset(v: number);
	    /**
	     * 物理角色控制器行走的速度。
	     * 由上一帧{@link move | move()}移动的距离除以上一帧的时长计算得到。
	     */
	    get velocity(): Vector3;
	    /**
	     * 直接将物理角色控制器传送到某地，不会被障碍物阻挡。
	     * 类似于直接修改{@link Rigidbody.position}。
	     */
	    reposition(position: Vector3): void;
	    /**
	     * 沿直线立刻移动物理角色控制器到某地，如果终点位置会和其他碰撞体相交，则会被阻挡。
	     *
	     * \**这个操作无需等待下一次物理模拟，会立刻生效。*
	     */
	    move(movement: Vector3): void;
	    /**
	     * 利用给定的speed来进行移动，效果类似于{@link move}。
	     *
	     * 移动的方向从speed中取，**无视**其中的y分量。
	     * 移动的过程中会受**重力**影响。
	     */
	    simpleMove(speed: Vector3): void;
	    /**
	     * 获取一个可以为onControllerColliderHit事件添加回调的Delegate。
	     * 在物理角色控制器调用{@link move}进行移动的过程中，如果被其他碰撞体所阻挡，就会生成一次onControllerColliderHit事件。
	     *
	     * ```typescript
	     * cct.onControllerColliderHit.add(hit => {...});
	     * ```
	     *
	     * 另一种添加onControllerColliderHit事件回调的方法，可以参考{@link Script.onControllerColliderHit}。
	     */
	    get onControllerColliderHit(): Delegate<IControllerColliderHit>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/controllerColliderHit' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import { Vector3_READONLY } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import CharacterController from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/charactercontroller'; const controllerColliderHitsMap: WeakMap<phys3D.ControllerColliderHit, ControllerColliderHit>;
	export { controllerColliderHitsMap };
	/**
	 * {@link CharacterController.onControllerColliderHit}事件返回的碰撞信息。
	 * @category Physics
	 */
	export interface IControllerColliderHit {
	    /**
	     * 阻挡物理角色控制器移动的碰撞体。
	     */
	    readonly collider: Collider;
	    /**
	     * 接收事件的物理角色控制器。
	     */
	    readonly controller: CharacterController;
	    /**
	     * 触发事件的{@link CharacterController.move | move()}的实际移动方向。
	     *
	     * 和move()传递的方向不一定一致，因为物理角色控制器还可以爬坡和爬台阶。
	     */
	    readonly moveDirection: Vector3_READONLY;
	    /**
	     * 碰撞平面的法线。
	     */
	    readonly normal: Vector3_READONLY;
	    /**
	     * 碰撞点。
	     */
	    readonly point: Vector3_READONLY;
	    /**
	     * 触发事件的{@link CharacterController.move | move()}的实际移动距离。
	     */
	    readonly moveLength: number;
	}
	export default class ControllerColliderHit implements IControllerColliderHit {
	    constructor(native: phys3D.ControllerColliderHit);
	    get collider(): Collider;
	    get controller(): CharacterController;
	    get moveDirection(): Vector3_READONLY;
	    get normal(): Vector3_READONLY;
	    get point(): Vector3_READONLY;
	    get moveLength(): number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/physicevent' {
	/**
	 * 物理{@link PhysicsDelegate | Delegate}注册的事件回调类型。
	 * @category Physics
	 * @template E 事件回调接收的参数类型。
	 */
	export type DelegateHandler<E> = (e: E) => void;
	/**
	 * 挂在entity上的delegate, 不持有native comp,
	 * 而是持有多个subDelegate, 通过这些subDelegate来invoke.
	 * 主要作用是让script里可以直接写个onCollisionEnter()的函数来接收该节点下所有物理组件的事件.
	 */
	export class SharedDelegate<E extends object> {
	    add(handler: DelegateHandler<E>, context?: any): void;
	    remove(handler: DelegateHandler<E>): void;
	    invoke(e: E): void;
	    dispose(): void;
	}
	/**
	 * 用来注册回调并接收某个**特定**物理事件的Delegate。
	 * @category Physics
	 * @template E 事件回调接收的参数类型。
	 * @see {@link Collider} {@link CharacterController}
	 */
	export class Delegate<E extends object> {
	    /**
	     * 注册事件回调。
	     */
	    add(handler: DelegateHandler<E>, context?: any): void;
	    /**
	     * 移除已注册的事件回调。
	     */
	    remove(handler: DelegateHandler<E>): void;
	    /**
	     * 移除所有事件回调。
	     */
	    clear(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider' {
	import Rigidbody from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/rigidbody';
	import { ICollision, ITriggerCollision } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collision';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import PhysicMaterial from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/physicMaterial';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { ReadonlyBounds } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/bounds';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { ColliderType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/physicevent'; const colliderMap: Map<phys3D.Collider, Collider>; const colliderEventNames: string[];
	export { colliderMap, colliderEventNames };
	export interface IEditorInfo {
	    lockCollider: boolean;
	}
	/**
	 * 碰撞体的基类。
	 * @category Physics
	 * @abstract
	 * @see [用户手册]()//TODO
	 */
	export default class Collider extends Component {
	    /**
	     * 物理组件在节点上的执行顺序，排在渲染节点之后、用户脚本之前。
	     */
	    readonly priority: number;
	    get type(): ColliderType;
	    set type(v: ColliderType);
	    /**
	     * 碰撞体是否是Trigger，开启后不参与碰撞，但是能触发Trigger系列的事件：
	     * {@link onTriggerEnter}, {@link onTriggerStay}, {@link onTriggerExit}。
	     * @default false
	     */
	    get isTrigger(): boolean;
	    set isTrigger(v: boolean);
	    set scale(v: Vector3);
	    /**
	     * 设置碰撞体的物理材质。
	     * 设置后碰撞体持有的材质是原材质的*深拷贝*。
	     */
	    get material(): PhysicMaterial | undefined;
	    set material(m: PhysicMaterial | undefined);
	    /**
	     * 获取碰撞体附着的刚体组件。
	     */
	    get attachedRigidbody(): Nullable<Rigidbody>;
	    /**
	     * 获取碰撞体的包围盒。
	     * 组件未经历onAwake生命周期前，会获取到undefined。
	     */
	    get bounds(): ReadonlyBounds | undefined;
	    /**
	     * 设置碰撞体的contactOffset，必须为正数。
	     * *一对*碰撞体，如果他们之间的最近距离小于他们的contactOffset之和，那么物理系统在一次*物理模拟*后就会产生一次碰撞。
	     */
	    get contactOffset(): number;
	    set contactOffset(v: number);
	    /**
	     * 获取一个可以为onCollisionEnter事件添加回调的Delegate。
	     * 在两个非Trigger碰撞体发生碰撞的第一帧，会生成一次onCollisionEnter事件。
	     *
	     * ```typescript
	     * collider.onCollisionEnter.add(collision => {...});
	     * ```
	     *
	     * 另一种添加onCollisionEnter（或其他物理）事件回调的方法，可以参考{@link Script.onCollisionEnter}。
	     */
	    get onCollisionEnter(): Delegate<ICollision>;
	    /**
	     * 获取一个可以为onCollisionExit事件添加回调的Delegate。
	     * 两个非Trigger碰撞体发生碰撞后，首次分开的那一帧，会生成一次onCollisionExit事件。
	     */
	    get onCollisionExit(): Delegate<ICollision>;
	    /**
	     * 获取一个可以为onCollisionStay事件添加回调的Delegate。
	     * 从两个非Trigger碰撞体发生碰撞后的第二帧开始，直到两个物体分开为止，会持续生成onCollisionStay事件。
	     */
	    get onCollisionStay(): Delegate<ICollision>;
	    /**
	     * 获取一个可以为onTriggerEnter事件添加回调的Delegate。
	     * 在两个Trigger（或一个Trigger，一个非Trigger）碰撞体发生相交的第一帧，会生成一次onTriggerEnter事件。
	     */
	    get onTriggerEnter(): Delegate<ITriggerCollision>;
	    /**
	     * 获取一个可以为onTriggerExit事件添加回调的Delegate。
	     * 两个Trigger（或一个Trigger，一个非Trigger）碰撞体发生相交后，首次分开的第一帧，会生成一次onTriggerExit事件。
	     */
	    get onTriggerExit(): Delegate<ITriggerCollision>;
	    /**
	     * 获取一个可以为onTriggerStay事件添加回调的Delegate。
	     * 从两个Trigger（或一个Trigger，一个非Trigger）碰撞体发生相交的第二帧开始，到两个物体分开，会持续生成onTriggerStay事件。
	     */
	    get onTriggerStay(): Delegate<ITriggerCollision>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/contactPoint' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import { Vector3_READONLY } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3'; const contactPointMap: WeakMap<phys3D.ContactPoint, ContactPoint>;
	export { contactPointMap };
	/**
	 * 物理事件返回的{@link Collision | 碰撞信息}中的碰撞点。
	 * @category Physics
	 */
	export interface IContactPoint {
	    /**
	     * 在该碰撞点处，两个碰撞体的距离。
	     *
	     * 不一定是0或小于0，因为只要两个碰撞体的距离小于{@link Collider.contactOffset}之和，就会判定为碰撞。
	     */
	    readonly separation: number;
	    /**
	     * 碰撞平面的法线。
	     */
	    readonly normal: Vector3_READONLY;
	    /**
	     * 碰撞点的位置。
	     */
	    readonly point: Vector3_READONLY;
	    /**
	     * 接收碰撞事件的碰撞体。
	     */
	    readonly thisCollider: Collider;
	    /**
	     * 另一个碰撞体。
	     */
	    readonly otherCollider: Collider;
	}
	export default class ContactPoint implements IContactPoint {
	    get separation(): number;
	    get normal(): Vector3_READONLY;
	    get point(): Vector3_READONLY;
	    get thisCollider(): Collider;
	    get otherCollider(): Collider;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collision' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import ContactPoint, { IContactPoint } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/contactPoint';
	import { Vector3_READONLY } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3'; const collisionMap: WeakMap<phys3D.Collision, Collision>;
	export { collisionMap };
	/**
	 * *物理模拟*中触发的碰撞事件（onCollisionXXX），返回的碰撞信息。
	 * @category Physics
	 * @readonly
	 */
	export interface ICollision {
	    /**
	     * 从碰撞到分离所用的冲量之和。
	     */
	    readonly impulse: Vector3_READONLY;
	    /**
	     * 两个刚体的相对线性碰撞速度。
	     */
	    readonly relativeVelocity: Vector3_READONLY;
	    /**
	     * 发生碰撞的另一个碰撞体。
	     */
	    readonly collider: Collider;
	    /**
	     * 本次碰撞的接触点。
	     */
	    readonly contacts: Array<IContactPoint>;
	}
	/**
	 * *物理模拟*中触发的Trigger事件（onTriggerXXX），返回的碰撞信息。
	 * @category Physics
	 * @readonly
	 */
	export interface ITriggerCollision {
	    /**
	    * 相交的另一个碰撞体。
	    */
	    readonly collider: Collider;
	}
	export default class Collision implements ICollision {
	    get impulse(): Vector3_READONLY;
	    get relativeVelocity(): Vector3_READONLY;
	    get collider(): Collider;
	    get contacts(): ContactPoint[];
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/script' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import Collision from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collision';
	import ControllerColliderHit from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/controllerColliderHit';
	import { TouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import TouchInputComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import KeyboardInputComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/KeyboardInputComponent';
	export default class Script extends Component {
	    readonly priority: number;
	    constructor(entity: Entity);
	    onAwake?(): void;
	    onStart?(): void;
	    onEnable?(): void;
	    onUpdate?(dt?: number): void;
	    onLateUpdate?(dt?: number): void;
	    onDisable?(): void;
	    onDestroy?(): void;
	    onTouchStart?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchEnd?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchMove?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchCancel?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchEnter?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchLeave?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchOver?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchOut?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onTouchUp?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onClick?(comp: TouchInputComponent, event: TouchInputEvent): void;
	    onKeyboardShow?(comp: KeyboardInputComponent, event: engineWX.KeyboardEvent): void;
	    onKeyboardInput?(comp: KeyboardInputComponent, event: engineWX.KeyboardEvent): void;
	    onKeyboardComplete?(comp: KeyboardInputComponent, event: engineWX.KeyboardEvent): void;
	    onKeyboardConfirm?(comp: KeyboardInputComponent, event: engineWX.KeyboardEvent): void;
	    onCollisionEnter?(collision: Collision): void;
	    onCollisionExit?(collision: Collision): void;
	    onCollisionStay?(collision: Collision): void;
	    onTriggerEnter?(collision: Collision): void;
	    onTriggerExit?(collision: Collision): void;
	    onTriggerStay?(collision: Collision): void;
	    onControllerColliderHit?(hit: ControllerColliderHit): void;
	    onFixedUpdate?(): void;
	    getComponent<T extends Component>(ctor: typeof Component): Nullable<T>;
	    getComponents<T extends Component>(ctor: typeof Component): T[];
	    addComponent<T extends Component>(ctor: typeof Component): Nullable<T>;
	    removeComponent(comp: Component): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorBlendTree' {
	/**
	 * jasonjwang doc
	 */
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip'; class AnimatorBlendTree {
	    name: string;
	    /**
	     * 混合树子节点。
	     */
	    get children(): Readonly<AnimatorBlendTree.AnimatorBlendTreeChild[]>;
	    /**
	     * 第一混合参数。
	     */
	    get blendParameterX(): Nullable<string>;
	    set blendParameterX(name: Nullable<string>);
	    /**
	     * 第二混合参数。
	     */
	    get blendParameterY(): Nullable<string>;
	    set blendParameterY(name: Nullable<string>);
	    /**
	     * 所有混合参数。
	     */
	    get blendParameters(): Readonly<string[]>;
	    /**
	     * 混合类型。
	     */
	    get blendType(): AnimatorBlendTree.BlendTreeType;
	    set blendType(blendType: AnimatorBlendTree.BlendTreeType);
	    /**
	     * 混合信息。
	     */
	    get blendInfo(): AnimatorBlendTree.AnimatorBlendInfo;
	    set blendInfo(info: AnimatorBlendTree.AnimatorBlendInfo);
	    /**
	     * 创建一颗混合树。
	     * @param name 混合树名称
	     */
	    constructor(name?: string);
	    /**
	     * 添加子节点。
	     * @param child 子节点
	     * @param thresholdOrposition 子节点信息
	     */
	    addChild(child: AnimatorBlendTree | AnimationClip): void;
	    addChild(child: AnimatorBlendTree | AnimationClip, threshold: number): void;
	    addChild(child: AnimatorBlendTree | AnimationClip, position: [number, number]): void;
	    /**
	     * 删除子节点。
	     * @param index 子节点索引
	     * @returns
	     */
	    removeChild(index: number): void;
	} namespace AnimatorBlendTree {
	    enum BlendTreeType {
	        Simple1D = 0,
	        SimpleDirectional2D = 1,
	        FreeformDirectional2D = 2,
	        FreeformCartesian2D = 3,
	        Direct = 4
	    }
	    interface AnimatorBlendInfo {
	        type: BlendTreeType.Simple1D | BlendTreeType.FreeformCartesian2D | BlendTreeType.FreeformDirectional2D | BlendTreeType.SimpleDirectional2D | BlendTreeType.Direct;
	    }
	    interface AnimatorBlendTreeChild {
	        motion: AnimatorBlendTree | AnimationClip;
	        threshold: Nullable<number>;
	        position: Nullable<[number, number]>;
	        timeScale: number;
	        cycleOffset: number;
	        directBlendParameter: Nullable<string>;
	    }
	}
	export default AnimatorBlendTree;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorCondition' {
	/**
	 * jasonjwang doc
	 */
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; class AnimatorCondition {
	    /**
	     * 状态机条件参数名称。
	     */
	    parameter: Nullable<string>;
	    /**
	     * 状态机条件操作符。
	     */
	    mode: AnimatorCondition.AnimatorConditionMode;
	    /**
	     * 状态机条件操作值。
	     */
	    threshold: number | boolean;
	} namespace AnimatorCondition {
	    /**
	     * 状态机条件枚举值。
	     */
	    enum AnimatorConditionMode {
	        If = 1,
	        IfNot = 2,
	        Greater = 3,
	        Less = 4,
	        ExitTime = 5,
	        Equals = 6,
	        NotEqual = 7
	    }
	}
	export default AnimatorCondition;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateTransition' {
	/**
	 * jasonjwang doc
	 */
	import AnimatorCondition from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorCondition';
	import AnimatorState from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorState';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; namespace Enumeration {
	    enum TransitionInterruptionSource {
	        None = 0,
	        Source = 1,
	        Destination = 2,
	        SourceThenDestination = 3,
	        DestinationThenSource = 4
	    }
	} class AnimatorStateTransition {
	    readonly name: string;
	    /**
	     * 是否启用转移退出时间。
	     */
	    hasExitTime: boolean;
	    /**
	     * 转移退出时间。
	     */
	    exitTime: number;
	    /**
	     * 是否使用绝对转移时长。
	     */
	    fixedDuration: boolean;
	    /**
	     * 转移时长。
	     */
	    duration: number;
	    /**
	     * 转移到目标状态的时间偏移量。
	     */
	    offset: number;
	    /**
	     * 状态转移的打断来源。
	     */
	    interruptionSource: AnimatorStateTransition.TransitionInterruptionSource;
	    /**
	     * 是否按优先级打断。
	     */
	    orderedInterruption: boolean;
	    /**
	     * 目标状态。
	     */
	    destState: Nullable<AnimatorState>;
	    /**
	     * 是否能转移袋自己。
	     */
	    canTransitionToSelf: boolean;
	    /**
	     * 所有的转移条件（exitTime除外）。
	     */
	    get conditions(): Readonly<AnimatorCondition[]>;
	    /**
	     * 创建一个新的转移。
	     * @param name 转移的名称
	     */
	    constructor(name?: string);
	    /**
	     * 添加一个转移条件。
	     * @param mode 操作类型
	     * @param threshold 对比值
	     * @param parameter 参数名称
	     */
	    addCondition(mode: AnimatorCondition.AnimatorConditionMode, threshold: number, parameter: string): void;
	    /**
	     * 移除一个转移条件。
	     * @param condition 条件对象
	     */
	    removeCondition(condition: AnimatorCondition): void;
	} namespace AnimatorStateTransition {
	    export import TransitionInterruptionSource = Enumeration.TransitionInterruptionSource;
	}
	export default AnimatorStateTransition;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorState' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import AnimatorBlendTree from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorBlendTree';
	import AnimatorStateTransition from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateTransition'; class AnimatorState {
	    /**
	     * 获取状态所包含的所有转移。
	     */
	    get transitions(): Readonly<AnimatorStateTransition[]>;
	    /**
	     * 状态的名称。
	     */
	    name: string;
	    /**
	     * 状态的播放速度。
	     */
	    speed: number;
	    /**
	     * 状态的速度参数。
	     */
	    speedParameter: Nullable<string>;
	    /**
	     * 状态的时间参数。
	     */
	    timeParameter: Nullable<string>;
	    /**
	     * 循环的起始偏移量。
	     */
	    cycleOffset: number;
	    /**
	     * 循环的起始偏移量参数。
	     */
	    cycleOffsetParameter: Nullable<string>;
	    /**
	     * 是否用默认值补齐未控制的骨骼及属性。
	     */
	    useDefaultValues: boolean;
	    /**
	     * 状态的动作对象，混合树或者动画资源。
	     */
	    motion: Nullable<AnimationClip | AnimatorBlendTree>;
	    /**
	     * 创建一个状态。
	     * @param name 状态名字
	     */
	    constructor(name?: string);
	    /**
	     * 添加转移。
	     * @param transition
	     */
	    addTransition(transition: AnimatorStateTransition): AnimatorStateTransition;
	    addTransition(state: Nullable<AnimatorState>, exitTime?: number): AnimatorStateTransition;
	    /**
	     * 移除转移。
	     * @param transition
	     */
	    removeTransition(transition: AnimatorStateTransition): void;
	} namespace AnimatorState { }
	export default AnimatorState;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateMachine' {
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimatorState from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorState';
	import AnimatorStateTransition from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateTransition'; class AnimatorStateMachine {
	    name: string;
	    /**
	     * 动画状态机的所有状态。
	     */
	    get states(): Readonly<AnimatorState[]>;
	    /**
	     * 动画状态机的默认状态。
	     */
	    get defaultState(): Nullable<AnimatorState>;
	    set defaultState(state: Nullable<AnimatorState>);
	    /**
	     * 动画状态机的“任意”状态。
	     */
	    get anyStateTransitions(): Readonly<AnimatorStateTransition[]>;
	    /**
	     * 创建一个状态机对象。
	     * @param name 状态机名称
	     */
	    constructor(name?: string);
	    /**
	     * 添加一个状态。
	     * @param name 状态的名字或者状态对象。
	     */
	    addState(name: string): AnimatorState;
	    addState(state: AnimatorState): void;
	    /**
	     * 添加一个“任意”状态的转移。
	     * @param destinationState 目标状态
	     * @returns
	     */
	    addAnyStateTransition(destinationState: AnimatorState): AnimatorStateTransition;
	    /**
	     * 移除一个“任意”状态的转移。
	     * @param transition 状态的转移
	     */
	    removeAnyStateTransition(transition: AnimatorStateTransition): void;
	    /**
	     * 移除一个状态。
	     * @param state 状态对象
	     */
	    removeState(state: AnimatorState): void;
	} namespace AnimatorStateMachine { }
	export default AnimatorStateMachine;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/weak-asset' {
	 enum Status {
	    Weak = "weak",
	    Strong = "strong"
	}
	export default class WeakAsset {
	    get status(): Status;
	    set status(status: Status);
	    get existed(): boolean;
	    get value(): any;
	    set value(value: any);
	    weaken(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/option' {
	 const _default: {
	    releaseResource: boolean;
	    releaseFileContent: boolean;
	};
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/load-inspector' {
	/**
	 * 这个模块仅用于线上和模拟器，IDE无法使用。
	 */
	import LoadTask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task';
	import LoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/game';
	import { UserFile } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file';
	export enum EContextStatus {
	    Initiated = 0,
	    LoadingManifest = 1,
	    Manifested_NoFile = 2,
	    LoadingFiles = 3,
	    Manifested_FileDownloaded_FileNotLoaded = 4,
	    Manifested_FileLoaded = 6
	}
	export class LoadInspector {
	    recording: boolean;
	    taskRecordBegin(task: LoadTask<any>, options: object): void;
	    taskRecordEnd(task: LoadTask<any>): void;
	    taskRecordContexts(task: LoadTask<any>): void;
	    contextStatusChange(context: LoadContext, status: EContextStatus): void;
	    fileDownloadBegin(file: UserFile, source: string): void;
	    fileDownloadEnd(file: UserFile, success: boolean): void;
	    setFileAsFromCache(file: UserFile): void;
	    setFileAsCached(file: UserFile): void;
	    clear(): void;
	    getLoaderProfile(): string;
	} const _default: LoadInspector;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/game' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import BaseLoadContext, { LoadType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import LoadTask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task';
	import { File } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file';
	import WeakAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/weak-asset';
	/**
	 * 负责管理一个组或者一个文件的下载过程
	 *
	 * @export
	 * @class LoadContext
	 */
	export default class LoadContext extends BaseLoadContext {
	    get progress(): {
	        total: number;
	        current: number;
	    };
	    get loaded(): boolean;
	    private get manifested();
	    id: string;
	    urls: string[];
	    size: number;
	    get cacheable(): boolean;
	    set cacheable(value: boolean);
	    constructor(id: string, urls: string[], size: number, cacheable: boolean);
	    registerTask(task: LoadTask<any>): void;
	    unregisterTask(task: LoadTask<any>): void;
	    load(type: LoadType): LitePromise<void>;
	    abort(): void;
	    getImageSrc(fileID: string): string;
	    getFileSrc(fileID: string): string;
	    getFile<T>(fileID: string): T | null;
	    getAsset<T>(assetID: string): T | null;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatar' {
	import { DeepImmutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { AvatarAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/game';
	/**
	 * 模型骨骼资源。
	 * @export
	 * @class Avatar
	 * @extends {BaseResource}
	 */
	export default class Avatar extends BaseResource {
	    /**
	     * 是否是优化过的模型。
	     * @type {boolean}
	     * @memberof Avatar
	     */
	    optimized: boolean;
	    /**
	     * 暴露的挂点信息。
	     * @type {DeepImmutable<number[]>}
	     * @memberof Avatar
	     */
	    exposedPaths: DeepImmutable<number[]>;
	    buffer: ArrayBuffer;
	    paths: DeepImmutable<string[]>;
	    /**
	     * 模型骨骼资源的反序列化方法。
	     * @static
	     * @param {AvatarAsset} resourceDescription
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {Avatar}
	     * @memberof Avatar
	     */
	    static DeserializeResource(resourceDescription: AvatarAsset, loadContext: BaseLoadContext): Avatar;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatarMask' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { AvatarMaskAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	/**
	 * 模型骨骼资源。
	 * @export
	 * @class Avatar
	 * @extends {BaseResource}
	 */
	export default class AvatarMask extends BaseResource {
	    name: string;
	    paths: {
	        [key: string]: number;
	    };
	    static DeserializeResource(resourceDescription: AvatarMaskAsset, loadContext: BaseLoadContext, dependencies: string[]): AvatarMask;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerLayer' {
	/**
	 * jasonjwang doc
	 */
	import AnimatorStateMachine from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateMachine';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AvatarMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatarMask'; class AnimatorControllerLayer {
	    name: string;
	    /**
	     * 动画状态机分层类型.
	     */
	    blendingMode: AnimatorControllerLayer.AnimatorLayerBlendingMode;
	    /**
	     * 动画状态机分层骨骼掩码。
	     */
	    avatarMask: Nullable<AvatarMask>;
	    /**
	     * 动画状态机分层权重。
	     */
	    weight: number;
	    /**
	     * 动画状态机分层中的状态机对象。
	     */
	    stateMachine: Nullable<AnimatorStateMachine>;
	    /**
	     * 创建一个分层。
	     * @param name 分层名称
	     */
	    constructor(name?: string);
	} namespace AnimatorControllerLayer {
	    /**
	     * 动画状态机分层类型枚举值。
	     */
	    enum AnimatorLayerBlendingMode {
	        Override = 0,
	        Additive = 1
	    }
	}
	export default AnimatorControllerLayer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerParameter' {
	 class AnimatorControllerParameter {
	    name: string;
	    /**
	     * 参数类型。
	     */
	    type: AnimatorControllerParameter.AnimatorControllerParameterType;
	    /**
	     * 浮点型的默认值。
	     */
	    defaultFloat: number;
	    /**
	     * 整型的默认值。
	     */
	    defaultInt: number;
	    /**
	     * 布尔值的默认值。
	     */
	    defaultBool: boolean;
	    /**
	     * 创建一个参数。
	     * @param name 参数名称
	     */
	    constructor(name?: string);
	} namespace AnimatorControllerParameter {
	    /**
	     * 动画状态机参数类型枚举值。
	     */
	    enum AnimatorControllerParameterType {
	        Float = 1,
	        Int = 3,
	        Bool = 4,
	        Trigger = 9
	    }
	}
	export default AnimatorControllerParameter;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Instantiate' {
	import AnimatorBlendTree from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorBlendTree';
	import AnimatorController from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorController';
	import AnimatorControllerLayer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerLayer';
	import AnimatorControllerParameter from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerParameter';
	import AnimatorStateTransition from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateTransition';
	import { DeepImmutable, Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimatorCondition from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorCondition';
	import type AnimatorControllerAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animatorController';
	export interface IDescriptionParameter {
	    name: string;
	    type: AnimatorControllerParameter.AnimatorControllerParameterType;
	    default?: any;
	}
	export interface IDescriptionMotionBlendTree {
	    type: "BlendTree";
	    id: number;
	}
	export interface IDescriptionMotionAnimationClip {
	    type: "AnimationClip";
	    id: string;
	}
	export interface IDescriptionBlendTreeChild {
	    motion: IDescriptionMotionBlendTree | IDescriptionMotionAnimationClip;
	    threshold?: number;
	    timeScale?: number;
	    position?: [number, number];
	    directBlendParameter?: string;
	}
	export interface IDescriptionBlendTree {
	    name: string;
	    children: Array<IDescriptionBlendTreeChild>;
	    blend: {
	        type: AnimatorBlendTree.BlendTreeType.Simple1D;
	        parameter: number;
	    } | {
	        parameterX: number;
	        parameterY: number;
	        type: AnimatorBlendTree.BlendTreeType.FreeformDirectional2D | AnimatorBlendTree.BlendTreeType.FreeformCartesian2D | AnimatorBlendTree.BlendTreeType.SimpleDirectional2D;
	    } | {
	        type: AnimatorBlendTree.BlendTreeType.Direct;
	        parameters: number[];
	    };
	}
	export interface IDescriptionTransition {
	    name: string;
	    conditions: Array<{
	        name: string;
	        operator: AnimatorCondition.AnimatorConditionMode;
	        value: number | boolean;
	    }>;
	    fixedDuration: boolean;
	    duration: number;
	    offset: number;
	    interruption: AnimatorStateTransition.TransitionInterruptionSource;
	    orderedInterruption: boolean;
	    exitTime: number;
	    hasExitTime: boolean;
	    canTransitionToSelf: boolean;
	    destState: Nullable<{
	        type: "State" | "StateMachine";
	        id: number;
	    }>;
	}
	export interface IDescriptionState {
	    name: string;
	    motion: Nullable<IDescriptionMotionBlendTree | IDescriptionMotionAnimationClip>;
	    speed: number;
	    transitions: number[];
	    cycleOffset: number;
	    cycleOffsetParameter: Nullable<string>;
	    speedParameter: Nullable<string>;
	    timeParameter: Nullable<string>;
	}
	export interface IDescriptionStateMachine {
	    name: string;
	    states: number[];
	    defaultState: Nullable<number>;
	    anyStateTransitions: number[];
	}
	export interface IDescriptionLayer {
	    name: string;
	    stateMachine: number;
	    blending: AnimatorControllerLayer.AnimatorLayerBlendingMode;
	    IKPass: boolean;
	    /**
	     * Avatar mask
	     */
	    mask?: string;
	    weight: number;
	}
	interface IAnimatorControllerDescription {
	    name?: string;
	    layers: Array<IDescriptionLayer>;
	    stateMachines: Array<IDescriptionStateMachine>;
	    states: Array<IDescriptionState>;
	    transitions: Array<IDescriptionTransition>;
	    blendTrees: Array<IDescriptionBlendTree>;
	    parameters: Array<IDescriptionParameter>;
	}
	export type AnimatorControllerDescription = DeepImmutable<IAnimatorControllerDescription>;
	export default function Instantiate(asset: AnimatorControllerAsset, result?: AnimatorController): AnimatorController;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorController' {
	/**
	 * jasonjwang doc
	 */
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import AnimatorControllerLayer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerLayer';
	import AnimatorControllerParameter from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerParameter';
	import Instantiate from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Instantiate'; class AnimatorController {
	    name: string;
	    /**
	     * 获取所有的分层对象。
	     */
	    get layers(): Readonly<AnimatorControllerLayer[]>;
	    /**
	     * 获取所有的参数对象。
	     */
	    get parameters(): Readonly<AnimatorControllerParameter[]>;
	    /**
	     * 创建一个控制器对象。
	     * @param name 控制器名称
	     */
	    constructor(name?: string);
	    /**
	     * 通过字符串或者对象添加一个新的分层。
	     * @param layer
	     */
	    addLayer(layer: string): void;
	    addLayer(layer: AnimatorControllerLayer): void;
	    /**
	     * 通过索引或者对象删除一个分层。
	     * @param layer
	     */
	    removeLayer(layer: number): void;
	    removeLayer(layer: AnimatorControllerLayer): void;
	    /**
	     * 添加一个参数。
	     * @param parameter
	     * @param type
	     */
	    addParameter(name: string, type: AnimatorControllerParameter.AnimatorControllerParameterType): void;
	    addParameter(parameter: AnimatorControllerParameter): void;
	    /**
	     * 移除一个参数。
	     * @param parameter
	     */
	    removeParameter(parameter: number): void;
	    removeParameter(parameter: string): void;
	    removeParameter(parameter: AnimatorControllerParameter): void;
	} namespace AnimatorController {
	    /**
	     * 从动画控制器资源实例化一个动画控制器对象。
	     */
	    const CreateFromAsset: typeof Instantiate;
	}
	export default AnimatorController;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animatorController' {
	import { default as RuntimeAnimatorController } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorController';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { AnimatorControllerDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Instantiate';
	/**
	 * 动画状态机资源。
	 * @export
	 * @class AnimatorController
	 * @extends {BaseResource}
	 */
	export default class AnimatorController extends BaseResource {
	    readonly description: AnimatorControllerDescription;
	    /**
	     * 强持有所依赖的资源，防止该资源长时间未实例化时，其依赖的资源因weakRef机制被释放。
	     * @private
	     * @type {BaseResource[]}
	     * @memberof AnimatorController
	     */
	    dependencies?: BaseResource[];
	    /**
	     * 通过资源描述文件创建动画状态机资源。
	     * @param {AnimatorControllerDescription} description 资源描述。
	     * @memberof AnimatorController
	     */
	    constructor(description: AnimatorControllerDescription);
	    static ExtractClipAndMaskAssets(description: AnimatorControllerDescription): {
	        clips: string[];
	        masks: string[];
	    };
	    /**
	     * 动画状态机资源的反序列化方法。
	     * @static
	     * @param {AnimatorControllerDescription} description 资源描述。
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {AnimatorController} 动画状态机资源。
	     * @memberof AnimatorController
	     */
	    static DeserializeResource(description: AnimatorControllerDescription, loadContext: BaseLoadContext, dependencies: string[]): AnimatorController;
	    /**
	     * 实例化动画状态机。
	     * @returns {RuntimeAnimatorController}
	     * @memberof AnimatorController
	     * @returns {RuntimeAnimatorController} 动画状态机实例。
	     */
	    instantiate(): RuntimeAnimatorController;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorError' {
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	export enum ErrorCode {
	    /**
	     * Calcution errors.
	     */
	    InvalidNormalizedTime = 4608,
	    MissingParameter = 4609,
	    InvalidParameterValue = 4610,
	    /**
	     * Logic errors.
	     */
	    ClipIndexOutOfRange = 4864,
	    MissingStateMachine = 4865,
	    InvalidTransition = 4866,
	    StateMachineTransitionNotSupport = 4867,
	    /**
	     * API params errors.
	     */
	    InvalidCrossFadeStateName = 5120,
	    InvalidCrossFadeLayerName = 5121,
	    CrossFadeStateNameNotFound = 5122,
	    CrossFadeLayerIndexOutOfRange = 5123,
	    InvalidParameterName = 5124
	}
	export const AnimatorErrors: {
	    4608: () => void;
	    4609: (name: string) => void;
	    4610: (name: string, value: any) => void;
	    4864: (animationClip: AnimationClip) => void;
	    4865: (layerName: string) => void;
	    4866: () => void;
	    4867: () => void;
	    5120: (stateName: string) => void;
	    5121: (layerName: string) => void;
	    5122: (layerName: string, stateName: string) => void;
	    5123: (layerIndex: number) => void;
	    5124: (name: string, call: string) => void;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Interruption' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Animator, { IAnimatorControllerLayerInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator';
	import AnimatorStateTransition from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateTransition';
	import AnimatorState from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorState';
	export const EmptyState: Animator.AnimatorState;
	export function GetInterruptionTransition(this: void, animator: Animator, entryState: AnimatorState, anyStateTransitions: AnimatorStateTransition[], layerInfo: IAnimatorControllerLayerInfo, dt: number, dst: {
	    transition: Nullable<AnimatorStateTransition>;
	    remain: number;
	    isInterruptedByDestination: boolean;
	}): void;
	export function GetStateActiveTransition(this: void, animator: Animator, entryState: AnimatorState, anyStateTransitions: AnimatorStateTransition[], layerInfo: IAnimatorControllerLayerInfo, state: AnimatorState, transition: Nullable<AnimatorStateTransition>, normalizedTime: number, dt: number, orderedInterruption: boolean, dst: {
	    transition: Nullable<AnimatorStateTransition>;
	    remain: number;
	    isInterruptedByDestination: boolean;
	}): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Blending' {
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Animator from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator';
	import AnimatorState from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorState';
	export interface IAnimationClipBlendInfo {
	    clip: Nullable<AnimationClip>;
	    length: number;
	    weight: number;
	    speed: number;
	    parentIndex: number;
	    selfLoop: boolean;
	    loop: boolean;
	}
	export const AnimationClipInfos: SmartArray<IAnimationClipBlendInfo>;
	export const MaxBlendTreeNodeNum: 256;
	export function GenerateBlendingInfo(this: void, animator: Animator, currentState: AnimatorState): number;
	export function ClearGeneratedBlendingInfo(count: number): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skeleton' {
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Avatar from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatar';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { AnimationUtility } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Utility';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import SkinnedMeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skinnedMeshRenderer';
	export type SkeletonConfiguration = {
	    type: AnimationUtility.AnimationAvatarBindingType.Static;
	    avatar: Avatar;
	    remapping: AnimationUtility.StaticRemapping;
	} | {
	    type: AnimationUtility.AnimationAvatarBindingType.Dynamic;
	    remapping: AnimationUtility.DynamicRemapping;
	};
	export type SkeletonConfigurationJSON = {
	    type: AnimationUtility.AnimationAvatarBindingType.Dynamic;
	    remapping: {
	        [key: string]: number | null;
	    };
	} | {
	    type: AnimationUtility.AnimationAvatarBindingType.Static;
	    avatar: string;
	    remapping: {
	        [key: string]: {
	            modelPath: string | "=" | "-";
	            bindingTransform: number | null;
	        };
	    };
	};
	export enum SkeletonEvent {
	    Configuration = 1,
	    Active = 2
	}
	export default class Skeleton extends Component {
	    readonly entity: Entity3D;
	    constructor(entity: Entity3D);
	    get optimized(): boolean;
	    get configuration(): Nullable<SkeletonConfiguration>;
	    set configuration(configuration: Nullable<SkeletonConfiguration>);
	    event: Emitter<Skeleton, number>;
	    skinnedMeshRenderers: Set<SkinnedMeshRenderer>;
	    onDeserialized(data: {
	        configuration: SkeletonConfigurationJSON;
	    }, context: {
	        [key: string]: any[];
	    }, builtContext: {
	        [key: string]: SmartArray<any>;
	    }): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator' {
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import type { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimatorBlendTreeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorBlendTree';
	import AnimatorConditionClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorCondition';
	import AnimatorControllerClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorController';
	import AnimatorControllerLayerClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerLayer';
	import AnimatorControllerParameterClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerParameter';
	import AnimatorStateClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorState';
	import AnimatorStateMachineClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateMachine';
	import AnimatorStateTransitionClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateTransition';
	import type { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import AnimationEventClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimationEvent';
	import { AnimationUtility } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Utility';
	import Skeleton from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skeleton';
	export interface IAnimatorStateInfo {
	    name: string;
	    length: number;
	    normalizedTime: number;
	    frames: Map<AnimationClip, number>;
	}
	export interface IAnimatorStateTransitionInfo {
	    anyState: boolean;
	    duration: number;
	    time: number;
	    fixedDuration: boolean;
	    normalizedTime: number;
	    transitionOffset: number;
	}
	interface IAnimatorControllerLayerInfoState {
	    currentState: AnimatorStateClass;
	    nextState: null;
	    currentTransition: null;
	    stateInfo: IAnimatorStateInfo;
	    nextStateInfo: null;
	    transitionInfo: null;
	}
	interface IAnimatorControllerLayerInfoTransition {
	    currentState: AnimatorStateClass;
	    nextState: AnimatorStateClass;
	    currentTransition: AnimatorStateTransitionClass;
	    stateInfo: IAnimatorStateInfo;
	    nextStateInfo: IAnimatorStateInfo;
	    transitionInfo: IAnimatorStateTransitionInfo;
	}
	export type IAnimatorControllerLayerInfo = IAnimatorControllerLayerInfoState | IAnimatorControllerLayerInfoTransition; class Animator extends Component {
	    readonly entity: Entity3D;
	    /**
	     * 动画状态机的分层。
	     */
	    get layers(): Readonly<Animator.AnimatorControllerLayer[]>;
	    /**
	     * 动画状态机的分层数目。
	     */
	    get layerCount(): number;
	    /**
	     * 动画状态机的参数。
	     */
	    get parameters(): Readonly<Animator.AnimatorControllerParameter[]>;
	    /**
	     * 动画状态机的参数数目。
	     */
	    get parameterCount(): number;
	    /**
	     * 动画状态机的整体播放速度，可以设为0来实现暂停功能。
	     */
	    get speed(): number;
	    set speed(speed: number);
	    /**
	     * 是否动态绑定动画资源，对于包含大量动画资源的动画状态机能够降低初始化耗时。
	     */
	    bindAnimationClipOnNeed: boolean;
	    /**
	     * 动画状态机所操控的骨架。
	     */
	    get skeleton(): Nullable<Skeleton>;
	    set skeleton(skeleton: Nullable<Skeleton>);
	    /**
	     * 动画状态机的控制器。
	     */
	    get controller(): Nullable<Animator.AnimatorController>;
	    set controller(controller: Nullable<Animator.AnimatorController>);
	    /**
	     * 是否支持转移中断逻辑，默认关闭。
	     */
	    interruptionSupport: boolean;
	    constructor(entity: Entity3D);
	    /**
	     * 获取指定分层的当前动画状态信息。
	     * @param layerIndex 分层索引
	     * @returns 对应分层当前动画状态信息
	     */
	    getCurrentAnimatorStateInfo(layerIndex?: number): Nullable<IAnimatorStateInfo>;
	    /**
	     * 获取指定分层的当前动画状态对象。
	     * @param layerIndex 分层索引
	     * @returns 对应分层当前动画状态对象
	     */
	    getCurrentAnimatorState(layerIndex?: number): Nullable<Animator.AnimatorState>;
	    getCurrentAnimatorTransitionInfo(layerIndex?: number): Nullable<IAnimatorStateTransitionInfo>;
	    /**
	     * 获取指定分层的当前动画转移对象。
	     * @param layerIndex 分层索引
	     * @returns 对应分层当前动画转移对象
	     */
	    getCurrentAnimatorTransition(layerIndex?: number): Nullable<Animator.AnimatorStateTransition>;
	    /**
	     * 获取指定分层的当前动画下一状态对象。
	     * @param layerIndex 分层索引
	     * @returns 如果当前状态存在并正在转移转移，则返回对应分层当前状态转移的目标状态对象
	     */
	    getNextAnimatorStateInfo(layerIndex?: number): Nullable<IAnimatorStateInfo>;
	    /**
	     * 获取动画状态机的参数。
	     * @param name 参数名称
	     * @returns
	     */
	    getParameter(name: string): Nullable<Animator.AnimatorControllerParameter>;
	    /**
	     * 获取对应参数名的浮点数值。
	     * @param arg 参数名称
	     * @returns
	     */
	    getFloat(arg: string): Nullable<number>;
	    /**
	     * 设置对应参数名的浮点数值。
	     * @param arg 参数名称
	     * @param value 浮点数值
	     */
	    setFloat(arg: string, value: number): void;
	    /**
	     * 获取对应参数名的整型数值。
	     * @param arg 参数名称
	     * @returns
	     */
	    getInteger(arg: string): Nullable<number>;
	    /**
	     * 设置对应参数名的整型数值。
	     * @param arg 参数名称
	     * @param value 整型数值
	     */
	    setInteger(arg: string, value: number): void;
	    /**
	     * 获取对应参数名的布尔型值。
	     * @param arg 参数名称
	     * @returns
	     */
	    getBool(arg: string): Nullable<boolean>;
	    /**
	     * 设置对应参数名的布尔型值。
	     * @param arg 参数名称
	     * @param value 布尔型值
	     */
	    setBool(arg: string, value: boolean): void;
	    /**
	     * 设置对应参数名的触发器。
	     * @param arg 参数名称
	     */
	    setTrigger(arg: string): void;
	    /**
	     * 重置对应参数名的触发器。
	     * @param arg 参数名称
	     */
	    resetTrigger(arg: string): void;
	    /**
	     * 获取动画状态机指定分层的当前转移信息。
	     * @param layerIndex 分层索引
	     * @returns
	     */
	    getAnimatorTransitionInfo(layerIndex: number): Nullable<IAnimatorStateTransitionInfo>;
	    /**
	     * 获取分层的权重。
	     * @param layerIndex 分层索引
	     * @returns
	     */
	    getLayerWeight(layerIndex?: number): number;
	    /**
	     * 查询动画状态机指定分层是否包含指定名称的动画状态。
	     * @param layerIndex 分层索引
	     * @param name 动画状态名称
	     * @returns
	     */
	    hasState(layerIndex: number, name: string): boolean;
	    /**
	     * 重绑动画。
	     * @param flag 重绑类型
	     */
	    rebind(flag?: number): void;
	    /**
	     * 查询动画状态机指定分层是否正在发生状态转移。
	     * @param layerIndex 分层索引
	     * @returns
	     */
	    isInTransition(layerIndex: number): boolean;
	    /**
	     * 指定一个分层，播放指定动画状态。
	     * @param {string} stateName 动画状态的名称，当第二个参数（分层索引）未设置的时候需要加上分层名称，例如：'Base Layer.Run'
	     * @param {int} layer 分层索引
	     * @param {float} normalizedTime 动画状态已播放的归一化时长
	     */
	    play(stateName: string, layer?: number, normalizedTime?: number): void;
	    /**
	     * 指定一个分层，设置从当前动画状态过渡到指定动画状态。
	     * @param {string} fullOrPartialName 动画状态的名称，当第二个参数（分层索引）未设置的时候需要加上分层名称，例如：'Base Layer.Run'
	     * @param {float} normalizedTransitionDuration 过渡时长
	     * @param {int} layer 分层索引
	     * @param {float} normalizedTimeOffset 动画状态已播放的归一化时长偏移
	     * @param {float} normalizedTransitionTime 动画状态转移已流逝的归一化时长
	     * @param {boolean} fixedDuration 过渡时长是否被视为绝对长度（单位为秒），如果为false则被视为转移长度的百分比
	     */
	    crossFade(fullOrPartialName: string, normalizedTransitionDuration: number, layer?: number, normalizedTimeOffset?: number, normalizedTransitionTime?: number, fixedDuration?: boolean): void;
	    /**
	     * 恢复动画绑定前的默认骨骼姿态。
	     */
	    writeDefaults(): void;
	    /**
	     * 指定一段时长并更新动画。
	     * @param dt 时长（单位秒），可以为0
	     */
	    update(dt: number): void;
	} namespace Animator {
	    /**
	     * 动画事件类。
	     */
	    export import AnimationEvent = AnimationEventClass;
	    /**
	     * 动画混合树类。
	     */
	    export import AnimatorBlendTree = AnimatorBlendTreeClass;
	    /**
	     * 动画状态机转移条件类。
	     */
	    export import AnimatorCondition = AnimatorConditionClass;
	    /**
	     * 动画状态机类。
	     */
	    export import AnimatorController = AnimatorControllerClass;
	    /**
	     * 动画状态机分层类。
	     */
	    export import AnimatorControllerLayer = AnimatorControllerLayerClass;
	    /**
	     * 动画状态机参数类。
	     */
	    export import AnimatorControllerParameter = AnimatorControllerParameterClass;
	    /**
	     * 动画状态机动画状态类。
	     */
	    export import AnimatorState = AnimatorStateClass;
	    /**
	     * 动画状态机状态机类。
	     */
	    export import AnimatorStateMachine = AnimatorStateMachineClass;
	    /**
	     * 动画状态机转移类。
	     */
	    export import AnimatorStateTransition = AnimatorStateTransitionClass;
	    /**
	     * 动画状态机重绑定类型枚举值。
	     */
	    enum AnimatorRebindType {
	        Skeleton = 1,
	        Controller = 2
	    }
	    /**
	     * 动画状态机使用限制参数。
	     */
	    const Limits: Readonly<{
	        MaxBlendTreeNodeNum: 256;
	    }>;
	    /**
	     * 动画状态机全局配置。
	     */
	    const Features: {
	        InterruptionSupport: boolean;
	    };
	}
	export default Animator;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Allocator' {
	/**
	 * jasonjwang doc
	 */
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import AnimationEvent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimationEvent';
	import { IAnimatorControllerLayerInfo, IAnimatorStateInfo, IAnimatorStateTransitionInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator';
	import AnimatorStateTransition from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorStateTransition';
	import { IAnimationClipBlendInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Blending';
	export interface IAllocator<T> {
	    alloc(): T;
	    free(t: T): void;
	} class AnimatorControllerLayerInfoAllocatorImpl implements IAllocator<IAnimatorControllerLayerInfo> {
	    alloc(): IAnimatorControllerLayerInfo;
	    free(t: IAnimatorControllerLayerInfo): void;
	}
	export const AnimatorControllerLayerInfoAllocator: AnimatorControllerLayerInfoAllocatorImpl; class AnimatorStateInfoAlloctorImpl implements IAllocator<IAnimatorStateInfo> {
	    alloc(): IAnimatorStateInfo;
	    free(t: IAnimatorStateInfo): void;
	}
	export const AnimatorStateInfoAlloctor: AnimatorStateInfoAlloctorImpl; class AnimatorStateTransitionInfoAlloctorImpl implements IAllocator<IAnimatorStateTransitionInfo> {
	    alloc(): IAnimatorStateTransitionInfo;
	    free(t: IAnimatorStateTransitionInfo): void;
	}
	export const AnimatorStateTransitionInfoAlloctor: AnimatorStateTransitionInfoAlloctorImpl; class AnimationClipBlendInfoAlloctorImpl implements IAllocator<IAnimationClipBlendInfo> {
	    alloc(): IAnimationClipBlendInfo;
	    free(t: IAnimationClipBlendInfo): void;
	}
	export const AnimationClipBlendInfoAlloctor: AnimationClipBlendInfoAlloctorImpl; class AnimatorClipEventInfoAlloctorImpl implements IAllocator<AnimationEvent.IAnimatorClipInfo> {
	    alloc(): AnimationEvent.IAnimatorClipInfo;
	    free(t: AnimationEvent.IAnimatorClipInfo): void;
	}
	export const AnimatorClipEventInfoAllocator: AnimatorClipEventInfoAlloctorImpl;
	interface IAnimatorInterruptResult {
	    transition: Nullable<AnimatorStateTransition>;
	    remain: number;
	    isInterruptedByDestination: boolean;
	} class AnimatorInterruptResultAlloctorImpl implements IAllocator<IAnimatorInterruptResult> {
	    alloc(): IAnimatorInterruptResult;
	    free(t: IAnimatorInterruptResult): void;
	}
	export const AnimatorInterruptResultAlloctor: AnimatorInterruptResultAlloctorImpl;
	interface IAnimatorCheckTransitionAvtiveResult {
	    active: boolean;
	    transitionRemainedTime: number;
	} class IAnimatorCheckTransitionAvtiveResultAlloctorImpl implements IAllocator<IAnimatorCheckTransitionAvtiveResult> {
	    alloc(): IAnimatorCheckTransitionAvtiveResult;
	    free(t: IAnimatorCheckTransitionAvtiveResult): void;
	}
	export const AnimatorCheckTransitionAvtiveResultAlloctor: IAnimatorCheckTransitionAvtiveResultAlloctorImpl;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimationEvent' {
	/**
	 * jasonjwang doc
	 */
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip'; class AnimationEvent {
	    /**
	     * 动画事件中的动画片段信息。
	     */
	    get animatorClipInfo(): AnimationEvent.IAnimatorClipInfo;
	    /**
	     * 动画事件的回调名称。
	     */
	    functionName: Nullable<string>;
	    /**
	     * 动画事件的回调的额外数字类型参数。
	     */
	    stringParameter: Nullable<string>;
	    /**
	     * 动画事件的回调的额外数字类型参数。
	     */
	    numberParameter: number;
	    /**
	     * 动画事件的回调的额外对象类型参数。
	     */
	    objectReferenceParameter: any;
	    /**
	     * 是否是Animator组件触发的事件。
	     */
	    isFiredByAnimator: boolean;
	    /**
	     * 是否是Animation组件触发的事件。
	     */
	    isFiredByLegacy: boolean;
	    /**
	     * 动画片段所播放的时间。
	     */
	    time: number;
	    /**
	     * 复制动画事件对象。
	     * @returns 复制的画事件对象
	     */
	    clone(): AnimationEvent;
	} namespace AnimationEvent {
	    interface IAnimatorClipInfo {
	        clip: AnimationClip;
	        weight: number;
	    }
	}
	export default AnimationEvent;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip' {
	import { MetaAnimationClipModel } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/MetaAnimation';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { AnimationClipAsset, IMetaAssetInfo, WrapMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import AnimationEvent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimationEvent';
	interface IClipBufferObj {
	    boneBuffer?: ArrayBuffer;
	    metaBuffer?: ArrayBuffer;
	}
	/**
	 * 动画片段资源。
	 * @export
	 * @class AnimationClip
	 * @extends {BaseResource}
	 */
	export default class AnimationClip extends BaseResource {
	    /**
	     * 动画片段的关键帧数。
	     * @readonly
	     * @type {number}
	     * @memberof AnimationClip
	     */
	    get frameLength(): number;
	    /**
	     * 动画片段的帧率。
	     * @readonly
	     * @type {number}
	     * @memberof AnimationClip
	     */
	    get frameRate(): number;
	    /**
	     * 动画片段的时长，单位秒。
	     * @readonly
	     * @type {number}
	     * @memberof AnimationClip
	     */
	    get length(): number;
	    /**
	     * 动画片段所控制的节点路径。
	     * @readonly
	     * @type {string[]}
	     * @memberof AnimationClip
	     */
	    get paths(): string[];
	    /**
	     * 动画片段所控制的节点路径（索引号）以及控制的属性字段。
	     * @readonly
	     * @type {Array<[number, string]>}
	     * @memberof AnimationClip
	     */
	    get props(): Array<[number, string]>;
	    /**
	     * Genetic动画的播放模式。
	     * @readonly
	     * @type {WrapMode}
	     * @memberof AnimationClip
	     *
	     * 加下面的@property 是为了vue中更新
	     */
	    get wrapMode(): WrapMode;
	    /**
	     * Genetic动画的播放起始位置。
	     * @readonly
	     * @type {number}
	     * @memberof AnimationClip
	     */
	    get startTime(): number;
	    /**
	     * Genetic动画的播放终止位置。
	     * @readonly
	     * @type {number}
	     * @memberof AnimationClip
	     */
	    get stopTime(): number;
	    /**
	     * 非Genetic动画的循环设置。
	     * @readonly
	     * @type {boolean}
	     * @memberof AnimationClip
	     *
	     * 加下面的@property 是为了vue中更新
	     */
	    get loopTime(): boolean;
	    /**
	     * 非Genetic动画的循环偏移量。
	     * @readonly
	     * @type {number}
	     * @memberof AnimationClip
	     */
	    get cycleOffset(): number;
	    /**
	     * 动画事件列表
	     * @readonly
	     * @type {AnimationEvent[]}
	     * @memberof AnimationClip
	     */
	    readonly events: AnimationEvent[];
	    metaAssets: IMetaAssetInfo[];
	    static WrapMode: typeof WrapMode;
	    addEvent(event: AnimationEvent): void;
	    removeEvent(event: AnimationEvent): void;
	    clone(): AnimationClip;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Utility' {
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import type AvatarMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatarMask';
	import AnimatorControllerLayer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorControllerLayer';
	import type { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import type Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import type Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import AnimatorController from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorController';
	import Avatar from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatar';
	export namespace AnimationUtility {
	    namespace Internal {
	        namespace AnimationCore {
	            function CreateAnimationCore(description: IAnimationCoreDescription, avatarBinding: IAnimationAvatarBinding, options?: IAnimationCoreRebindOption): IAnimationCore;
	            function CreateAnimationCore(controller: Nullable<AnimatorController>, avatarBinding: IAnimationAvatarBinding, options?: IAnimationCoreRebindOption): IAnimationCore;
	            function CreateAnimationCore2D(description: IAnimationCoreDescription, avatarBinding: IAnimationAvatarBinding): IAnimationCore;
	            function CreateAnimationCore2D(controller: Nullable<AnimatorController>, avatarBinding: IAnimationAvatarBinding): IAnimationCore;
	        }
	        namespace AnimationAvatarBinding {
	            function CreateAnimationAvatarBinding(avatar: Avatar, root: Transform3D, remapping?: StaticRemapping): IAnimationAvatarBinding;
	            function CreateAnimationAvatarBinding(root: Transform3D, remapping?: DynamicRemapping): IAnimationAvatarBinding;
	            function CreateAnimationAvatarBinding2D(avatar: Nullable<Avatar>, root: Transform2D): IAnimationAvatarBinding;
	        }
	        namespace AnimationClipBinding {
	            /**
	             * IAnimationClipBinding represet a binding that connect animation clips with the transforms(visible) they take control.
	             * @export
	             * @interface IAnimationClipBinding
	             */
	            interface IAnimationClipBinding {
	                readonly animationClips: SmartArray<AnimationClip>;
	                readonly animationClipCount: number;
	                readonly maxStateBlendConcurrency: number;
	                writeDefaults(): void;
	                dispose(): void;
	            }
	            function RebindAnimationClipBindingByDescription(this: void, clipBinding: IAnimationClipBinding, description: IAnimationCoreDescription, avatarBinding: IAnimationAvatarBinding, options?: IAnimationCoreRebindOption): void;
	            function RebindAnimationClipBindingByAnimatorController(this: void, clipBinding: IAnimationClipBinding, controller: Nullable<AnimatorController>, avatarBinding: IAnimationAvatarBinding, options?: IAnimationCoreRebindOption): void;
	            function CreateAnimationClipBinding(description: IAnimationCoreDescription, avatarBinding: IAnimationAvatarBinding, options?: IAnimationCoreRebindOption): IAnimationClipBinding;
	            function CreateAnimationClipBinding2D(description: IAnimationCoreDescription, avatarBinding: IAnimationAvatarBinding): IAnimationClipBinding;
	        }
	    }
	    export enum AnimationAvatarBindingType {
	        Static = 0,
	        Dynamic = 1
	    }
	    /**
	     * 动画骨骼姿态管理核心API模块。
	     */
	    export interface IAnimationAvatarBinding {
	        /**
	         * 骨骼绑定类型。
	         */
	        readonly type: AnimationAvatarBindingType;
	        /**
	         * 骨骼根节点。
	         */
	        readonly root: Transform3D | Transform2D;
	        /**
	         * 提取或者返回一个骨骼路劲所对应的节点。
	         * @param path 骨骼路径
	         * @param isAnimation 是否使用动画重定向。
	         */
	        extract(path: string, isAnimation?: boolean): Nullable<Transform3D | Transform2D>;
	        /**
	         * 返回一个骨骼路劲所对应的节点。
	         * @param path 骨骼路径
	         * @param isAnimation 是否使用动画重定向。
	         */
	        getExtractedNode(path: string, isAnimation?: boolean): Nullable<Transform3D>;
	        /**
	         * 析构对象，清除不必要的内存。
	         */
	        dispose(): void;
	    }
	    export const CreateAnimationAvatarBinding: typeof Internal.AnimationAvatarBinding.CreateAnimationAvatarBinding;
	    export const CreateAnimationAvatarBinding2D: typeof Internal.AnimationAvatarBinding.CreateAnimationAvatarBinding2D;
	    export enum AnimationCoreRebindAddAction {
	        Ignore = 0,
	        Refresh = 1
	    }
	    export enum AnimationCoreRebindRetainAction {
	        Keep = 0,
	        Refresh = 1,
	        WriteBack = 2
	    }
	    export enum AnimationCoreRebindRemoveAction {
	        Keep = 0,
	        Clear = 1,
	        WriteBack = 2
	    }
	    export interface IAnimationCoreRebindOption {
	        removedOp?: number;
	        retainedOp?: number;
	        addedOp?: number;
	        bindAnimationClipOnNeed?: boolean;
	    }
	    /**
	     * 动画混合计算核心API模块。
	     */
	    export interface IAnimationCore {
	        /**
	         * 动画数目。
	         */
	        readonly animationClipCount: number;
	        /**
	         * 动画数组（请不要通过.length来遍历，使用animationClipCount）。
	         */
	        readonly animationClips: Readonly<ArrayLike<AnimationClip>>;
	        /**
	         * 设置分层的节点掩码。
	         * @param layerIndex 层索引
	         * @param mask 节点掩码
	         */
	        setLayerMask(layerIndex: number, mask: Nullable<AvatarMask>): void;
	        /**
	         * 设置分层类型。
	         * @param layerIndex 层索引
	         * @param type 分层类型
	         */
	        setLayerType(layerIndex: number, type: AnimatorControllerLayer.AnimatorLayerBlendingMode): void;
	        /**
	         * 设置分层权重。
	         * @param layerIndex 层索引
	         * @param weight 权重
	         */
	        setLayerWeight(layerIndex: number, weight: number): void;
	        /**
	         * 设置状态的默认值行为。
	         * @param layerIndex 层索引
	         * @param stateIndex 状态索引
	         * @param writeDefaults 默认值行为（是否启用默认补全）
	         */
	        setStateWriteDefaults(layerIndex: number, stateIndex: number, writeDefaults: boolean): void;
	        /**
	         * 设置状态的权重。
	         * @param layerIndex 层索引
	         * @param stateIndex 状态索引
	         * @param weight 权重
	         */
	        setStateWeight(layerIndex: number, stateIndex: number, weight: number): void;
	        /**
	         * 获取状态的权重。
	         * @param layerIndex 层索引
	         * @param stateIndex 状态索引
	         */
	        getStateWeight(layerIndex: number, stateIndex: number): number;
	        /**
	         * 设置状态的动画权重。
	         * @param layerIndex 层索引
	         * @param stateIndex 状态索引
	         * @param clip 动画资源
	         * @param frameIndex 播放的帧数
	         * @param weight 权重
	         * @param additiveClip 叠加参考动画
	         * @param additiveFrameIndex 叠加参考动画播放的帧数
	         */
	        setStateBlendInfo(layerIndex: number, stateIndex: number, clip: AnimationClip, frameIndex: number, weight: number, additiveClip?: AnimationClip, additiveFrameIndex?: number): void;
	        /**
	         * 重置状态的动画权重。
	         * @param layerIndex 层索引
	         * @param stateIndex 状态索引
	         */
	        resetStateBlendInfo(layerIndex: number, stateIndex: number): void;
	        /**
	         * 恢复骨骼默认姿态。
	         */
	        writeDefaults(): void;
	        /**
	         * 提交动画任务到客户端。
	         */
	        commit(): void;
	        /**
	         * 撤销提交动画任务。
	         */
	        uncommit(): void;
	        /**
	         * 重新绑定动画资源。
	         * @param description
	         * @param avatarBinding
	         * @param options
	         */
	        rebind(description: IAnimationCoreDescription, avatarBinding: IAnimationAvatarBinding, options?: IAnimationCoreRebindOption): void;
	        rebind(controller: Nullable<AnimatorController>, avatarBinding: IAnimationAvatarBinding, options?: IAnimationCoreRebindOption): void;
	        /**
	         * 析构对象，清除不必要的内存。
	         */
	        dispose(): void;
	    }
	    export interface IAnimationCoreDescription {
	        animationClips: ArrayLike<AnimationClip>;
	        animationClipCount: number;
	        layers: Array<{
	            states: number[];
	        }>;
	    }
	    export const CreateAnimationCore: typeof Internal.AnimationCore.CreateAnimationCore;
	    export type DynamicRemapping = {
	        [path: string]: Nullable<Transform3D>;
	    };
	    export type StaticRemapping = {
	        [path: string]: {
	            modelPath: string | "=" | "-";
	            bindingTransform: Nullable<Transform3D>;
	        };
	    };
	    export type Remapping = DynamicRemapping | StaticRemapping;
	    export const CreateAnimationCore2D: typeof Internal.AnimationCore.CreateAnimationCore2D;
	    export {};
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skinnedMeshRenderer' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { EnumRendererType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/materials/buildinShaderDesc';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Skeleton from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skeleton';
	/**
	 * 蒙皮模型渲染组件。
	 */
	export default class SkinnedMeshRenderer extends MeshRenderer {
	    static IS(value: any): value is SkinnedMeshRenderer;
	    isSkinnedMeshRenderer: boolean;
	    set skeleton(skeleton: Nullable<Skeleton>);
	    /**
	     * 骨架。
	     */
	    get skeleton(): Nullable<Skeleton>;
	    /**
	     * 创建一个SkinnedMeshRenderer，请用`entity.AddComponent`！
	     */
	    constructor(entity: Entity3D);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lineRenderer' {
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { GradientColor } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext'; enum ELineAlignment {
	    /** 一直面向相机。 */
	    View = 0,
	    /** 不随相机移动而变化。 */
	    Local = 1
	} class LineRenderer extends MeshRenderer {
	    /**
	     * 线上所有点的位置列表。
	     *
	     * @type {Vector3[]}
	     * @memberof LineRenderer
	     */
	    get positions(): Vector3[];
	    set positions(p: Vector3[]);
	    /**
	     * 起始宽度。
	     * @type {number}
	     * @memberof LineRenderer
	     */
	    get startWidth(): number;
	    set startWidth(val: number);
	    /**
	     * 终止宽度。
	     * @type {number}
	     * @memberof LineRenderer
	     */
	    get endWidth(): number;
	    set endWidth(val: number);
	    /**
	     * 如果没有gColor时，决定起始颜色。
	     * @type {Color}
	     * @memberof LineRenderer
	     */
	    get startColor(): Color;
	    set startColor(val: Color);
	    /**
	     * 如果没有gColor时，决定终止颜色。
	     * @type {Color}
	     * @memberof LineRenderer
	     */
	    get endColor(): Color;
	    set endColor(val: Color);
	    /**
	     * 对齐方式。
	     * @type {LineRenderer.LineAlignment}
	     * @memberof LineRenderer
	     */
	    get alignment(): ELineAlignment;
	    set alignment(val: ELineAlignment);
	    /**
	     * positions是否是世界坐标中的位置。
	     * @type {boolean}
	     * @memberof LineRenderer
	     */
	    get useWorldSpace(): boolean;
	    set useWorldSpace(val: boolean);
	    /**
	     * 渐变色。
	     * @type {GradientColor}
	     * @memberof LineRenderer
	     */
	    get gColor(): Nullable<GradientColor>;
	    set gColor(val: Nullable<GradientColor>);
	    set posCount(val: number);
	    /**
	     * 获取第index个顶点的位置
	     *
	     * @param {*} index
	     * @returns {Vector3}
	     * @memberof LineRenderer
	     */
	    getPosition(index: any): Vector3;
	    /**
	     * 设置第index个顶点的位置。
	     *
	     * @param {number} index
	     * @param {Vector3} position
	     * @returns {boolean}
	     * @memberof LineRenderer
	     */
	    setPosition(index: number, position: Vector3): boolean;
	    /**
	     * 获取颜色percent位置的颜色。
	     *
	     * @param {*} percent 取值范围0-1
	     * @param {Color} [dst]
	     * @returns {Color}
	     * @memberof LineRenderer
	     */
	    getColor(percent: any, dst?: Color): Color;
	} namespace LineRenderer {
	    /** 线段渲染器的对齐方式。 */
	    export import LineAlignment = ELineAlignment;
	}
	export default LineRenderer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/trailRenderer' {
	import { EnumRendererType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/materials/buildinShaderDesc';
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import { GradientColor, HermiteCurve } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/advancedProperty';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext'; enum ETrailAlignment {
	    /** 一直面向相机。 */
	    View = 0,
	    /** 不随相机移动而变化。 */
	    Local = 1
	} enum ETrailTextureMode {
	    /**  */
	    Stretch = 0,
	    Tile = 1
	} class TrailRenderer extends MeshRenderer {
	    set startWidth(val: number);
	    set endWidth(val: number);
	    /**
	     * 尾迹持续的时间。
	     * @type {number}
	     * @memberof TrailRenderer
	     */
	    get time(): number;
	    set time(val: number);
	    /**
	     * 宽度变化曲线。
	     * @type {HermiteCurve}
	     * @memberof TrailRenderer
	     */
	    get widthCurve(): HermiteCurve;
	    set widthCurve(val: HermiteCurve);
	    /**
	     * 宽度系数。
	     * @type {number}
	     * @memberof TrailRenderer
	     */
	    get widthMultiplier(): number;
	    set widthMultiplier(val: number);
	    set startColor(val: Color);
	    set endColor(val: Color);
	    /**
	     * 渐变色。
	     * @type {GradientColor}
	     * @memberof TrailRenderer
	     */
	    get gColor(): GradientColor;
	    set gColor(val: GradientColor);
	    /**
	     * 尾迹中一个面片的最小长度。
	     * @type {number}
	     * @memberof TrailRenderer
	     */
	    get minVertexDistance(): number;
	    set minVertexDistance(val: number);
	    /**
	     * 尾迹对齐方式。
	     * @type {TrailRenderer.TrailAlignment}
	     * @memberof TrailRenderer
	     */
	    get alignment(): ETrailAlignment;
	    set alignment(val: ETrailAlignment);
	    /**
	     * 贴图模式。
	     * @type {TrailRenderer.TrailTextureMode}
	     * @memberof TrailRenderer
	     */
	    get textureMode(): ETrailTextureMode;
	    set textureMode(val: ETrailTextureMode);
	} namespace TrailRenderer {
	    /** 尾迹渲染器的对齐方式。 */
	    export import TrailAlignment = ETrailAlignment;
	    /** 尾迹渲染器贴图的渲染方式。 */
	    export import TrailTextureMode = ETrailTextureMode;
	}
	export default TrailRenderer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIGraphic' {
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D'; enum Shape {
	    Rect = 0,
	    Circle = 1
	}
	export default class UIGraphic extends Renderable2D {
	    static Shape: typeof Shape;
	    /**
	     * UIGraphic的图像类型
	     *
	     * @type {GraphicShape}
	     * @memberof UIGraphic
	     */
	    get shape(): Shape;
	    set shape(val: Shape);
	    /**
	     * 半径，仅Circle模式下有效
	     *
	     * @type {number}
	     * @memberof UIGraphic
	     */
	    get radius(): number;
	    set radius(val: number);
	    /**
	     * 圆的角度，仅Circle模式下有效
	     *
	     * @type {number}
	     * @memberof UIGraphic
	     */
	    get angle(): number;
	    set angle(val: number);
	    /**
	     * 圆的分段数，仅Circle模式下有效
	     *
	     * @type {number}
	     * @memberof UIGraphic
	     */
	    get section(): number;
	    set section(val: number);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/MetaAnimation' {
	import { Entity3D, Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { IMetaAssetInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	export class HermiteCurve {
	    readonly fbuffer: Float32Array;
	    readonly ubuffer: Uint32Array;
	    readonly startOffset: number;
	    readonly frameCount: number;
	    fps: number;
	    frameLength: number;
	    constructor(fbuffer: Float32Array, ubuffer: Uint32Array, startOffset: number, frameCount: number, fps: number, frameLength: number);
	    evaluate(index: number): number;
	} class AssetCurve {
	    readonly metaAssetInfo: IMetaAssetInfo;
	    constructor(metaAssetInfo: IMetaAssetInfo);
	    evaluate(frameIndex: number): Nullable<BaseResource>;
	}
	export class MetaAnimationClipModel {
	    readonly clip: AnimationClip;
	    get curveCount(): number;
	    constructor(ab: Nullable<ArrayBuffer>, clip: AnimationClip, fps: number);
	    evaluate(frameIndex: number, binding: Array<string | null>, out: {
	        [key: string]: number | Nullable<BaseResource>;
	    }): void;
	}
	interface ISyncFunction {
	    symbol: string;
	    entity: Entity3D | Entity2D;
	    get: () => number;
	    set: (val: number | Nullable<BaseResource>) => void;
	}
	export function createSyncFunction(transform: Transform2D | Transform3D, property: string): ISyncFunction;
	export enum UseDefaultAddedAction {
	    Ignore = 0,
	    Refresh = 1
	}
	export enum UseDefaultRetainedAction {
	    Keep = 0,
	    Refresh = 1,
	    WriteBack = 2
	}
	export enum UseDefaultRemovedAction {
	    Keep = 0,
	    Clear = 1,
	    WriteBack = 2
	}
	export class MetaAnimationClipBinding {
	    clipBindingMap: Map<MetaAnimationClipModel, Array<string | null>>;
	    channelSyncFunctionMap: Map<string, ISyncFunction>;
	    defaultValues: Map<string, number | Nullable<BaseResource>>;
	    constructor(clipArray: MetaAnimationClipModel[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<Transform3D | Transform2D | null>, channelArrayOffset: number, channelArrayLength: number, useDefaultAddedNodesAction: UseDefaultAddedAction);
	    rebind(clipArray: MetaAnimationClipModel[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<Transform3D | Transform2D | null>, channelArrayOffset: number, channelArrayLength: number, removeAction: number, retainedAction: number, addedAction: UseDefaultAddedAction): boolean;
	    update(clipArray: MetaAnimationClipModel[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<Transform3D | Transform2D | null>, channelArrayOffset: number, channelArrayLength: number, removeAction: number, retainedAction: number, addedAction: UseDefaultAddedAction): boolean;
	    writeDefaultValues(): void;
	}
	export function createMetaAnimationClipBinding(clipArray: MetaAnimationClipModel[], clipArrayOffset: number, clipArrayLength: number, entityArray: Array<Transform3D | Transform2D | null>, channelArrayOffset: number, channelArrayLength: number, useDefaultAddedNodesAction: UseDefaultAddedAction): MetaAnimationClipBinding;
	interface IMetaAnimatorContorllerStateInfo {
	    clip: null | MetaAnimationClipModel;
	    frameIndex: number;
	    weight: number;
	    addtiveClip: null | MetaAnimationClipModel;
	    additiveFrameIndex: number;
	}
	export class MetaAnimatorControllerStateModel {
	    readonly count: number;
	    nextState: MetaAnimatorControllerStateModel | null;
	    weight: number;
	    useDefault: number;
	    info: IMetaAnimatorContorllerStateInfo[];
	    constructor(count: number);
	    resetBlendInfo(): void;
	    setNextState(state: MetaAnimatorControllerStateModel | null): void;
	    setBlendInfo(clip: MetaAnimationClipModel, frameIndex: number, blendWeight: number, additiveReferenceClip: null | MetaAnimationClipModel, additiveFrameIndex: number): boolean;
	}
	export function createMetaAnimatorControllerStateModel(count: number): MetaAnimatorControllerStateModel;
	export enum BlendType {
	    Override = 0,
	    Additive = 1
	}
	interface IMetaLayerInfo {
	    blendType: BlendType;
	    weight: number;
	    blend: null | MetaAnimatorControllerStateModel;
	    mask: null | Array<{
	        entity: Entity3D;
	        weight: number;
	    }>;
	}
	export class MetaAnimatorControllerModel {
	    readonly layerCount: number;
	    readonly infos: IMetaLayerInfo[];
	    binding: null | MetaAnimationClipBinding;
	    constructor(layerCount: number);
	    setAnimationClipBinding(binding: null | MetaAnimationClipBinding): void;
	    setLayerBlendType(layerIndex: number, blendType: BlendType): void;
	    setLayerWeight(layerIndex: number, weight: number): void;
	    setLayerBlend(layerIndex: number, blend: null | MetaAnimatorControllerStateModel): void;
	    setLayerMask(layerIndex: number, mask: Nullable<Array<{
	        entity: Entity3D;
	        weight: number;
	    }>>): void;
	}
	export function createAnimatorController(layerCount: number): MetaAnimatorControllerModel;
	export function updateMetaAnimatorController(this: void, controller: MetaAnimatorControllerModel): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/animation' {
	import { MetaAnimatorControllerModel } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/MetaAnimation';
	import Game, { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array'; type TransformBase = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase').default; type Transform3D = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D').default;
	/**
	 * @export
	 *
	 * @category Animation
	 * @category System
	 */
	export default class AnimationSystem implements IGameSystem {
	    readonly game: Game;
	    constructor(game: Game);
	    markAnimationAvatarDirty(comps: {
	        [path: string]: Transform3D;
	    }): void;
	    markAnimatorControllerNodesNeedDirty(comps: Transform3D[]): void;
	    markAnimatorControllerNeedUpdate(comp: Kanata.AnimatorControllerModel): void;
	    markMetaAnimatorControllerNeedUpdate(comp: MetaAnimatorControllerModel): void;
	    cancelAnimatorControllerUpdate(comp: Kanata.AnimatorControllerModel): void;
	    cancelMetaAnimatorControllerUpdate(comp: MetaAnimatorControllerModel): void;
	    markSkinningMatrixNeedUpdate(comp: Kanata.SkinnedSkeletonComponent): void;
	    bindBone(transform: TransformBase, entity: Kanata.Entity3D): void;
	    unbindBone(transform: TransformBase): void;
	    updateAnimatorControllers(): void;
	    updateSkinningMatrices(): void;
	    dispose(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/node' {
	import { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; type Component = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/component').default; type Entity = import('!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity').default; enum ComponentState {
	    Entry = 0,
	    ToActivate = 1,
	    Activating = 2,
	    Activated = 3,
	    ToEnable = 4,
	    Enabling = 5,
	    Enabled = 6,
	    ToStart = 7,
	    Starting = 8,
	    Started = 9,
	    Update = 10,
	    ToDeactivate = 11,
	    Deactivating = 12,
	    Deactivated = 13,
	    StateCount = 14
	} class PriorityArrayBase<T extends object> {
	    constructor(getPriorityFunc: (item: T) => number);
	    add(item: T): void;
	    remove(item: T): void;
	    has(item: T): boolean;
	    forEach(fn: (item: T) => void): void;
	    clear(): void;
	}
	export class PriorityArray<T extends object> {
	    constructor(getPriorityFunc: (item: T) => number);
	    has(item: T): boolean;
	    add(item: T): void;
	    remove(item: T): void;
	    forEach(fn: (item: T) => void, once?: boolean, cycle?: boolean): void;
	    reset(): void;
	} enum ComponentAction {
	    Activate = 0,
	    Deactivate = 1,
	    Enable = 2,
	    Disable = 3
	} class InvokeComponentPersist<T extends Component> extends PriorityArray<T> {
	    invokeFunc: (comp: T, dt: number) => void;
	    constructor(invokeFunc: (comp: T, dt: number) => void);
	    invoke(dt: number): void;
	} class InvokeComponentOnce<T extends Component> extends PriorityArray<T> {
	    invokeFunc: (comp: T) => void;
	    constructor(invokeFunc: (comp: T) => void);
	    invoke(cycle?: boolean): void;
	}
	interface IAllocator<T> {
	    alloc(): T;
	    free(t: T): void;
	} class DeactivateInvokerAllocatorImpl implements IAllocator<InvokeComponentOnce<Component>> {
	    readonly componentSystem: ComponentSystem;
	    constructor(componentSystem: ComponentSystem);
	    alloc(): InvokeComponentOnce<Component>;
	    free(t: InvokeComponentOnce<Component>): void;
	} class RemoveInvokerAllocatorImpl implements IAllocator<InvokeComponentOnce<TransformBase>> {
	    alloc(): InvokeComponentOnce<TransformBase>;
	    free(t: InvokeComponentOnce<TransformBase>): void;
	} class ComponentSystem {
	    activatingEntity: Nullable<Entity>;
	    latePreRemoveTasks: SmartArray<() => void>;
	    activateInvoker: InvokeComponentOnce<Component>;
	    deactivateInvokerAllocator: DeactivateInvokerAllocatorImpl;
	    removeInvokerAllocator: RemoveInvokerAllocatorImpl;
	    deactivateInvokerStack: SmartArray<InvokeComponentOnce<Component>>;
	    removeInvokerStack: SmartArray<InvokeComponentOnce<TransformBase>>;
	    deactivateInvoker: InvokeComponentOnce<Component>;
	    removeInvoker: InvokeComponentOnce<TransformBase>;
	    createDeactivateScope(): void;
	    destroyDeactivateScope(): void;
	    componentStateMap: WeakMap<Component, number>;
	    getState(comp: Component): ComponentState;
	    setState(comp: Component, newState: ComponentState): void;
	    getActive(comp: Component): boolean;
	    setActive(comp: Component, active: boolean): void;
	    preUpdate(dt: number): void;
	    update(dt: number): void;
	    lateUpdate(dt: number): void;
	    onActiveInHierarchyChange(comp: Component): void;
	    activate(comp: Component): void;
	    deactivate(comp: Component): void;
	} enum EntityState {
	    Entry = 0,
	    Activated = 1,
	    Deactivated = 2,
	    StateCount = 3
	} enum EntityAction {
	    Activate = 0,
	    Deactivate = 1,
	    Enable = 2,
	    Disable = 3
	}
	export default class NodeSystem implements IGameSystem {
	    entityStateMap: WeakMap<Entity, EntityState>;
	    componentSystem: ComponentSystem;
	    onComponentActiveInHierarchyChange(component: Component): void;
	    activateComponent(component: Component): void;
	    deactivateComponent(component: Component): void;
	    onActiveInHierarchyChange(entity: Entity): void;
	    deactivateImmediate(entity: Entity): void;
	    preUpdate(deltaTime: number): void;
	    update(deltaTime: number): void;
	    lateUpdate(deltaTime: number): void;
	    dispose(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/LODGroup' {
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	export interface ILodConfig {
	    screenRelativeTransitionHeight: number;
	    fadeTransitionWidth: number;
	    renderers: MeshRenderer[];
	}
	export interface ILod {
	    id: number;
	    radius: number;
	    lodList: ILodConfig[];
	    entity: Entity3D;
	    renderer: MeshRenderer | null;
	}
	export interface ICenter {
	    x: number;
	    y: number;
	    z: number;
	}
	export default class LODGroup extends Component {
	    readonly entity: Entity3D;
	    get radius(): number;
	    set radius(val: number);
	    get lodCount(): number;
	    set lodCount(val: number);
	    get lodList(): ILodConfig[];
	    set lodList(val: ILodConfig[]);
	    get center(): ICenter;
	    set center(val: ICenter);
	    get renderer(): MeshRenderer | null;
	    set renderer(val: MeshRenderer | null);
	    onDeserialized(data: any, context: {
	        [key: string]: any[];
	    }, builtContext: {
	        [key: string]: SmartArray<any>;
	    }): void;
	    constructor(entity: Entity3D);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera' {
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4';
	import DirectionalLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/directionalLight';
	/**
	 * 3D场景相机。
	 */
	export default class Camera extends BaseCamera {
	    readonly entity: Entity3D;
	    /**
	     * 阴影模式。
	     */
	    static readonly ShadowMode: Readonly<typeof Kanata.EShadowMode>;
	    /**
	     * 阴影适配模式
	     */
	    static readonly ShadowFitMode: Readonly<typeof Kanata.EShadowFitMode>;
	    /**
	     * 阴影渲染模式
	     */
	    get shadowMode(): Kanata.EShadowMode;
	    set shadowMode(val: Kanata.EShadowMode);
	    /**
	     * Cascaded splits。
	     */
	    get cascadedSplits(): Vector3;
	    set cascadedSplits(val: Vector3);
	    /**
	     * 阴影适配模式。
	     */
	    get shadowFitMode(): Kanata.EShadowFitMode;
	    set shadowFitMode(val: Kanata.EShadowFitMode);
	    /**
	     * 阴影距离。
	     */
	    get shadowDistance(): number;
	    set shadowDistance(val: number);
	    /**
	     * 是否开启HDR。
	     */
	    get hdr(): boolean;
	    set hdr(val: boolean);
	    /**
	     * 相机的跟拍目标。
	     * 该属性有值时，相机为跟拍模式，相机的rotation会被自动更新。
	     * 该属性设置为null时，相机为自由旋转模式。
	     */
	    get targetTransform(): Nullable<Transform3D>;
	    set targetTransform(val: Nullable<Transform3D>);
	    /**
	     * 是否绘制天空盒。
	     */
	    get drawSkybox(): boolean;
	    set drawSkybox(val: boolean);
	    /**
	     * 是否绘制Gizmo
	     *
	     * @type {boolean}
	     * @memberof Camera
	     */
	    get drawGizmo(): boolean;
	    set drawGizmo(val: boolean);
	    /**
	     * 请使用entity.addComponent(engine.Camera)来创建。
	     */
	    constructor(entity: Entity3D);
	    /**
	     * 通过一个平行光绘制阴影。
	     *
	     * @param light 要绘制阴影的平行光。
	     * @param renderList 绘制列表。
	     * @param lightMode 光照类型。
	     */
	    drawLight(light: DirectionalLight, renderList: Kanata.ScalableList, lightMode: string): void;
	    /**
	     * 修改viewMatrix的设置类型。
	     *
	     * @param manual 是否要设置为手动模式。
	     * @param mat4 手动模式下，要设置的值。
	     */
	    changeViewMatrix(manual: boolean, mat4?: Matrix4): void;
	    /**
	     * 修改projectMatrix的设置类型。
	     *
	     * @param manual 是否要设置为手动模式。
	     * @param mat4 手动模式下，要设置的值。
	     */
	    changeProjectMatrix(manual: boolean, mat4?: Matrix4): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/core' {
	/**
	 * basic.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 5/24/2021, 3:05:12 PM
	*/
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import RGNode, { ERGNodeType, IRGData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode';
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera';
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	import Screen from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen'; type RenderSystem = import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	/**
	 * 相机节点，将一个相机变成节点的输出。
	 *
	 * @category Render
	 */
	export class RGCameraNode extends RGNode<{}, 'Camera', {
	    camera: BaseCamera;
	}> {
	    type: ERGNodeType;
	    inputTypes: {
	        camera: "Camera";
	    };
	    outputType: 'Camera';
	    onInit(options: {
	        camera: BaseCamera;
	    }): void;
	}
	/**
	 * 剔除节点，接入一个相机，输出剔除结果列表。
	 *
	 * @category Render
	 */
	export class RGCullNode extends RGNode<{
	    camera: 'Camera';
	}, 'MeshList', {
	    /**
	     * 剔除使用的lightMode。
	     */
	    lightMode: string;
	    /**
	     * 输出剔除列表的初始化大小。
	     * @default 1024
	     */
	    initSize?: number;
	}> {
	    type: ERGNodeType;
	    inputTypes: {
	        camera: "Camera";
	    };
	    outputType: 'MeshList';
	    onActive(): void;
	    onExecute(context: RenderSystem, options: {
	        lightMode: string;
	    }): void;
	    onDisable(): void;
	}
	/**
	 * 生成RenderTarget节点。
	 *
	 * @category Render
	 */
	export class RGGenRenderTargetNode extends RGNode<{}, 'RenderTarget', {
	    /**
	     * 用于创建输出渲染目标的方法。
	     */
	    createRenderTarget(): RenderTexture | Screen;
	}> {
	    type: ERGNodeType;
	    inputTypes: {};
	    outputType: 'RenderTarget';
	    onActive(context: RenderSystem, options: {
	        createRenderTarget(): RenderTexture | Screen;
	    }): void;
	    onDisable(): void;
	}
	/**
	 * 用于输出一个类Camera对象的View节点，可用于连接`RGClearNode`。
	 *
	 * @category Render
	 */
	export class RGGenViewNode extends RGNode<{}, 'Camera', {
	    viewObject: {
	        view: Kanata.View;
	    };
	}> {
	    type: ERGNodeType;
	    inputTypes: {};
	    outputType: 'Camera';
	    onActive(context: RenderSystem, options: {
	        viewObject: {
	            view: Kanata.View;
	        };
	    }): void;
	    onDisable(): void;
	}
	/**
	 * 用于清屏的节点。
	 *
	 * @category Render
	 */
	export class RGClearNode extends RGNode<{
	    camera: 'Camera';
	    renderTarget: 'RenderTarget';
	}, 'None', {}> {
	    type: ERGNodeType;
	    inputTypes: {
	        camera: "Camera";
	        renderTarget: "RenderTarget";
	    };
	    outputType: 'None';
	    onExecute(context: RenderSystem, options: {
	        lightMode: string;
	    }): void;
	}
	/**
	 * 渲染节点的创建参数。
	 *
	 * @category Render
	 */
	export interface IRGRenderNodeOptions<TInputs> {
	    /**
	     * 用于渲染的全局UniformBlock数组。
	     * 目前暂时只支持一个!
	     */
	    createUniformBlocks(): Kanata.UniformBlock[];
	    /**
	     * 用于渲染的lightMode。
	     */
	    lightMode: string;
	    /**
	     * 要追加的输入参数类型。
	     */
	    inputTypes?: TInputs;
	    /**
	     * 输入和全局UniformBlock中key的映射关系。
	     */
	    uniformsMap?: {
	        [uniformName: string]: {
	            inputKey: keyof TInputs;
	            /**
	             * 如果uniform是`RenderTexture`，使用哪个缓冲。
	             */
	            name: 'depth' | 'stencil' | 'color';
	            /**
	             * 如果的是`RenderTexture`并且是`color`缓冲，选择哪一个。
	             * 目前只能是0！
	             */
	            index?: number;
	        };
	    };
	}
	/**
	 * 渲染节点。
	 *
	 * @category Render
	 */
	export class RGRenderNode<TInputs extends {
	    [key: string]: keyof IRGData;
	} = {}> extends RGNode<TInputs & {
	    camera: 'Camera';
	    renderTarget: 'RenderTarget';
	    meshList: 'MeshList';
	    lightList: "LightList";
	}, 'RenderTarget', IRGRenderNodeOptions<TInputs>> {
	    type: ERGNodeType;
	    inputTypes: any;
	    outputType: 'RenderTarget';
	    onInit(options: IRGRenderNodeOptions<TInputs>): void;
	    onActive(context: RenderSystem, options: IRGRenderNodeOptions<TInputs>): void;
	    onExecute(context: RenderSystem, options: IRGRenderNodeOptions<TInputs>): void;
	    /**
	     * 渲染回调，如果要继承可以重写此方法。
	     */
	    onRender(context: RenderSystem, options: IRGRenderNodeOptions<TInputs>): void;
	    onDisable(): void;
	}
	/**
	 * 用于渲染阴影的节点。
	 *
	 * @category Render
	 */
	export class RGLightNode extends RGRenderNode {
	    onRender(context: RenderSystem, options: IRGRenderNodeOptions<{}>): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/subGraph' {
	import RGNode, { ERGNodeType, IRGData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode';
	import RenderGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph';
	/**
	 * 子图节点的配置。
	 *
	 * @category Render
	 */
	export interface IRGSubGraphNodeOptions<IOptions = any> {
	    /**
	     * 子图的类。
	     */
	    RGClass: new (name: string, options: IOptions) => RenderGraph<IOptions>;
	    /**
	     * 传给子图的配置。
	     */
	    options?: IOptions;
	}
	/**
	 * 剔除节点，接入一个相机，输出剔除结果列表。
	 *
	 * @category Render
	 */
	export class RGSubGraphNode<TInputs extends {
	    [key: string]: keyof IRGData;
	}, TOutput extends keyof IRGData, IOptions = any> extends RGNode<TInputs, TOutput, IRGSubGraphNodeOptions<IOptions>> {
	    type: ERGNodeType;
	    inputTypes: TInputs;
	    outputType: TOutput;
	    showDebugInfo(): string;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/forwardAdd' {
	import RGNode, { ERGNodeType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode';
	import { RGRenderNode, IRGRenderNodeOptions } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/core'; type RenderSystem = import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	/**
	 * ForwardAdd流程的Mesh剔除节点。
	 *
	 * @category Render
	 */
	export class RGCullMeshFANode extends RGNode<{
	    camera: "Camera";
	    meshList: "MeshList";
	}, "MeshList", {}> {
	    type: ERGNodeType;
	    inputTypes: {
	        camera: "Camera";
	        meshList: "MeshList";
	    };
	    outputType: "MeshList";
	    onActive(): void;
	    onExecute(context: RenderSystem, options: {}): void;
	    onDisable(): void;
	} type TRGFARenderNodeInputs = {
	    lightList: 'LightList';
	};
	/**
	 * ForwardAdd流程的渲染节点。
	 *
	 * @category Render
	 */
	export class RGFARenderNode extends RGRenderNode<TRGFARenderNodeInputs> {
	    onExecute(context: RenderSystem, options: IRGRenderNodeOptions<TRGFARenderNodeInputs>): void;
	    onRender(context: RenderSystem, options: IRGRenderNodeOptions<TRGFARenderNodeInputs>): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4'; type Camera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera').default;
	export abstract class BaseGizmo {
	    addRenderCamera(camera: Camera): void;
	    deleRenderCamera(camera: Camera): void;
	    clearRenderCameraSet(): void;
	    shouldRenderInCamera(camera: Camera): boolean;
	    setTintColor(r?: number, g?: number, b?: number, a?: number): void;
	    get meshRenderer(): Kanata.MeshRendererComponent;
	    constructor();
	    update(camera: Camera): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/gizmosPool' {
	import { BaseGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo';
	export class BaseGizmosPool {
	    constructor();
	    push(gizmo: BaseGizmo): void;
	    remove(gizmo: BaseGizmo): void;
	    pop(): BaseGizmo;
	    get extractable(): boolean;
	}
	export class GizmosPool {
	    static lineGizmosPool: BaseGizmosPool;
	    static cubeGizmosPool: BaseGizmosPool;
	    static rectGizmosPool: BaseGizmosPool;
	    static circleGizmosPool: BaseGizmosPool;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/materials/shaders/unlit/unlit.vertex' {
	 const _default: "\n#version 100\nprecision highp float;\nattribute vec3 a_position;\nuniform mat4 u_view;\nuniform mat4 u_worldMat;\nuniform mat4 u_projection;\n\nvoid main(void) {\n    vec4 modelPosition = u_worldMat * vec4(a_position, 1.0);\n    gl_Position = u_projection * u_view * modelPosition;\n}";
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/materials/shaders/unlit/unlit.pixel' {
	 const _default: "\n#version 100\nprecision highp float;\nuniform vec4 u_color;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n}";
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/materials/shaders/lit/lit.pixel' {
	 const _default: "\n#version 100\nprecision highp float;\nuniform vec4 u_color;\nvarying vec3 v_normal;\nuniform vec3 u_lightDir;\n\nvoid main(void) {\n    vec3 nrmN = normalize(v_normal);\n    vec3 nrmL = -normalize(u_lightDir);\n    float result = max(0.5, dot(nrmN, nrmL));\n    gl_FragColor = vec4((u_color * result).rgb, 1.0);\n    \n}";
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/materials/shaders/lit/lit.vertex' {
	 const _default: "\n#version 100\nprecision highp float;\nuniform mat4 u_projection;\nuniform mat4 u_view;\nuniform mat4 u_worldMat;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nvarying vec3 v_normal;\n\nuniform vec3 u_worldCameraPosition;\nuniform mat4 u_normal;\n\nvoid main(void) {\n    vec3 objectNormal = a_normal;\n    v_normal = mat3(u_normal) * objectNormal;\n    vec4 modelPosition = vec4(a_position, 1.0);\n    gl_Position = u_projection * u_view * u_worldMat * modelPosition;\n}";
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/materials/gizmoMaterials' {
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	export class GizmoMaterials {
	    static createEffect(name: string, vs: string, ps: string, primitiveType: Kanata.EPrimitiveType): Effect;
	    static get LineMaterial(): Material;
	    static get CircleMaterial(): Material;
	    static get RectMaterial(): Material;
	    static get CubeMaterial(): Material;
	    static get MeshMaterial(): Material;
	    static get UnlitMeshMaterial(): Material;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/lineGizmo' {
	import { BaseGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3'; type Camera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera').default;
	export class LineGizmo extends BaseGizmo {
	    get start(): V3ReadOnly;
	    set start(val: V3ReadOnly);
	    get end(): V3ReadOnly;
	    set end(val: V3ReadOnly);
	    set WorldMatrix(matrix: Matrix4);
	    get WorldMatrix(): Matrix4;
	    resetGizmo(start: V3ReadOnly, end: V3ReadOnly): void;
	    constructor(start: V3ReadOnly, end: V3ReadOnly);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/circleGizmo' {
	import { BaseGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3'; type Camera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera').default;
	export class CircleGizmo extends BaseGizmo {
	    get center(): V3ReadOnly;
	    set center(val: V3ReadOnly);
	    get radius(): number;
	    set radius(val: number);
	    get radian(): number;
	    set radian(val: number);
	    get startRadian(): number;
	    set startRadian(val: number);
	    setPrimitiveInfo(center?: V3ReadOnly, radius?: number, radian?: number, startRadian?: number): void;
	    set WorldMatrix(matrix: Matrix4);
	    get WorldMatrix(): Matrix4;
	    resetGizmo(center?: V3ReadOnly, radius?: number, radian?: number, startRadian?: number): void;
	    constructor(center?: V3ReadOnly, radius?: number, radian?: number, startRadian?: number);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/rectGizmo' {
	import { BaseGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4'; type Camera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera').default;
	export class RectGizmo extends BaseGizmo {
	    get x(): number;
	    set x(val: number);
	    get z(): number;
	    set z(val: number);
	    set WorldMatrix(matrix: Matrix4);
	    get WorldMatrix(): Matrix4;
	    resetGizmo(x?: number, z?: number): void;
	    constructor(x?: number, z?: number);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/cubeGizmo' {
	import { BaseGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types'; type Camera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera').default;
	export class CubeGizmo extends BaseGizmo {
	    get center(): V3ReadOnly;
	    set center(val: V3ReadOnly);
	    get size(): V3ReadOnly;
	    set size(val: V3ReadOnly);
	    set WorldMatrix(matrix: Matrix4);
	    get WorldMatrix(): Matrix4;
	    resetGizmo(center: V3ReadOnly, size: V3ReadOnly): void;
	    constructor(center: V3ReadOnly, size: V3ReadOnly);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/meshGizmo' {
	import { BaseGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import Mesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material'; type Camera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera').default;
	export class MeshGizmo extends BaseGizmo {
	    get center(): V3ReadOnly;
	    set center(val: V3ReadOnly);
	    get size(): V3ReadOnly;
	    set size(val: V3ReadOnly);
	    set WorldMatrix(matrix: Matrix4);
	    get WorldMatrix(): Matrix4;
	    resetGizmo(center: V3ReadOnly, size: V3ReadOnly): void;
	    setMaterial(material: Material): void;
	    constructor(center: V3ReadOnly, size: V3ReadOnly, mesh: Mesh);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/gizmos' {
	import { BaseGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/baseGizmo';
	import { LineGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/lineGizmo';
	import { CircleGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/circleGizmo';
	import { RectGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/rectGizmo';
	import { CubeGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/cubeGizmo';
	import { MeshGizmo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/meshGizmo';
	import { GizmoMaterials } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/materials/gizmoMaterials';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import Mesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh'; type Camera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera').default;
	export { LineGizmo, CircleGizmo, RectGizmo, CubeGizmo, MeshGizmo, GizmoMaterials };
	export class Gizmos {
	    static createCubeGizmo(center: V3ReadOnly, size: V3ReadOnly): CubeGizmo;
	    static createMeshGizmo(center: V3ReadOnly, scale: V3ReadOnly, mesh: Mesh): MeshGizmo;
	    static createLineGizmo(start: V3ReadOnly, end: V3ReadOnly): LineGizmo;
	    static createCircleGizmo(center?: V3ReadOnly, radius?: number, radian?: number, startRadian?: number): CircleGizmo;
	    static createRectGizmo(x?: number, z?: number): RectGizmo;
	    static removeGizmo(gizmo: BaseGizmo): void;
	    static clearAllGizmos(): void;
	    static update(camera: Camera, renderList: Kanata.ScalableList): void;
	    static IsEmpty(): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/gizmos' {
	import RGNode, { ERGNodeType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode'; type RenderSystem = import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	/**
	 * Gizmo数据的生成节点。
	 *
	 * @category Render
	 */
	export class RGGizmosNode extends RGNode<{
	    camera: "Camera";
	}, "MeshList", {}> {
	    type: ERGNodeType;
	    inputTypes: {
	        camera: "Camera";
	    };
	    outputType: "MeshList";
	    onActive(): void;
	    onExecute(context: RenderSystem): void;
	    onDisable(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/skybox' {
	/**
	 * skybox.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 5/24/2021, 3:05:47 PM
	*/
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import RGNode, { ERGNodeType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode'; type RenderSystem = import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	/**
	 * 用于天空盒的节点。
	 *
	 * @category Render
	 */
	export class RGSkyBoxNode extends RGNode<{}, 'MeshList', {}> {
	    type: ERGNodeType;
	    inputTypes: {};
	    outputType: 'MeshList';
	    onActive(): void;
	    onExecute(context: RenderSystem): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/ui' {
	/**
	 * ui.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 5/24/2021, 3:05:30 PM
	*/
	import RGNode, { ERGNodeType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode';
	import UICamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICamera'; type RenderSystem = import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	export interface IRGUIPrepareNodeOptions {
	    camera: UICamera;
	}
	export class RGUIPrepareNode extends RGNode<{}, 'MeshList', IRGUIPrepareNodeOptions> {
	    type: ERGNodeType;
	    inputTypes: {};
	    outputType: 'MeshList';
	    onActive(context: RenderSystem, options: IRGUIPrepareNodeOptions): void;
	    onExecute(context: RenderSystem, options: IRGUIPrepareNodeOptions): void;
	    onDisable(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes' {
	/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 5/24/2021, 3:04:16 PM
	*/
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/core';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/subGraph';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/forwardAdd';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/gizmos';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/skybox';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/ui';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/postProcessing';

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph' {
	import RGNode, { TRGNodeAny } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera'; type Game = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default; type RenderSystem = import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	interface IDigraphNode {
	    node: TRGNodeAny;
	    ins: number;
	    dist: number[];
	}
	/**
	 * 渲染图。
	 *
	 * @category Render
	 */
	export default class RenderGraph<IOptions = any> {
	    /**
	     * 图名字。
	     */
	    get name(): string;
	    /**
	     * 当前正在运行的Game实例。
	     */
	    get game(): import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default;
	    /**
	     * 当前的渲染上下文。
	     */
	    get context(): import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	    constructor(name: string,options: IOptions);
	    /**
	     * 创建一个节点。
	     */
	    createNode<TRGNode extends TRGNodeAny>(name: string, clz: new (...args: any) => TRGNode, options: TRGNode['options']): TRGNode;
	    /**
	     * 销毁一个节点。
	     */
	    destroyNode(rgNode: TRGNodeAny): void;
	    /**
	     * 连接两个节点。
	     *
	     * @param inputKey 需要将`from`节点的输出连接到哪个`to`节点的输入。
	     */
	    connect<TToNode extends TRGNodeAny>(from: TRGNodeAny, to: TToNode, inputKey?: keyof TToNode['inputTypes']): void;
	    /**
	     * 断开两个节点的连接。
	     */
	    disconnect(from: TRGNodeAny, to: TRGNodeAny): void;
	    /**
	     * 图在被第一次真正使用时的回调。
	     */
	    onActive(context: RenderSystem, options: IOptions): void;
	    /**
	     * 在渲染上下文中的相机改变时调用，一般用于重新构建图。
	     */
	    onCamerasChange(cameras: BaseCamera[], changeCameras: BaseCamera[]): void;
	    /**
	     * 在图每帧执行前调用。
	     */
	    onExecuteBegin(context: RenderSystem, options: IOptions): void;
	    /**
	     * 在图每帧执行后调用。
	     */
	    onExecuteDone(context: RenderSystem, options: IOptions): void;
	    /**
	     * 在图不再使用时调用。
	     */
	    onDisable(context: RenderSystem, options: IOptions): void;
	    showDebugInfo(callback?: (digraph: (IDigraphNode | undefined)[], sorted: TRGNodeAny[]) => void): string;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/shared' {
	/**
	 * shared.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 1/18/2021, 7:16:23 PM
	*/
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	export const ForwardBaseUniformBlockDesc: {
	    [lightMode: string]: Kanata.UniformDescriptor;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/ForwardBaseSubGraph' {
	/**
	 * ForwardBaseSubGraph.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/16/2021, 4:43:12 PM
	 */
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import RenderGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph';
	import Camera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera';
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	import Screen from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen';
	import RenderSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render';
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera';
	export interface IForwardBaseSubGraphOptions {
	    camera: BaseCamera;
	    fbUniforms: Kanata.UniformBlock;
	    faUniforms: Kanata.UniformBlock;
	    uiUniforms?: Kanata.UniformBlock;
	    scUniforms?: Kanata.UniformBlock;
	}
	/**
	 * 默认的内置前向渲染管线的子图，针对每个相机生成。
	 * 实际上包含了Forward Add部分。
	 *
	 * @category Render
	 */
	export default class ForwardBaseSubGraph extends RenderGraph<IForwardBaseSubGraphOptions> {
	    onActive(context: RenderSystem, options: IForwardBaseSubGraphOptions): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/ForwardBaseRG' {
	/**
	 * ForwardBaseRG.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 1/18/2021, 5:34:58 PM
	*/
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import RenderGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph';
	import RenderSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render';
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera';
	/**
	 * 默认的内置前向渲染管线。
	 * 实际上包含了Forward Add部分。
	 *
	 * @category Render
	 */
	export default class ForwardBaseRG extends RenderGraph {
	    onActive(context: RenderSystem): void;
	    onCamerasChange(cameras: BaseCamera[], changeCameras: BaseCamera[]): void;
	    onExecuteBegin(context: RenderSystem): void;
	    onExecuteDone(context: RenderSystem): void;
	    onDisable(context: RenderSystem): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render' {
	import { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import Screen from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen';
	import { Emitter, Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { RawTouchEvents } from '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/touch';
	import MeshRender from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import RenderGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph'; type Game = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default; type BaseCamera = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera').default;
	/**
	 * 渲染系统，用于管理整个引擎的渲染。
	 *
	 * @category Render
	 * @category System
	 */
	export default class RenderSystem implements IGameSystem {
	    readonly game: Game;
	    /**
	     * 主屏引用。
	     */
	    readonly screen: Screen;
	    /**
	     * 当前场景的渲染设置。
	     */
	    get setting(): import('!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene').Scene3DSettings;
	    /**
	     * 当前正在使用的RenderGraph。
	     */
	    get renderGraph(): RenderGraph<any> | undefined;
	    constructor(game: Game);
	    /**
	     * 通过一个特定的`CullResult`中的id获取`MeshRenderer`。
	     * 一般RenderGraph中自动处理。
	     */
	    getMeshById(id: number): MeshRender;
	    /**
	     * 使用某个RenderGraph，默认会使用内置的`ForwardBaseRG`。
	     */
	    useRenderGraph(rg: RenderGraph): void;
	    /**
	     * 开启全局GPU实例化。
	     */
	    enableInstance(): void;
	    /**
	     * 关闭全局GPU实例化。
	     */
	    disableInstance(): void;
	    dispose(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/layout' {
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	export default class LayoutSystem implements IGameSystem {
	    constructor();
	    dispose(): void;
	    addDirtyRectTransform(rectTransform: Transform2D): void;
	    updateRectLayout(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/FrameSystem' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	export enum FrameSystemMode {
	    IMMEDIATE = 0,
	    ORDINARY = 1
	}
	export class FrameSystem {
	    static init(startTime: any): void;
	    static runTaskByFrame(task: any): LitePromise<unknown>;
	    static update(frameStartTime: number): void;
	    static setPreferredFramesPerSecond(fps: number): void;
	    static TargetFrameTime(): number;
	    static setMode(mode: FrameSystemMode): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/adapter/Worker' {
	export default class MockWorker implements engineWX.Worker {
	    get died(): boolean;
	    constructor(path: string);
	    postMessage(message: any): void;
	    onMessage(callback: (message: any) => void): void;
	    terminate: () => void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/adapter/SharedArrayBuffer' {
	export default class MockSharedArrayBuffer implements engineWX.SharedArrayBuffer {
	    get _sabId(): number;
	    get buffer(): ArrayBuffer;
	    constructor(byteSize: number);
	    lock(callback: () => void): void;
	    unlock(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/adapter' {
	/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 6/10/2021, 3:20:41 PM
	*/
	export function createWorker(path: string): engineWX.Worker;
	export function createSharedArrayBuffer(byteSize: number): engineWX.SharedArrayBuffer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/syncPair' {
	export default class SyncPair {
	    constructor(sab?: any);
	    get sab(): [engineWX.SharedArrayBuffer, engineWX.SharedArrayBuffer];
	    get toggle(): number;
	    get(): engineWX.SharedArrayBuffer;
	    switch(): this;
	    lock(cb: () => void): void;
	    unlock(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/messenger' {
	/**
	 * @file 简易通信类
	 * @author shanexyzhou
	 */
	import EngineWorker from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/worker';
	export default class Messenger {
	    constructor(worker: EngineWorker);
	    once(callback: any, pred: any): void;
	    on(callback: any, pred: any): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/msgapi' {
	// 这里记录engine和worker通信的格式
	export namespace WorkerMessageAPI {

	  export interface BaseWorkerMsg {
	    type: string;

	    /**
	         * 引擎内的worker版本号
	         * 通过engine.workerVersion获取
	         */
	    version: string;
	  }

	  // 启动任务
	  export interface StartJob extends BaseWorkerMsg {
	    type: "startJob";

	    /**
	         * 用于同步的两个锁
	         */
	    sync: [engineWX.SharedArrayBuffer, engineWX.SharedArrayBuffer];

	    /**
	         * 用于同步状态的flag
	         * flag[0] sync位置(0-1)
	         * flag[1] 任务状态
	         * flag[1]=0 worker未执行任务
	         * flag[1]=1 job running
	         * flag[1]=2 engine主动停止任务
	         * flag[1]=3 invalid
	         */
	    flag: engineWX.SharedArrayBuffer;

	    /**
	         * 任务名, 在worker里注册
	         */
	    name: string;

	    /**
	         * 用于数据交换的object, 里面包含wx.SharedArrayBuffer
	         */
	    data: object;
	  }

	  export interface RequireAndStartJob extends BaseWorkerMsg {
	    type: "requireAndStartJob";

	    sync: [engineWX.SharedArrayBuffer, engineWX.SharedArrayBuffer];

	    flag: engineWX.SharedArrayBuffer;

	    /**
	         * require的文件路径
	         */
	    path: string;

	    data: object;
	  }

	  // RPC
	  export interface RPCSend extends BaseWorkerMsg {
	    type: "rpc";

	    /**
	         * flag[0] 过程状态
	         * flag[0] = 0 worker内未执行
	         * flag[1] = 1 worker内正在执行
	         * flag[1] = 2 worker内完成
	         */
	    flag: engineWX.SharedArrayBuffer;

	    /**
	         * 数据交互块
	         */
	    data: object;

	    /**
	         * 过程名
	         */
	    name: string;

	    /**
	         * 过程编号
	         */
	    taskId: number;
	  }
	}
}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/worker' {
	/**
	 * @file 代表一个worker资源
	 * @author shanexyzhou
	 */
	import SyncPair from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/syncPair';
	export type StatusEnum = "init" | "running" | "terminated" | "invalid";
	/**
	 * 一个Worker的实例对应一个原生的worker。
	 *
	 * 在工具内配置了worker文件夹后，由${name}自动创建。
	 *
	 * 对开发者来说，一般情况下无需关心这个类，只需要控制{@link WorkerJob | worker任务}即可。
	 * @see {@link WorkerJob} {@link WorkerSystem}
	 *
	 * @category Worker
	 */
	export default class EngineWorker {
	    /**
	     * worker的状态。
	     */
	    status: StatusEnum;
	    /**
	     * 强行终止worker。
	     * @param log 终止前是否检查worker运行状态。
	     */
	    terminate(log?: boolean): void;
	    /**
	     * 重新启动worker。
	     */
	    restart(): void;
	    isRunning(): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/job' {
	/**
	 * @file 代表game中的一个job
	 * @author shanexyzhou
	 */
	export type StatusEnum = "init" | "starting" | "running" | "suspended" | "destroying" | "destroyed" | "invalid";
	/**
	 * Worker任务。
	 *
	 * 通过调用{@link WorkerSystem.createJob}来创建，让开发者可以控制任务启动或者暂停。
	 *
	 * 创建任务后，任务不会自动运行，请手动调用一次{@link start}来启动任务。
	 *
	 * @category Worker
	 */
	export default class WorkerJob {
	    /**
	     * 用于与worker交互的数据块，在创建任务时传入。
	     */
	    get data(): object;
	    /**
	     * 开发者自己实现的任务类的路径，在创建任务时传入。
	     */
	    get jobPath(): string;
	    /**
	     * **任务状态**：
	     * + 新建任务后，任务不会立刻启动，状态为**init**；
	     * + `start()`了之后任务启动，状态变为**starting**；
	     * + worker环境内执行了一次任务之后，状态变为**running**(所以可以通过状态来判断worker有没有开始执行)；
	     * + `suspend()`了之后，状态变为**suspended**；
	     * + `resume()`了之后，状态变为**starting**；worker再执行一次之后变为**running**；
	     * + `dispose()`了之后，状态变为**destroying**；帧末进行真实销毁，状态变为**destroyed**。
	     */
	    get status(): StatusEnum;
	    /**
	     * 启动任务。
	     * @param workCallback 主线程内的任务回调，每帧末worker执行完任务后调用。
	     */
	    start(workCallback?: (job: WorkerJob) => void): void;
	    /**
	     * 暂停任务，会跳过每帧末的任务回调，worker内的任务也会暂停。
	     */
	    suspend(): void;
	    /**
	     * 重启（暂停中的）任务。
	     * 任务状态会回到`starting`。
	     */
	    resume(): void;
	    /**
	     * 销毁worker内的任务。
	     * 主线程内对应的任务回调也不会再执行。
	     */
	    dispose(): void;
	    /**
	     * 重新设置主线程内的任务回调。
	     *
	     * 如果在{@link start}前先调用这个方法设置了任务回调，那么`start()`即使不传入参数，也会继续沿用之前的任务回调。
	     *
	     * \**可以用这个方法来清空任务回调。*
	     */
	    setWorkCallback(workCallback?: (job: WorkerJob) => void): void;
	    /**
	     * 设置任务终止时的回调。
	     * @event
	     */
	    setOnEnd(endCallback: Function): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/rpc' {
	import EngineWorker from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/worker'; type StatusEnum = "init" | "starting" | "running" | "done" | "invalid";
	export default class WorkerRPC {
	    flagView: Uint8Array;
	    resolve?: Function;
	    get status(): StatusEnum;
	    constructor(worker: EngineWorker, funcName: string, data: object);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/module' {
	/**
	 * @file workerModule
	 * @author shanexyzhou
	 */
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/worker' {
	/**
	 * @file game中的workerSystem
	 * @author shanexyzhou
	 */
	import WorkerJob from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/job';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game'; type Game = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default;
	export enum Module {
	    LOGIC = 0,
	    WX_API = 1
	}
	/**
	 * Worker系统。
	 *
	 * 负责注册worker，调度任务等。
	 *
	 * 为开发者提供了创建worker任务的接口。
	 *
	 * @category Worker
	 * @category System
	 */
	export default class WorkerSystem implements IGameSystem {
	    /**
	     * @classdesc 保存game创建的所有job，并每帧末更新job
	     */
	    /** */
	    readonly game: Game;
	    /**
	     * 关闭后所有worker任务都会暂停，主线程内的任务回调也不执行。
	     */
	    active: boolean;
	    /**
	     * 每帧的帧末，在主线程等待worker `timeout` 毫秒后，worker会被自动终止，防止卡住游戏主循环。
	     *
	     * `timeout=0`表示无超时设置。
	     */
	    timeout: number;
	    dispose(): void;
	    /**
	     * 根据开发者自己实现的任务类的路径，来创建worker任务。
	     *
	     * 实现任务类的方法，详见[用户手册](todo)。
	     *
	     * @param jobPath 任务类的路径。
	     * @param data 自定义的共享数据块，用于和worker交换数据。
	     * @see {@link createSharedArrayBuffer}
	     */
	    createJob(jobPath: string, data: any): Nullable<WorkerJob>;
	    /**
	     * 创建主线程和worker之间的共享内存，用于交换数据。
	     *
	     * ```typescript
	     * const sab = game.workerSystem.createSharedArrayBuffer(256);
	     * const buffer = sab.buffer; // 通过sab.buffer来获取ArrayBuffer
	     * const view = new Float32Array(buffer);
	     * view[0] = 0.5;
	     * ```
	     */
	    createSharedArrayBuffer(byteSize: number): engineWX.SharedArrayBuffer;
	    /**
	     * 设置worker超时回调。
	     * @see {@link timeout}
	     */
	    onTimeout(cb: Function): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/raycasthit' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	export default class RayCastHit {
	    constructor(nativeComp?: phys3D.RaycastHit);
	    /**
	       * native层真正的raycastHit对象，业务侧无需关心
	       */
	    get nativeRayCastHit(): phys3D.RaycastHit | undefined;
	    /**
	       * 被射线射中的collider所附的Rigidbody，如果collider没有附着在一个Rigidbody上，则为null
	       */
	    get rigidbody(): import('!!Only Export Engine Module, Cant Use Internal Module：engine/type').Nullable<import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/rigidbody').default>;
	    /**
	       * 被射线射中的collider
	       */
	    get collider(): import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider').default | null;
	    /**
	       * 从光线的原点到碰撞点的距离
	       */
	    get distance(): number;
	    set distance(v: number);
	    /**
	       * 射线锁碰到的表面的法线
	       */
	    get normal(): Vector3;
	    set normal(v: Vector3);
	    /**
	       * 在世界空间中，射线碰到collider的碰撞点
	       */
	    get point(): Vector3;
	    set point(v: Vector3);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/memorycache-inspector' {
	import { BaseResource } from 'engine';
	export default class MemoryCacheInspector {
	    static getGfxCacheCount(): {
	        [gfxObjType: string]: number;
	    };
	    static addAdditionalResource(asset: BaseResource): void;
	    static getAssetCacheCount(): {
	        [assetType: string]: {
	            count: number;
	            everCount: number;
	            totalSize: number;
	        };
	    };
	    static getLoaderStringCount(): number;
	    static getAssetCacheDetailByType(type: string): {
	        key: string;
	        size: number;
	    }[];
	    static getGraphicResource(): {
	        canvasSize: any;
	        imageSize: any;
	        imageSrc: any;
	    };
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/debug-plugin' {
	 type ILanDebugHost = {
	    ip: string;
	    port: number;
	} | undefined; class DebugPlugin {
	    constructor();
	    initLanDebug: (lanDebugHost: ILanDebugHost, isDevtool: boolean) => void;
	    handleDebugMessage: (msg: {
	        command: string;
	        data?: any;
	    }, socket?: engineWX.SocketTask | undefined) => Promise<unknown>;
	} const _default: DebugPlugin;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/debug' {
	import loadInspector from '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/load-inspector';
	import Logger, { LoggerInstance } from '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/logger';
	import MemoryCacheInspector from '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/memorycache-inspector';
	import DebugPlugin from '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/debug-plugin';
	import option from '!!Only Export Engine Module, Cant Use Internal Module：engine/debug/option';
	export { Logger, LoggerInstance, MemoryCacheInspector, MemoryCacheInspector as CacheInspector, loadInspector, DebugPlugin, option };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/physics' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Rigidbody from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/rigidbody';
	import CharacterController from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/charactercontroller';
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import RaycastHit from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/raycasthit';
	import Game, { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import { QueryTriggerInteraction } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	import Quaternion from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion';
	/**
	 * 物理系统。
	 *
	 * 脚本内通过`engine.game.physicsSystem`来获取。
	 * 实例上会挂载全局的物理配置，和一些物理工具接口。
	 *
	 * @category System
	 * @category Physics
	 */
	export default class PhysicsSystem implements IGameSystem {
	    readonly game: Game;
	    /**
	     * 物理系统是否启用。
	     * 游戏初始化后这一项会变为`true`。
	     *
	     * 关闭这项会导致：
	     * 1. 每帧的*物理模拟*不再进行；
	     * 2. 物理组件无法初始化。
	     *
	     * 如果你很确定你的游戏不需要用到物理，并且也没有任何物理组件，可以手动关闭这一项。会略微提升性能。
	     */
	    active: boolean;
	    /**
	     * 在每两个渲染帧之间，最多能进行时长为maxPhysicsDeltaTime的*物理模拟*。
	     * 如果没有这一限制，那么在渲染帧花费时间较长的时候，*物理模拟*花费的时间也会很长，导致进一步性能恶化。
	     */
	    maxPhysicsDeltaTime: number;
	    /**
	     * 不同于渲染帧，每次*物理模拟*的时长都是固定的。
	     * 将这一项变小，会消耗更多性能，产生更自然的模拟。
	     */
	    fixedDeltaTime: number;
	    /**
	     * 每帧是否进行*物理模拟*。
	     */
	    autoSimulation: boolean;
	    /**
	     * 射线检测，判断给定射线是否与至少一个碰撞体相交，并返回与**最近**的那个碰撞体相交的信息。
	     * @param origin 射线起点。
	     * @param unitDir 射线方向（单位向量）。
	     * @param distance 射线的最大长度。
	     * @param hit 用来接收碰撞信息的容器。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     */
	    rayCast(origin: Vector3, unitDir: Vector3, distance?: number, hit?: RaycastHit, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): boolean;
	    /**
	     * 射线检测，返回与射线相交的所有碰撞体的信息。
	     * @param origin 射线起点。
	     * @param unitDir 射线方向（单位向量）。
	     * @param distance 射线的最大长度。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 所有相交信息。
	     */
	    rayCastAll(origin: Vector3, unitDir: Vector3, distance?: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): RaycastHit[];
	    /**
	     * 在场景中沿射线移动一个胶囊体，检测场景中是否有碰撞体与胶囊体相交。
	     * @param p1 （起点处）胶囊体一端的半球的球心。
	     * @param p2 （起点处）胶囊体另一端的半球的球心。
	     * @param radius 胶囊体两端半球的半径。
	     * @param direction 射线的方向。
	     * @param maxDistance 射线的最大长度。
	     * @param hit 用来接收碰撞信息的容器。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     */
	    capsuleCast(p1: Vector3, p2: Vector3, radius: number, direction: Vector3, maxDistance?: number, hit?: RaycastHit, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): boolean;
	    /**
	     * 在场景中沿射线移动一个胶囊体，返回路径上中所有与胶囊体相交的碰撞体。
	     * @param p1 （起点处）胶囊体一端的半球的球心。
	     * @param p2 （起点处）胶囊体另一端的半球的球心。
	     * @param radius 胶囊体两端半球的半径。
	     * @param direction 射线的方向。
	     * @param maxDistance 射线的最大长度。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 所有相交信息。
	     */
	    capsuleCastAll(p1: Vector3, p2: Vector3, radius: number, direction: Vector3, maxDistance?: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): RaycastHit[];
	    /**
	     * 在场景中沿射线移动一个球体，检测场景中是否有碰撞体与球体相交。
	     * @param origin （起点处）球心。
	     * @param radius 球体半径。
	     * @param direction 射线方向。
	     * @param maxDistance 射线的最大长度。
	     * @param hit 用来接收碰撞信息的容器。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     */
	    sphereCast(origin: Vector3, radius: number, direction: Vector3, maxDistance?: number, hit?: RaycastHit, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): boolean;
	    /**
	     * 在场景中沿射线移动一个球体，返回路径上中所有与球体相交的碰撞体。
	     * @param origin （起点处）球心。
	     * @param radius 球体半径。
	     * @param direction 射线方向。
	     * @param maxDistance 射线的最大长度。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 所有相交信息。
	     */
	    sphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance?: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): RaycastHit[];
	    /**
	     * 沿射线投射盒体并返回有关命中对象的详细信息
	     * @param {Vector3} center  盒体的中心
	     * @param {Vector3} halfExtents 盒体各个维度大小的一半
	     * @param {Vector3} direction 投射盒体的方向
	     * @param {RaycastHit} hit 如果返回 true，则 hit 将包含有关碰撞体的撞击位置的更多信息
	     * @param {Quaternion} orientation 盒体的旋转
	     * @param {nuber} maxDistance 投射的最大长度
	     * @param {number} layerMask 层遮罩，用于在投射胶囊体时有选择地忽略碰撞体
	     * @param {number} queryTriggerInteraction 指定该查询是否应该命中触发器。
	     */
	    /**
	     * 在场景中沿射线移动一个长方体，检测场景中是否有碰撞体与长方体相交。
	     * @param center 长方体的中心位置。
	     * @param halfExtents 长方体的长宽高的**一半**。
	     * @param direction 射线方向。
	     * @param hit 用来接收碰撞信息的容器。
	     * @param orientation 长方体的旋转（四元数）。
	     * @param maxDistance 射线的最大长度。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     */
	    boxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hit?: RaycastHit, orientation?: Quaternion, maxDistance?: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): any;
	    /**
	     * 在场景中沿射线移动一个长方体，返回路径上中所有与长方体相交的碰撞体。
	     * @param center 长方体的中心位置。
	     * @param halfExtents 长方体的长宽高的**一半**。
	     * @param direction 射线方向。
	     * @param orientation 长方体的旋转（四元数）。
	     * @param maxDistance 射线的最大长度。
	     * @param layerMask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 所有相交信息。
	     */
	    boxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation?: Quaternion, maxDistance?: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction): RaycastHit[];
	    /**
	     * 检测场景中是否有碰撞体与给定长方体相交。
	     * @param center 长方体的中心位置。
	     * @param halfExtends 长方体的长宽高的**一半**。
	     * @param orientation 长方体的旋转（四元数）。
	     * @param layermask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 所有相交的碰撞体。
	     */
	    overlapBox(center: Vector3, halfExtends: Vector3, orientation?: Quaternion, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction): Collider[];
	    /**
	     * 检测场景中是否有碰撞体与给定长方体相交。
	     * @param center 长方体的中心位置。
	     * @param halfExtends 长方体的长宽高的**一半**。
	     * @param orientation 长方体的旋转（四元数）。
	     * @param layermask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 是否有相交。
	     */
	    checkBox(center: Vector3, halfExtends: Vector3, orientation: Quaternion, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction): boolean;
	    /**
	     * 检测场景中是否有碰撞体与给定胶囊体相交。
	     * @param p1 胶囊体一端的半球的球心。
	     * @param p2 胶囊体另一端的半球的球心。
	     * @param radius 胶囊体两端的半球的半径。
	     * @param layermask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 所有相交的碰撞体。
	     */
	    overlapCapsule(p1: Vector3, p2: Vector3, radius: number, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction): Collider[];
	    /**
	     * 检测场景中是否有碰撞体与给定胶囊体相交。
	     * @param p1 胶囊体一端的半球的球心。
	     * @param p2 胶囊体另一端的半球的球心。
	     * @param radius 胶囊体两端的半球的半径。
	     * @param layermask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 是否有相交。
	     */
	    checkCapsule(p1: Vector3, p2: Vector3, radius: number, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction): boolean;
	    /**
	     * 检测场景中是否有碰撞体与给定球体相交。
	     * @param origin 球心。
	     * @param radius 球体半径。
	     * @param layermask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 所有相交的碰撞体。
	     */
	    overlapSphere(origin: Vector3, radius: number, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction): Collider[];
	    /**
	     * 检测场景中是否有碰撞体与给定球体相交。
	     * @param origin 球心。
	     * @param radius 球体半径。
	     * @param layermask 可以用来屏蔽一些碰撞体。
	     * @param queryTriggerInteraction 暂未实现，默认能与Trigger相交。
	     * @returns 是否有相交。
	     */
	    checkSphere(origin: Vector3, radius: number, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction): boolean;
	    /**
	     * 设定某一对layer之间是否会发生碰撞。
	     * @param ignore `true`表示**不**碰撞。
	     */
	    ignoreLayerCollision(layer1: number, layer2: number, ignore?: boolean): void;
	    dispose(): void;
	    /**
	     * 全局重力。
	     * @default //TODO
	     */
	    get gravity(): Vector3;
	    set gravity(v: Vector3);
	    /**
	     * 两个碰撞体发生碰撞时，如果相对碰撞速度小于这一项，则不会弹开。
	     * @limit bounceThreshold > 0
	     * @default (0, -9.8, 0)
	     */
	    get bounceThreshold(): number;
	    set bounceThreshold(v: number);
	    /**
	     * 全局默认最大角速度。
	     * @default 0
	     */
	    get defaultMaxAngularSpeed(): number;
	    set defaultMaxAngularSpeed(v: number);
	    /**
	     * 全局默认碰撞解决迭代次数。
	     * @default 6
	     * @see {@link Rigidbody.solverIterations}
	     */
	    get defaultSolverIterations(): number;
	    set defaultSolverIterations(v: number);
	    /**
	     * 全局默认碰撞解决迭代次数。
	     * @default 1
	     * @see {@link Rigidbody.solverVelocityIterations}
	     */
	    get defaultSolverVelocityIterations(): number;
	    set defaultSolverVelocityIterations(v: number);
	    /**
	     * 全局默认休眠能量阈值。
	     * @default 0.005
	     * @see {@link Rigidbody.sleepThreshold}
	     */
	    get sleepThreshold(): number;
	    set sleepThreshold(v: number);
	    /**
	     * 默认contactOffset。
	     * @default 0.01
	     * @see {@link Collider.contactOffset}
	     */
	    get defaultContactOffset(): number;
	    set defaultContactOffset(v: number);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/light' {
	import { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import DirectionalLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/directionalLight';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/baseLight';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { LightEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import { PriorityArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/node'; type Game = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default; class InvokeLightOnce<T extends BaseLight> extends PriorityArray<T> {
	    invokeFunc: (light: T) => void;
	    constructor(invokeFunc: (light: T) => void);
	    invoke(cycle?: boolean): void;
	}
	export default class LightSystem implements IGameSystem {
	    readonly game: Game;
	    get mainDirectionalLight(): Nullable<DirectionalLight>;
	    get sceneLights(): BaseLight[];
	    get count(): number;
	    constructor(game: Game);
	    update(): void;
	    forEach(cb: (light: BaseLight, index: number) => void): void;
	    dispose(): void;
	    hasInited(): boolean;
	    clear(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/streaming-loading' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { Task } from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/task';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Prefab from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/prefab'; enum EUnloadType {
	    /** 表示将这些节点的 active 置为 false。 */
	    Deactivate = 0,
	    /** 表示将调用节点的 destroy 方法，即销毁。  */
	    Destroy = 1
	} type StreamingLoadingObjectInformation = {
	    center: [number, number, number];
	    radius: number;
	    priority?: number;
	    unloadType?: EUnloadType;
	    unloadDebounce?: number;
	    prefabID: string;
	}; class StreamingLoadingComponent extends Component {
	    /**
	     * 表示这些子节点的加载优先级。
	     * @type {number}
	     * @memberof StreamingLoadingComponent
	     */
	    get loadingPriority(): number;
	    set loadingPriority(value: number);
	    /**
	     * 表示这些子节点在被动态卸载时应用怎样的操作。
	     * @type {StreamingLoadingComponent.UnloadType}
	     * @memberof StreamingLoadingComponent
	     */
	    get unloadType(): StreamingLoadingComponent.UnloadType;
	    set unloadType(value: StreamingLoadingComponent.UnloadType);
	    /**
	     * 表示节点被判定要卸载时的一个防抖动等待时间，为了避免玩家在一个边界区域反复移动时造成的反复卸载。
	     * @memberof StreamingLoadingComponent
	     */
	    get unloadDebounce(): number;
	    set unloadDebounce(value: number);
	} namespace StreamingLoadingComponent {
	    /** 表示这些子节点在被动态卸载时应用怎样的操作。 */
	    export import UnloadType = EUnloadType;
	    class StreamingLoadingObject {
	        center: Vector3;
	        radius: number;
	        readonly priority: number;
	        readonly prefabID: string;
	        readonly unloadType: StreamingLoadingComponent.UnloadType;
	        readonly unloadDebounce: number;
	        task: Task<Prefab>;
	        constructor(information: StreamingLoadingObjectInformation, level: StreamingLoadingComponent, parent: Entity);
	    }
	}
	export default StreamingLoadingComponent;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/system/streaming-loading' {
	import { IGameSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import StreamingLoadingComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/streaming-loading';
	import { TaskManager } from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/task';
	import Prefab from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/prefab'; enum TestResult {
	    Load = 0,
	    Unload = 1,
	    Keep = 2
	} class StreamingLoadingSystem extends TaskManager<Prefab> implements IGameSystem {
	    /**
	     * 是否要加载或卸载Prefab的检查器。
	     * @type {StreamingLoadingSystem.Tester}
	     * @memberof StreamingLoadingSystem
	     */
	    tester: StreamingLoadingSystem.Tester;
	    /**
	     * 检查的间隔时间。
	     * @type {number}
	     * @memberof StreamingLoadingSystem
	     */
	    interval: number;
	    dispose(): void;
	} namespace StreamingLoadingSystem {
	    interface Tester {
	        /** 一个没有参数的回调函数，表示是否需要进行后续的遍历，如视角/玩家位置变化不大，可以理解为玩家视野变化不大，因此无须遍历检查物体是否需要加载/卸载。 */
	        needTest(): boolean;
	        /** 一个传入 StreamingLoadingObject 的回调函数，StreamingLoadingObject 包含以下几项属性。 */
	        test(object: StreamingLoadingComponent.StreamingLoadingObject): TestResult;
	    }
	}
	export default StreamingLoadingSystem;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/eventEmitter' {
	export class EventEmitter {
	    on(event: string, listener: (...args: any[]) => any): () => void;
	    removeListener(event: string, listener: (...args: any[]) => any): void;
	    emit(event: string, ...args: any[]): void;
	    once(event: any, listener: any): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game' {
	import { default as SceneResource } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/scene';
	import { RawTouchEvents } from '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/touch';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import { Entity2D, Entity3D, Scene2D, Scene3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import AnimationSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/animation';
	import NodeSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/node';
	import RenderSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render';
	import LayoutSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/layout';
	import UICamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICamera';
	import UICanvas from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICanvas';
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { LightEventType, MeshRendererEventType, PipeLineEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import WorkerSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/worker';
	import PhysicsSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/physics';
	import LightSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/light';
	import StreamingLoadingSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/streaming-loading';
	import { EventEmitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/eventEmitter';
	export interface IGameSystem {
	    dispose(): void;
	}
	export const DefaultEntityName = "NewEntity";
	export const DefaultEntity2DName = "NewEntity2D";
	/**
	 * @export
	 * @class Game
	 */
	export default class Game {
	    readonly renderSystem: RenderSystem;
	    readonly nodeSystem: NodeSystem;
	    readonly animationSystem: AnimationSystem;
	    readonly layoutSystem: LayoutSystem;
	    readonly workerSystem: WorkerSystem;
	    readonly physicsSystem: PhysicsSystem;
	    readonly streamingLoadingSystem: StreamingLoadingSystem;
	    readonly root: Entity3D;
	    readonly lightSystem: LightSystem;
	    readonly sceneRoot: Entity2D & Entity3D;
	    readonly detachedRoot: Entity2D & Entity3D;
	    readonly editorRootEntity?: Entity2D & Entity3D;
	    readonly rootUICanvas: UICanvas;
	    readonly rootUICamera: UICamera;
	    readonly persistEntities: Set<Entity>;
	    readonly meshRendererEvent: Emitter<import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer').default, MeshRendererEventType>;
	    readonly lightEvent: Emitter<import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/baseLight').default, LightEventType>;
	    readonly pipelineEvent: Emitter<PipeLineEventType, void>;
	    readonly touchEvent: Emitter<RawTouchEvents, TouchEvent>;
	    readonly customEventEmitter: EventEmitter;
	    gameTime: number;
	    startTime: number;
	    lastFrameTime: number;
	    mainFrameCnt: number;
	    get activeScene(): Scene3D;
	    get activeScene2D(): Scene2D;
	    constructor();
	    markAsPersist(entity: Entity): void;
	    createEntity2D(name?: string): Entity2D;
	    createEntity3D(name?: string): Entity3D;
	    playScene(scene: SceneResource): Entity;
	    clearScene(clear3D: boolean, clear2D: boolean): void;
	    run(): void;
	    /**
	     * 让game使用当前启用的worker。
	     * 如果有之前在使用着的worker，会清空job队列。
	     */
	    initWorkerSystem(): void;
	    /**
	     * @deprecated
	     * 请使用game.workerSystem.createJob代替
	     */
	    createWorkerJob(jobPath: string, data: any): import('!!Only Export Engine Module, Cant Use Internal Module：engine/type').Nullable<import('engine').WorkerJob>;
	    /**
	     * TODO
	     * in progress
	     */
	    rpc(funcName: string, data: any, callback: (data: any) => void): void;
	    dumpScene(): [string, string];
	    dispose(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/Instantiator' {
	import { PrefabResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { Immutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity'; type Game = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default;
	export type Entity3D = Entity & {
	    transform: Transform3D;
	};
	export type Entity2D = Entity & {
	    transform2D: Transform2D;
	};
	export default class Instantiator {
	    static Instantiate(game: Game, prefabJSON: PrefabResourceDescription, uuidToBufferMap: {
	        [uuid: string]: ArrayBuffer;
	    }, componentsOut?: any[]): Entity;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/prefab' {
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { PrefabResourceDescription, SceneResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource'; type PrefabLikeDescription = PrefabResourceDescription | SceneResourceDescription;
	export class PrefabLike<T extends PrefabLikeDescription> extends BaseResource {
	    readonly description: T;
	    /**
	     * Prefab资源的反序列化逻辑。
	     * @static
	     * @param {PrefabResourceDescription} resourceDescription 资源配置。
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {Prefab}
	     * @memberof Prefab
	     */
	    /**
	     * Prefab资源的额外描述。
	     * @readonly
	     * @type {PrefabResourceDescription["meta"]}
	     * @memberof Prefab
	     */
	    get meta(): T["meta"];
	    get data(): T;
	    uuidToBufferMap: {
	        [uuid: string]: ArrayBuffer;
	    };
	    /**
	     * 强持有所依赖的资源，防止该资源长时间未实例化时，其依赖的资源因weakRef机制被释放。
	     * @protected
	     * @type {any[]}
	     * @memberof AnimatorController
	     */
	    dependencies?: BaseResource[];
	    scripts?: string[];
	    /**
	     * 从资源配置中实例化Prefab资源。
	     * @param {PrefabResourceDescription} description 资源配置。
	     * @memberof Prefab
	     */
	    constructor(description: T);
	    /**
	     * 实例化Prefab资源。
	     * @returns {(Entity | Never)}
	     * @memberof Prefab
	     */
	    instantiate(componentsOut?: any[]): Entity;
	}
	/**
	 * Prefab资源。
	 * @export
	 * @class Prefab
	 * @extends {BaseResource}
	 */
	export default class Prefab extends PrefabLike<PrefabResourceDescription> {
	    static DeserializeResource(description: PrefabResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): Prefab;
	    constructor(desc: PrefabResourceDescription, isFbxPrefab?: boolean);
	    /**
	     *
	     * 实例化一个prefab，并把__type、__prefab、__prefabInstanceLocalID等信息加到entity上
	     * 一般用于工具中的addPrefab功能，若在runtime或game模式运行，则回退成instantiate的能力。
	     */
	    instantiateWithPrefabInfo(prefabInstanceID?: string): Entity;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/scene' {
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { SceneResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import { PrefabLike } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/prefab';
	/**
	 * 场景资源。
	 * @export
	 * @class Scene
	 * @extends {BaseResource}
	 */
	export default class Scene extends PrefabLike<SceneResourceDescription> {
	    /**
	     * 场景资源反序列化逻辑。
	     * @static
	     * @param {SceneResourceDescription} description
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {Scene}
	     * @memberof Scene
	     */
	    static DeserializeResource(description: SceneResourceDescription, loadContext: BaseLoadContext): Scene;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/textureCube' {
	import { TextureCubeResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import Texture, { TextureFilterMode, TextureSource } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	export const CUBE_ORDER_TO_FACE: string[];
	/**
	 * TextureCube构造参数。
	 */
	export interface TextureCubeDesc {
	    filterMode?: TextureFilterMode;
	    wrapU?: Kanata.EWrapMode;
	    wrapV?: Kanata.EWrapMode;
	    wrapW?: Kanata.EWrapMode;
	    anisoLevel?: number;
	}
	/**
	 * 立方体贴图资源。
	 */
	export default class TextureCube extends Texture {
	    /**
	     * 贴图的填充模式。
	     */
	    get filterMode(): TextureFilterMode;
	    /**
	     * 各向异性参数，有效值为1-16。
	     */
	    get anisoLevel(): number;
	    /**
	     * 像素格式。
	     */
	    get pixelFormat(): Kanata.ETextureFormat;
	    /**
	     * 横向采样包围模式。
	     */
	    get wrapU(): Kanata.EWrapMode;
	    /**
	     * 纵向采样包围模式。
	     */
	    get wrapV(): Kanata.EWrapMode;
	    /**
	     * 采样包围模式。
	     */
	    get wrapW(): Kanata.EWrapMode;
	    /**
	     * 是否使用mipmap。
	     */
	    get useMipmap(): boolean;
	    /**
	     * 是否使用需要做预乘处理。
	     */
	    get needUnpackPremultiplyAlpha(): boolean;
	    get mipmapLevel(): number | undefined;
	    get minFilter(): Kanata.EFilterMode | undefined;
	    /**
	     * 贴图高。
	     */
	    get height(): number;
	    /**
	     * 贴图宽。
	     */
	    get width(): number;
	    /**
	     * 是否可动态写入。
	     */
	    get writeable(): boolean;
	    /**
	     * 贴图额外的信息。
	     */
	    get meta(): TextureCubeResourceDescription["desc"] | undefined;
	    /**
	     * 创建TextureCube。
	     */
	    constructor(desc?: TextureCubeDesc);
	    /**
	     * Image对象来初始化
	     *
	     * @param 是否生成mipmap
	     * @returns 是否初始化成功
	     */
	    initWithTextureSources(sources: TextureSource[], width: number, height: number, generateMipmap?: boolean): boolean;
	    /**
	     * 使用压缩纹理初始化
	     * 目前支持 PVR/ASTC (IOS) , ETC1/ETC2 (Android)
	     *
	     * @param pixelFormat 纹理格式
	     * @param bufferSrc 原始buffer,如有mipmap，则逐级连接
	     */
	    initWithCompressTexture(pixelFormat: Kanata.ETextureFormat, buffers: ArrayBuffer[], width: number, height: number, mipmapLevel?: number): boolean;
	}
	export const BuildInCubeTextures: {
	    TransparentCube: TextureCube;
	    WhiteCube: TextureCube;
	    BlackCube: TextureCube;
	    GreenCube: TextureCube;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene' {
	import { default as SceneResource } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/scene';
	import { AmbientMode, FogMode, UIAdaptationType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import TextureCube from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/textureCube';
	export interface LightMapData {
	    color: Texture2D;
	    shadowMask?: Texture2D;
	}
	export interface EnvMapData {
	    color: TextureCube;
	}
	export interface PanoramaData {
	    color: Texture2D;
	} type Material = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material').default; type Game = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default; type DirectionalLight = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/directionalLight').default;
	export type Entity3D = Entity & {
	    transform: Transform3D;
	};
	export type Entity2D = Entity & {
	    transform2D: Transform2D;
	};
	export class Scene3D {
	    readonly settings: Scene3DSettings;
	    readonly root: Entity3D;
	    readonly name: string;
	    readonly game: Game;
	    constructor(game: Game, scene?: SceneResource);
	    dispose(): void;
	}
	export class Scene3DSettings {
	    readonly scene: Scene3D;
	    get directionalLights(): DirectionalLight[];
	    get fogMode(): FogMode;
	    set fogMode(fogMode: FogMode);
	    get fogColor(): Vector3;
	    set fogColor(val: Vector3);
	    get fogStart(): number;
	    set fogStart(val: number);
	    get fogRange(): number;
	    set fogRange(val: number);
	    get fogDensity(): number;
	    set fogDensity(fogDensity: number);
	    get ambientMode(): AmbientMode;
	    set ambientMode(ambientMode: AmbientMode);
	    get ambientLight(): Vector3;
	    set ambientLight(val: Vector3);
	    get ambientIntensity(): number;
	    set ambientIntensity(ambientIntensity: number);
	    get ambientSkyColor(): Color;
	    set ambientSkyColor(ambientSkyColor: Color);
	    get ambientEquatorColor(): Color;
	    set ambientEquatorColor(ambientEquatorColor: Color);
	    get ambientGroundColor(): Color;
	    set ambientGroundColor(ambientGroundColor: Color);
	    get skyBox(): Nullable<Material>;
	    set skyBox(skyBox: Nullable<Material>);
	    get mainEnvironmentMap(): TextureCube;
	    get mainPanoramaMap(): Texture2D;
	    get shCoefficients(): Float32Array;
	    lightMaps: LightMapData[];
	    lightMapType: number;
	    subtractiveShadowColor: Color;
	    envMaps: EnvMapData[];
	    constructor(scene: Scene3D, sceneResource: SceneResource);
	}
	export class Scene2D {
	    readonly settings: Scene2DSettings;
	    readonly root: Entity2D;
	    readonly name: string;
	    readonly game: Game;
	    constructor(game: Game, scene?: SceneResource);
	    get width(): number;
	    get height(): number;
	    dispose(): void;
	} class Scene2DSettings {
	    readonly scene: Scene2D;
	    get designWidth(): number;
	    set designWidth(designWidth: number);
	    get designHeight(): number;
	    set designHeight(designHeight: number);
	    get adaptationType(): UIAdaptationType;
	    set adaptationType(adaptationType: UIAdaptationType);
	    constructor(scene: Scene2D, sceneResource: SceneResource);
	}
	export const EmptyScene3DResource: SceneResource;
	export const EmptyScene2DResource: SceneResource;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D' {
	import Rect from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/rect';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	import { M4ReadOnly, M3ReadOnly, V2ReadOnly, NumberReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export default class Transform2D extends TransformBase {
	    readonly entity: Entity2D;
	    /**
	     * local位移
	     *
	     * @type {Vector2}
	     * @memberof Transform2D
	     */
	    get position(): Vector2;
	    set position(val: Vector2);
	    /**
	     * local位移x分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get positionX(): number;
	    set positionX(val: number);
	    /**
	     * local位移y分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get positionY(): number;
	    set positionY(val: number);
	    /**
	     * local旋转
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get rotation(): number;
	    set rotation(val: number);
	    /**
	     * local缩放
	     *
	     * @type {Vector2}
	     * @memberof Transform2D
	     */
	    get scale(): Vector2;
	    set scale(val: Vector2);
	    /**
	     * local缩放x分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get scaleX(): number;
	    set scaleX(val: number);
	    /**
	     * local缩放y分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get scaleY(): number;
	    set scaleY(val: number);
	    /**
	     * local尺寸
	     *
	     * @type {Vector2}
	     * @memberof Transform2D
	     */
	    get size(): Vector2;
	    set size(val: Vector2);
	    /**
	     * local尺寸x分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get sizeX(): number;
	    set sizeX(val: number);
	    /**
	     * local尺寸y分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get sizeY(): number;
	    set sizeY(val: number);
	    /**
	     * local锚点
	     *
	     * @type {Vector2}
	     * @memberof Transform2D
	     */
	    get anchor(): Vector2;
	    set anchor(val: Vector2);
	    /**
	     * local锚点
	     * 也支持通过pivot获取和设置
	     * @type {Vector2}
	     * @memberof Transform2D
	     */
	    get pivot(): Vector2;
	    set pivot(val: Vector2);
	    /**
	     * 本地锚点x分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get anchorX(): number;
	    set anchorX(val: number);
	    /**
	     * 本地锚点y分量
	     *
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get anchorY(): number;
	    set anchorY(val: number);
	    /**
	     * 4x4的世界RTS矩阵，为了对齐3D，只读
	     *
	     * @readonly
	     * @type {M4ReadOnly}
	     * @memberof Transform2D
	     */
	    get worldMatrix(): M4ReadOnly;
	    /**
	     * 3x3世界RTS矩阵，只读
	     *
	     * @readonly
	     * @type {M3ReadOnly}
	     * @memberof Transform2D
	     */
	    get worldMatrix3(): M3ReadOnly;
	    /**
	     * 本地RTS矩阵，只读
	     *
	     * @readonly
	     * @type {M3ReadOnly}
	     * @memberof Transform2D
	     */
	    get localMatrix3(): M3ReadOnly;
	    /**
	     * 世界位移，只读
	     *
	     * @readonly
	     * @type {V2ReadOnly}
	     * @memberof Transform2D
	     */
	    get worldPosition(): V2ReadOnly;
	    /**
	     * 世界位移x分量，只读
	     *
	     * @readonly
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get worldPositionX(): number;
	    /**
	     * 世界位移y分量，只读
	     *
	     * @readonly
	     * @type {number}
	     * @memberof Transform2D
	     */
	    get worldPositionY(): number;
	    /**
	     * 世界缩放，只读
	     *
	     * @readonly
	     * @type {V2ReadOnly}
	     * @memberof Transform2D
	     */
	    get worldScale(): V2ReadOnly;
	    /**
	     * 世界旋转，只读
	     *
	     * @readonly
	     * @type {NumberReadOnly}
	     * @memberof Transform2D
	     */
	    get worldRotation(): NumberReadOnly;
	    get isRectTransform(): boolean;
	    set isRectTransform(val: boolean);
	    get leftAnchor(): number | undefined;
	    set leftAnchor(val: number | undefined);
	    get leftOffset(): number;
	    set leftOffset(val: number);
	    get rightAnchor(): number | undefined;
	    set rightAnchor(val: number | undefined);
	    get rightOffset(): number;
	    set rightOffset(val: number);
	    get bottomAnchor(): number | undefined;
	    set bottomAnchor(val: number | undefined);
	    get bottomOffset(): number;
	    set bottomOffset(val: number);
	    get topAnchor(): number | undefined;
	    set topAnchor(val: number | undefined);
	    get topOffset(): number;
	    set topOffset(val: number);
	    get leftRelative(): number;
	    set leftRelative(val: number);
	    get topRelative(): number;
	    set topRelative(val: number);
	    /**
	     * 请使用engine.game.createEntity2D(name)创建2D对象
	     *
	     * @param {Entity2D} entity
	     * @param {Float32Array} [_rawNativeValue]
	     * @param {Float32Array} [_raw]
	     * @param {number} [_offset]
	     * @memberof Transform2D
	     */
	    constructor(entity: Entity2D,rawNativeValue?: Float32Array);
	    /**
	     * 在当前节点前插入新的节点, 新插入的节点世界矩阵不变
	     * @param {Transform2D} child 要插入的节点
	     * @returns {boolean} 是否插入成功
	     * @memberof Transform2D
	     */
	    immovableBefore(child: Transform2D): boolean;
	    /**
	     * 在当前节点后插入新的节点, 新插入的节点世界矩阵不变
	     * @param {Transform2D} child 要插入的节点
	     * @returns {boolean} 是否插入成功
	     * @memberof Transform2D
	     */
	    immovableAfter(child: Transform2D): boolean;
	    /**
	     * 把当前节点添加到指定的parent节点里，作为其子节点。 当前节点世界矩阵不变
	     * @param {Transform2D} parent 当前节点移动后的parent
	     * @returns {boolean} 是否插入成功
	     * @memberof Transform2D
	     */
	    immovableAppendTo(parent: Transform2D): boolean;
	    /**
	     * 添加子节点，若子节点已存在父节点，则会先移除其父节点
	     * 子节点必须是Transform2D
	     *
	     * @param {Transform2D} child
	     * @returns {boolean} 是否添加成功
	     * @memberof Transform2D
	     */
	    addChild(child: Transform2D): boolean;
	    /**
	     * 添加子节点到指定index，若子节点已存在父节点，则会先移除其父节点
	     * 子节点必须是Transform2D
	     *
	     * @param {Transform2D} child 子节点
	     * @param {number} index index顺序
	     * @returns {boolean} 添加是否成功
	     * @memberof Transform2D
	     */
	    addChildAtIndex(child: Transform2D, index: number): boolean;
	    /**
	     * 删除指定子节点
	     *
	     * @param {Transform2D} child 要删除的子节点
	     * @returns {boolean} 是否删除成功
	     * @memberof Transform2D
	     */
	    removeChild(child: Transform2D): boolean;
	    /**
	     * 将世界坐标转换为本地坐标系坐标
	     *
	     * @param {V2ReadOnly} worldPosition 世界坐标
	     * @param {Vector2} [dst] 是否将计算结果输出到Dst
	     * @returns {Vector2} 本地坐标系坐标
	     * @memberof Transform2D
	     */
	    convertWorldPositionToLocal(worldPosition: V2ReadOnly, dst?: Vector2): Vector2;
	    /**
	     * 测试该节点世界包围盒是否包含某个点
	     *
	     * @param {V2ReadOnly} worldPosition 测试点的世界坐标
	     * @param {Nullable<Rect>} [hitArea] 如果传了该参数，则使用该区域作为本地包围盒
	     * @param {Vector2} [dstLocal] 如果传了该参数，则将返回测试点在本地坐标系下的坐标
	     * @returns {boolean} 是否包含
	     * @memberof Transform2D
	     */
	    hitTest(worldPosition: V2ReadOnly, hitArea?: Nullable<Rect>, dstLocal?: Vector2): boolean;
	    /**
	     * 测试该节点世界包围盒是否在某个区域内
	     *
	     * @param {V2ReadOnly} startWorldPosition 测试点的世界坐标
	     * @param {V2ReadOnly} endWorldPosition 测试点的世界坐标
	     * @param {Nullable<Rect>} [hitArea] 如果传了该参数，则使用该区域作为本地包围盒
	     * @returns {boolean} 是否包含
	     * @memberof Transform2D
	     */
	    rangeTest(startWorldPosition: V2ReadOnly, endWorldPosition: V2ReadOnly, hitArea?: Nullable<Rect>): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity' {
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Entity2D, Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Game from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import { Emitter } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	/**
	 * 场景节点类。
	 * @export
	 * @class Entity
	 */
	export default class Entity {
	    /**
	     * 3D变换信息，2D节点该属性为空。
	     * @type {Transform3D}
	     * @memberof Entity
	     */
	    transform?: Transform3D;
	    /**
	     * 2D变换信息，3D节点该属性为空。
	     * @type {Transform2D}
	     * @memberof Entity
	     */
	    transform2D?: Transform2D;
	    /**
	     * 节点的名字
	     * @type {string}
	     * @memberof Entity
	     */
	    name: string;
	    /**
	     * 节点是否已经被销毁。
	     * @type {boolean}
	     * @memberof Entity
	     */
	    readonly isDestroyed: boolean;
	    /**
	     * 节点场景所在的游戏运行实例，当节点被销毁后该属性会置位null。
	     * @type {Game}
	     * @memberof Entity
	     */
	    game: Game;
	    /**
	     * 节点是否处于激活状态。
	     * @type {boolean}
	     * @memberof Entity
	     */
	    get active(): boolean;
	    set active(val: boolean);
	    /**
	     * 节点在层级结构中是否处于激活状态。
	     * @readonly
	     * @type {boolean}
	     * @memberof Entity
	     */
	    get activeInHierarchy(): boolean;
	    /**
	     * 创建一个节点。
	     * @param {Game} game 所依附的游戏运行实例。
	     * @param {string} [name="NewEntity"]
	     * @memberof Entity
	     */
	    constructor(game: Game, name?: string);
	    /**
	     * 创建3D节点。
	     * @deprecated
	     * @static
	     * @param {string} name
	     * @returns {Entity3D}
	     * @memberof Entity
	     */
	    static createEntity3D(name: string): Entity3D;
	    /**
	     * 创建2D节点。
	     * @deprecated
	     * @static
	     * @param {string} name
	     * @returns {Entity2D}
	     * @memberof Entity
	     */
	    static createEntity2D(name: string): Entity2D;
	    /**
	     * 获取某一类型的组件。
	     * @template T
	     * @param {typeof Component} ctor
	     * @returns {Nullable<T>}
	     * @memberof Entity
	     */
	    getComponent<T extends Component>(ctor: typeof Component): Nullable<T>;
	    /**
	     * 获取某一类型的组件列表。
	     * @template T
	     * @param {typeof Component} ctor
	     * @returns {T[]}
	     * @memberof Entity
	     */
	    getComponents<T extends Component>(ctor: typeof Component): T[];
	    /**
	     * 获取所有组件列表。
	     * @readonly
	     * @type {Component[]}
	     * @memberof Entity
	     */
	    get components(): Component[];
	    /**
	     * 获取所有组件列表。
	     * @deprecated
	     * @returns {Component[]}
	     * @memberof Entity
	     */
	    getAllComponents(): Component[];
	    /**
	     * 添加组件。
	     * @template T
	     * @param {typeof Component} ctor
	     * @returns {(T | never)}
	     * @memberof Entity
	     */
	    addComponent<T extends Component>(ctor: typeof Component): T | never;
	    registScriptCompEvent(scriptComp: Component): void;
	    fireScriptCompEventEmitter(eventName: string, ...args: any[]): boolean;
	    removeScriptCompEventListener(scriptComp: Component): void;
	    disposeScriptCompEventEmitter(): void;
	    /**
	     * 移除组件。
	     * @param {Component} comp
	     * @returns {void}
	     * @memberof Entity
	     */
	    removeComponent(comp: Component): void;
	    /**
	     * 销毁节点。
	     * @returns {void}
	     * @memberof Entity
	     */
	    destroy(): void;
	    /**
	     * 立即销毁节点。
	     * @returns {void}
	     * @memberof Entity
	     */
	    destroyImmediate(): void;
	    get layer(): number;
	    set layer(l: number);
	}
	export const InvalidEntity: Entity;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component' {
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import Collision from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collision';
	import ControllerColliderHit from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/controllerColliderHit';
	interface Component {
	} class Component {
	    get active(): boolean;
	    set active(value: boolean);
	    /**
	     * 在场景树中是否active
	     *
	     * @readonly
	     * @type {boolean}
	     * @memberof Component
	     */
	    get activeInHierarchy(): boolean;
	    static Serialize?: (...args: any[]) => any;
	    static Priority: {
	        Low: number;
	        Render: number;
	        Physics: number;
	        Align: number;
	        Layout: number;
	        Tool: number;
	    };
	    readonly priority: number;
	    readonly isDestroyed: boolean;
	    readonly isDestroying: boolean;
	    readonly id: number;
	    readonly entity: Entity;
	    constructor(entity: Entity);
	    getTypeName(): string;
	    destroy(): void;
	    isDetached(): boolean;
	    resetProperties(): void;
	}
	export default Component;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators' {
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; type BaseResource = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource').default; type BaseLoadContext = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base').default;
	export const TypeNames: {
	    Object: string;
	    String: string;
	    Boolean: string;
	    Number: string;
	    AnimationClip: string;
	    AnimatorController: string;
	    AudioMixerAsset: string;
	    Avatar: string;
	    AvatarMask: string;
	    BitmapFont: string;
	    Effect: string;
	    Font: string;
	    Material: string;
	    Mesh: string;
	    Playable: string;
	    AudioClip: string;
	    PhysicMaterial: string;
	    Prefab: string;
	    Scene: string;
	    SpriteFrame: string;
	    Texture2D: string;
	    RenderTexture: string;
	    TextureCube: string;
	    Variant: string;
	    Raw: string;
	    Atlas: string;
	    ScriptableAsset: string;
	    PostProcess: string;
	    Canvas2D: string;
	    Renderable2D: string;
	    UIAnchor: string;
	    UIButton: string;
	    UICanvas: string;
	    UIFrameAnimation: string;
	    UIGraphic: string;
	    UIGrid: string;
	    UILabel: string;
	    UIMask: string;
	    UIRichText: string;
	    UIScrollView: string;
	    UISprite: string;
	    UITextInput: string;
	    UIToggle: string;
	    UIToggleGroup: string;
	    UIWidget: string;
	    UILayer: string;
	    UIMesh: string;
	    OpenDataContainer: string;
	    KeyboardInput: string;
	    TouchInput: string;
	    Skeleton: string;
	    Animator: string;
	    Animation: string;
	    Camera: string;
	    UICamera: string;
	    Component: string;
	    DirectionalLight: string;
	    LineRenderer: string;
	    MeshRenderer: string;
	    SkinnedAnimationRenderer: string;
	    SkinnedMeshRenderer: string;
	    TrailRenderer: string;
	    LODGroup: string;
	    StreamingLoadingComponent: string;
	    Particle: string;
	    RawResourceCollection: string;
	    Transform2D: string;
	    Transform3D: string;
	    TransformBase: string;
	    Color: string;
	    Quaternion: string;
	    Rect: string;
	    Vector2: string;
	    Vector3: string;
	    Vector4: string;
	    Entity: string;
	    GradientColor: string;
	    HermiteCurve: string;
	    ParticleEmitterBurst: string;
	    ParticleBoxShape: string;
	    ParticleConeShape: string;
	    ParticleHemiSphereShape: string;
	    ParticleSphereShape: string;
	    ParticleCircleShape: string;
	    ParticleCommon: string;
	    ParticleEmitter: string;
	    ParticleRenderer: string;
	    ParticleEmitterShape: string;
	    ParticleRotationByLife: string;
	    ParticleSizeByLife: string;
	    ParticleSpeedByLife: string;
	    ParticleSpeedLimitByLife: string;
	    ParticleColorByLife: string;
	    ParticleTextureSheetAnimation: string;
	    Constant: string;
	    Curve: string;
	    TwoConstants: string;
	    TwoCurves: string;
	    OneColor: string;
	    Gradient: string;
	    TwoColors: string;
	    TwoGradients: string;
	    BoundBall: string;
	    BoundBox: string;
	    BooleanVector3: string;
	    Rigidbody: string;
	    BoxCollider: string;
	    CapsuleCollider: string;
	    SphereCollider: string;
	    MeshCollider: string;
	    CharacterController: string;
	    PointLight: string;
	    SpotLight: string;
	    PlayableDirector: string;
	    CullingMask: string;
	    TrackAsset: string;
	    AnimationTrackAsset: string;
	    ActivationTrackAsset: string;
	    AudioTrackAsset: string;
	    ControlTrackAsset: string;
	    GroupTrackAsset: string;
	    TimelineClip: string;
	    AnimationPlayableAsset: string;
	    ActivationPlayableAsset: string;
	    AudioPlayableAsset: string;
	    ControlPlayableAsset: string;
	    AudioSource: string;
	    AudioSourceNode: string;
	    AudioListener: string;
	    AudioListenerNode: string;
	    AudioPannerNode: string;
	    AudioBiquadFilterNode: string;
	    AudioLowPassFilter: string;
	    AudioLowPassFilterNode: string;
	    AudioHighPassFilter: string;
	    AudioHighPassFilterNode: string;
	    AudioDistortionNode: string;
	    AudioDistortion: string;
	    AudioEchoNode: string;
	    AudioEcho: string;
	    AudioSendNode: string;
	    AudioReceiveNode: string;
	    AudioDuckNode: string;
	    AudioAttenuationNode: string;
	    Layout: string;
	    Tutorial: string;
	    TutorialSection: string;
	    TutorialPage: string;
	    TutorialWelcome: string;
	};
	export enum EComponentDimensionType {
	    'TwoD' = "2D",
	    'ThreeD' = "3D",
	    'Mix' = "2/3D",
	    'All' = "All"
	}
	export interface IComponentCtor<T extends Component> {
	    readonly prototype: any;
	    Deserialize?: (data: any, result: T, context: any, builtContext: any) => Nullable<T>;
	    new (entity: Entity): T;
	}
	export interface IInternalCtor<T> {
	    readonly prototype: any;
	    Deserialize?: (data: any, result: T, context: any, builtContext: any) => Nullable<T>;
	    new (...args: any[]): T;
	}
	export interface IResourceCtor {
	    readonly prototype: any;
	    DeserializeResource: (resourceDescription: any, loadContext: BaseLoadContext, dependencies?: string[], uuid?: string) => BaseResource;
	    new (...args: any[]): BaseResource;
	}
	export type SerializableCtor = IComponentCtor<any> | IInternalCtor<any> | IResourceCtor;
	export const ReflectionTable: {
	    [key: string]: SerializableCtor;
	};
	export const PROPERTY_KEY: string;
	export const PROPERTY_ARRAY_KEY: string;
	export const TYPE_NAME_KEY: string;
	export const VALUE_TYPE_FLAG_KEY: string;
	export const CONTEXT_KEY: string;
	export const NO_SERIALIZE_KEY: string;
	export const TRACK_CLIP_TYPE_NAME: string;
	export const TRACK_BINDING_TYPE_NAME: string;
	export const TRACK_DISPLAY_COLOR: string;
	export const TRACK_VISIBLE: string;
	export const AUDIO_EFFECT_NODE_TYPE: string;
	export const AUDIO_SIDE_CHAIN_MAP: string;
	export const AUDIO_SNAPSHOT_PARAM_MAP = "__audioSnapshotParamMap";
	export const COMPONENT_DIMENSION_TYPE: string;
	export class MultiType {
	    constructor(info: {
	        [key: string]: TypeInfo;
	    });
	}
	export class EnumType {
	    constructor(info: any);
	} type ValueOf<T> = T[keyof T];
	export type TypeInfo = ValueOf<typeof TypeNames> | [ValueOf<typeof TypeNames>];
	export interface IPropertyBaseConfig {
	    deserialize?: boolean;
	    serialize?: boolean;
	    required?: boolean;
	    visible?: boolean;
	    tooltips?: string;
	    placeholder?: string;
	    readonly?: boolean;
	    animatable?: boolean;
	    bind?: boolean;
	}
	export interface IPropertyConfig extends IPropertyBaseConfig {
	    type: TypeInfo | MultiType | EnumType;
	    inspectorType?: string;
	}
	export interface IPropertyMultiConfig extends IPropertyBaseConfig {
	    type: {
	        [key: string]: TypeInfo;
	    };
	}
	export interface IPropertyEnumConfig extends IPropertyBaseConfig {
	    type: {
	        [key: string]: string | number;
	    };
	    enumToolTips?: {
	        [key: string]: string;
	    };
	}
	export interface ITrackConfig {
	    clipTypeName?: Nullable<string>;
	    bindingTypeName?: Nullable<string>;
	    color?: string;
	    visible?: boolean;
	}
	export interface IAudioEffectComponentConfig {
	    effectNodeTypeName: string;
	}
	export interface ISideChainConfig {
	    parameterKey?: string;
	    index: number;
	}
	export interface ISideChainMapInfo {
	    nodeKey: string | symbol;
	    parameterKey?: string;
	}
	export type ISideChainMap = Array<ISideChainMapInfo>;
	export interface ISnapshotParamConfig {
	    nodeKey: string;
	    parameterKey?: string;
	    cal?: (val: any) => any;
	    inversoCal?: (val: any) => any;
	}
	export interface ISnapshotParam extends ISnapshotParamConfig {
	}
	export type ISnapshotMap = {
	    [key in string]: ISnapshotParam;
	};
	export const decorators: {
	    context: (aliasTable: {
	        [key: string]: string;
	    }) => (classCtor: SerializableCtor) => void;
	    serialize: (typeName: string, isValueType?: boolean) => ClassDecorator;
	    trackAssetConfig: ({ clipTypeName, bindingTypeName, color, visible }: ITrackConfig) => ClassDecorator;
	    audioEffectComponentConfig: (options: IAudioEffectComponentConfig) => ClassDecorator;
	    audioSideChainInterface: (options: ISideChainConfig) => PropertyDecorator;
	    snapshotParameter: (options: ISnapshotParamConfig) => PropertyDecorator;
	    componentDimensionType: (dimensionType: EComponentDimensionType) => (classCtor: Function) => void;
	    writable: (value: boolean) => (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
	    property: {
	        (config: IPropertyConfig): PropertyDecorator & ParameterDecorator;
	        multi(config: IPropertyMultiConfig): PropertyDecorator & ParameterDecorator;
	        enum(config: IPropertyEnumConfig): PropertyDecorator & ParameterDecorator;
	        array(index: number, config: IPropertyConfig & {
	            type: string;
	        }): PropertyDecorator & ParameterDecorator;
	    };
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { V3ReadOnly, QuatReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	export default class Vector3 {
	    /**
	     * x值
	     *
	     * @type {number}
	     * @memberof Vector3
	     */
	    get x(): number;
	    set x(val: number);
	    /**
	     * y值
	     *
	     * @type {number}
	     * @memberof Vector3
	     */
	    get y(): number;
	    set y(val: number);
	    /**
	     * z值
	     *
	     * @type {number}
	     * @memberof Vector3
	     */
	    get z(): number;
	    set z(val: number);
	    /**
	     * 零向量，不要对该对象进行修改
	     *
	     * @readonly
	     * @static
	     * @type {V3ReadOnly}
	     * @memberof Vector3
	     */
	    static readonly ZERO: V3ReadOnly;
	    /**
	     * 一向量，不要对该对象进行修改
	     *
	     * @readonly
	     * @static
	     * @type {V3ReadOnly}
	     * @memberof Vector3
	     */
	    static readonly ONE: V3ReadOnly;
	    /**
	     * 上方向，不要对该对象进行修改
	     *
	     * @static
	     * @type {V3ReadOnly}
	     * @memberof Vector3
	     */
	    static readonly Up: V3ReadOnly;
	    /**
	     * 前方向，基于左手坐标系，不要对该对象进行修改
	     *
	     * @static
	     * @type {V3ReadOnly}
	     * @memberof Vector3
	     */
	    static readonly ForwardLH: V3ReadOnly;
	    constructor(raw?: Float32Array, offset?: number);
	    /**
	     * 使用数值创建
	     * 推荐使用这种方式代替new Vector3
	     *
	     * @static
	     * @param {number} x x
	     * @param {number} y y
	     * @param {number} z z
	     * @returns {Vector3} 创建出来的向量
	     * @memberof Vector3
	     */
	    static createFromNumber(x: number, y: number, z: number): Vector3;
	    /**
	     * 使用一个数组创建
	     * 此操作会拷贝一份数组
	     *
	     * @static
	     * @param {number[]} array 数据源，长度必须为3，否则会抛出异常
	     * @returns {Vector3} 创建出来的向量
	     * @memberof Vector3
	     */
	    static createFromArray(array: number[]): Vector3;
	    /**
	     * 使用某个已有的typedArray创建
	     * 此操作不会拷贝数据，而是在原来的内存区域上操作
	     *
	     * @static
	     * @param {Float32Array} array 数据源
	     * @param {number} [offset=0] 数据源中的偏移
	     * @returns {Vector3}
	     * @memberof Vector3
	     */
	    static createFromTypedArray(array: Float32Array, offset?: number): Vector3;
	    /**
	     * 使用四元数进行向量旋转
	     *
	     * @static
	     * @param {V3ReadOnly} source 源向量
	     * @param {QuatReadOnly} rotation 用于旋转的四元数
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    static transformQuat(source: V3ReadOnly, rotation: QuatReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 返回向量数据
	     *
	     * @returns {number[]} 矩阵数据，以JSArray返回
	     * @memberof Vector3
	     */
	    toArray(): number[];
	    /**
	     * 判断与目标向量的值是否相等
	     *
	     * @param {V3ReadOnly} v 目标向量
	     * @returns {boolean} 是否相等，这里误差小于10^-6视为相等
	     * @memberof Vector3
	     */
	    equal(v: V3ReadOnly): boolean;
	    /**
	     * 拷贝目标向量的值到该向量
	     *
	     * @param {V3ReadOnly} val 目标向量
	     * @returns {Vector3} 自身
	     * @memberof Vector3
	     */
	    set(v: V3ReadOnly): Vector3;
	    /**
	     * 设置向量的值
	     *
	     * @param {number} x x
	     * @param {number} y y
	     * @param {number} z z
	     * @returns {Vector3} 自身
	     * @memberof Vector3
	     */
	    setValue(x: number, y: number, z: number): Vector3;
	    /**
	     * 向量加法
	     *
	     * @param {V3ReadOnly} v 目标向量
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    add(v: V3ReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 向量减法
	     *
	     * @param {V3ReadOnly} v 目标向量
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    sub(v: V3ReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 向量叉乘
	     *
	     * @param {V3ReadOnly} v 目标向量
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    cross(v: V3ReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 向量归一化
	     *
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    normalize(dst?: Vector3): Vector3;
	    /**
	     * 向量缩放
	     *
	     * @param {number} f 缩放比
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    scale(f: number, dst?: Vector3): Vector3;
	    /**
	     * 向量缩放
	     *
	     * @param {number} x x缩放比
	     * @param {number} y y缩放比
	     * @param {number} z z缩放比
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    scaleXYZ(x: number, y: number, z: number, dst?: Vector3): Vector3;
	    /**
	     * 在该向量与目标向量之间计算插值
	     *
	     * @param {V3ReadOnly} v 目标向量
	     * @param {number} f 插值系数
	     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
	     * @returns {Vector3} 计算结果
	     * @memberof Vector3
	     */
	    lerp(v: V3ReadOnly, f: number, dst?: Vector3): Vector3;
	    project(camera: any): Vector3;
	    unproject(camera: any): Vector3;
	    /**
	     * 取反
	     * @returns
	     */
	    negate(): this;
	    /**
	     * 向量点乘
	     *
	     * @param {V3ReadOnly} v 目标向量
	     * @returns {number} 计算结果
	     * @memberof Vector3
	     */
	    dot(v: V3ReadOnly): number;
	    /**
	     * 向量的模
	     *
	     * @returns {number} 计算结果
	     * @memberof Vector3
	     */
	    length(): number;
	    /**
	     * 拷贝该向量
	     *
	     * @returns {Vector3} 拷贝出来的对象
	     * @memberof Vector3
	     */
	    clone(): Vector3;
	    /**
	     * 是否为零向量
	     *
	     * @returns {boolean}
	     * @memberof Vector3
	     */
	    isZero(): boolean;
	    /**
	     * 获取到目标点的距离
	     *
	     * @param {V3ReadOnly} p 目标点
	     * @returns {number} 计算结果
	     * @memberof Vector3
	     */
	    distanceTo(p: V3ReadOnly): number;
	    /**
	     * 获取到目标点的角度
	     *
	     * @param {V3ReadOnly} location 目标点
	     * @returns {number} 计算结果
	     * @memberof Vector3
	     */
	    angleTo(location: V3ReadOnly, dst?: Vector3): Vector3;
	    applyQuaternion(q: QuatReadOnly): this;
	    /**
	     * created by shanexyzhou
	     * 从物理引擎内的RawVec3f生成Vector3
	     */
	    static fromPhysics(v: phys3D.RawVec3f): Vector3;
	    fromPhysics(v: phys3D.RawVec3f): Vector3;
	    static clearPhysicsPool(): void;
	    /**
	     * created by shanexyzhou
	     * 生成物理引擎内的RawVec3f
	     */
	    toPhysics(): Nullable<phys3D.RawVec3f>;
	}
	export class Vector3_READONLY extends Vector3 {
	    get x(): number;
	    set x(v: number);
	    get y(): number;
	    set y(v: number);
	    get z(): number;
	    set z(v: number);
	    constructor(array?: Float32Array, offset?: number);
	    set(): this;
	    setValue(): this;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/settings' {
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	export const BaseSettings: {
	    TexturePackingWidth: number;
	    TexturePackingHeight: number;
	    designWidth: number;
	    designHeight: number;
	    renderWidth: number;
	    renderHeight: number;
	    enableCatchError: boolean;
	};
	export enum AdaptationType {
	    Auto = 0,
	    FillWidth = 1,
	    FillHeight = 2
	}
	export class Settings {
	    get screenWidth(): number;
	    get screenHeight(): number;
	    get renderScale(): number;
	    get enableCatchError(): boolean;
	    set enableCatchError(val: boolean);
	    get designWidth(): number;
	    set designWidth(val: number);
	    get designHeight(): number;
	    set designHeight(val: number);
	    get baseURL(): string;
	    set baseURL(val: string);
	    get renderWidth(): number;
	    set renderWidth(val: number);
	    get renderHeight(): number;
	    set renderHeight(val: number);
	    get aspect(): number;
	    get uiScale(): number;
	    get setRenderWidth(): number;
	    get setRenderHeight(): number;
	    get gravity(): Vector3;
	    get fixedDeltaTime(): number;
	    get collisionMatrix(): string;
	    /**
	     * 微信调试版本和特殊的工具版本可以使用物理的pvd调试能力
	     * @typedef {phys3D.physicsDebugConfig}
	     *
	     */
	    get physicsDebugConfig(): phys3D.physicsDebugConfig | null;
	    get cacheDlimiter(): string;
	    get globalHTTPRetry(): number;
	    get cacheSizeLimit(): number | undefined;
	    get useEngineSubcontext(): boolean;
	    get mainScreenMSAA(): boolean;
	    workerPath?: string;
	    maxWorkerCount: number;
	    workerTimeout: number;
	    constructor();
	    setScreenSize(width: number, height: number): void;
	    setRenderSize(width: number, height: number): void;
	} const settings: Settings;
	export default settings;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/crossContextDataBus' {
	/**
	 * 跨域数据总线。
	 */
	export interface ICrossContextDataBus {
	    /**
	     * 从主域向子域发送消息。
	     * 相同`type`的数据将被合并为一个数组。
	     */
	    send(type: string, data: any): void;
	    /**
	     * 在子域监听主域发来的消息。
	     * 相同`type`的数据将被合并为一个数组。
	     */
	    addReceiver(type: string, handler: (dataList: any[]) => void): void;
	    /**
	     * 在子域移除一个监听器。
	     */
	    removeReceiver(type: string, handler: (dataList: any[]) => void): void;
	}
	/**
	 * 注意，此处不会序列化而是直接传递数据，不要传用户的对象，不要暴露出去！！！！
	 */
	export const engineCrossContextDataBus: ICrossContextDataBus;
	export const userCrossContextDataBus: ICrossContextDataBus;
	export function flush(): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture';
	/**
	 * RenderTexture构造参数。
	 */
	export interface IRenderTextureOptions {
	    /**
	     * 是否是跨域共享纹理。
	     */
	    isShared?: boolean;
	    /**
	     * 若是跨域共享纹理，主域和子域的id需要对应。
	     */
	    uuid?: string;
	    /**
	     * 宽。
	     */
	    width: number;
	    /**
	     * 高。
	     */
	    height: number;
	    /**
	     * @default 1
	     */
	    needSampleCount?: number;
	    /**
	     * 颜色纹理配置。
	     * 目前只支持一个Color输出！
	     */
	    colors?: Kanata.ITextureOptions[];
	    /**
	     * 深度模板纹理配置。
	     */
	    depthStencil?: {
	        format: Kanata.ETextureFormat.Depth_High | Kanata.ETextureFormat.Depth_Low | Kanata.ETextureFormat.Depth_Stencil;
	        needRead?: boolean;
	    };
	}
	/**
	 * RenderTexture。
	 * @export
	 * @class RenderTexture
	 */
	export default class RenderTexture extends Texture {
	    static IS(obj: any): obj is RenderTexture;
	    isRenderTexture: boolean;
	    get colors(): Kanata.Texture[];
	    get depthStencil(): Kanata.Texture | undefined;
	    get needSampleCount(): any;
	    get isShared(): boolean;
	    set isShared(value: boolean);
	    /**
	     * 贴图高。
	     */
	    get height(): number;
	    set height(value: number);
	    /**
	     * 贴图宽。
	     */
	    get width(): number;
	    set width(value: number);
	    /**
	     * 创建RenderTexture实例。
	     */
	    constructor(options: IRenderTextureOptions);
	    /**
	     * 销毁RenderTexture。
	     */
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/postProcessAsset' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	/**
	 * 后处理资源，可以使用${name}内置的*后处理步骤*。
	 *
	 * 可以应用在相机上。
	 */
	export default class PostProcessAsset extends BaseResource {
	    /**
	     * 后处理是否采用高动态范围。
	     */
	    get hdr(): boolean;
	    set hdr(v: boolean);
	    constructor();
	    clear(): void;
	    /**
	     * 删除所有名字为`name`的*后处理步骤*。
	     *
	     * \**不提供`name`的话会删除最后加入的那**一个**。*
	     */
	    remove(name?: string): void;
	    /**
	     * 在最后一步添加名字为`name`的抗锯齿步骤。如果`name`已存在，则会替换对应步骤。
	     */
	    addFXAA(name?: string): void;
	    /**
	     * 在最后一步添加名字为`name`的色调映射步骤。如果`name`已存在，则会替换对应步骤。
	     *
	     * 色调映射的公式大致如下：
	     * ![rgb'=(1-e^{-rgb^{2.2}\cdot exposure})^{\frac{1}{2.2}}](https://latex.codecogs.com/svg.latex?rgb'=(1-e^{-rgb^{2.2}\cdot&space;exposure})^{\frac{1}{2.2}})
	     *
	     * @param exposure 曝光度。
	     */
	    addToneMapping(name?: string, exposure?: number): void;
	    /**
	     * 在最后一步添加名字为`name`的泛光步骤。如果`name`已存在，则会替换对应步骤。
	     * @param radius 泛光范围半径（像素），设置得太大会影响性能。
	     * @param intensity 泛光强度。
	     * @param threshold 泛光阈值，亮度超过该值的像素点才会向周围泛光。
	     * @param softThreshold 泛光软阈值，让亮度略低于`threshold`的像素点也能产生一定程度上的泛光。
	     */
	    addBloom(name?: string, radius?: number, intensity?: number, threshold?: number, softThreshold?: number): void;
	    /**
	     * 在最后一步添加名字为`name`的高斯模糊步骤。如果`name`已存在，则会替换对应步骤。
	     * @param radius 模糊半径（像素），设置得太大会影响性能。
	     */
	    addGaussianBlur(name?: string, radius?: number): void;
	    addCustomEffect(name?: string, type?: string, options?: object): void;
	    disableStep(name: string): void;
	    enableStep(name: string): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera' {
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import Rect from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/rect';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { M4ReadOnly, V3ReadOnly } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/types';
	import Screen from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	import PostProcessAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/postProcessAsset';
	/**
	 * 相机投影类型。
	 */
	export enum CameraProjectionType {
	    /**
	     * 透视
	     */
	    Perspective = 0,
	    /**
	     * 正交
	     */
	    Orthographic = 1
	}
	/**
	 * 相机纵横比模式。
	 */
	export enum CameraAspectType {
	    /**
	     * 根据屏幕宽高自动适配
	     */
	    Auto = 0,
	    /**
	     * 根据相机中的设置
	     */
	    Custom = 1,
	    /**
	     * 等同于Custom
	     */
	    Setable = 1
	}
	export enum ClearFlag {
	    Color = 1,
	    Depth = 2,
	    Stencil = 4
	}
	/**
	 * @export
	 * @abstract
	 * @class BaseCamera
	 * @extends {Component}
	 */
	export default abstract class BaseCamera extends Component {
	    /**
	     * 宽高比模式
	     *
	     * @static
	     * @memberof BaseCamera
	     */
	    static readonly AspectType: Readonly<typeof CameraAspectType>;
	    /**
	     * 投影类型
	     *
	     * @static
	     * @memberof BaseCamera
	     */
	    static readonly ProjectionType: Readonly<typeof CameraProjectionType>;
	    /**
	     * 决定是否要添加到renderSystem从而进入RenderGraph流程，必须在onEnable前设置！
	     */
	    forDebug: boolean;
	    get editorRenderTarget(): RenderTexture | undefined;
	    get renderTarget(): RenderTexture | Screen | undefined;
	    set renderTarget(rt: RenderTexture | Screen | undefined);
	    /**
	     * 渲染的View。
	     */
	    get view(): Kanata.View | undefined;
	    /**
	     * @deprecate
	     * 请使用`renderTarget`。
	     */
	    get targetTexture(): RenderTexture | Screen | undefined;
	    set targetTexture(rt: RenderTexture | Screen | undefined);
	    /**
	     * 相机深度，决定了相机的渲染顺序，深度小的先被渲染。
	     */
	    get depth(): number;
	    set depth(val: number);
	    /**
	     * 剔除掩码，有效值：0~0x3fffffff。最高两位为工具预留。
	     * 剔除时将使用该值与MeshRenderer的cullingMask做按位与，有值时才渲染。
	     */
	    get cullingMask(): number;
	    set cullingMask(cullingMask: number);
	    get clearFlag(): ClearFlag;
	    /**
	     * 清除颜色缓冲的值。
	     * 暂不支持clearColor.r = 255 这种写法。
	     */
	    get clearColor(): Color;
	    set clearColor(val: Color);
	    /**
	     * 清除深度缓冲的值，范围0-1。
	     */
	    get clearDepth(): number;
	    set clearDepth(val: number);
	    /**
	     * 清除模板缓冲的值，范围0-255。
	     */
	    get clearStencil(): number;
	    set clearStencil(val: number);
	    /**
	     * 是否要清除颜色。
	     */
	    get isClearColor(): boolean;
	    set isClearColor(val: boolean);
	    /**
	     * 是否清除深度缓冲。
	     */
	    get isClearDepth(): boolean;
	    set isClearDepth(val: boolean);
	    /**
	     * 是否清除模板缓冲。
	     */
	    get isClearStencil(): boolean;
	    set isClearStencil(val: boolean);
	    /**
	     * 视野大小，用角度表示，透视模式专用。
	     */
	    get fieldOfView(): number;
	    set fieldOfView(val: number);
	    /**
	     * 视野大小，用弧度表示，透视模式专用。
	     */
	    get fieldOfViewRadians(): number;
	    set fieldOfViewRadians(val: number);
	    /**
	     * 正交相机视野高的一半。
	     */
	    get orthographicSize(): number;
	    set orthographicSize(val: number);
	    /**
	     * 相机宽高比模式。
	     */
	    get aspectType(): CameraAspectType;
	    set aspectType(val: CameraAspectType);
	    /**
	     * 相机宽高比。
	     * 仅当CameraAspectType = Custom 时可设置。
	     */
	    get aspect(): number;
	    set aspect(val: number);
	    /**
	     * 投影类型。
	     */
	    get projectionType(): CameraProjectionType;
	    set projectionType(val: CameraProjectionType);
	    /**
	     * 相机近剪裁面。
	     */
	    get nearClipPlane(): number;
	    set nearClipPlane(val: number);
	    /**
	     * 相机远剪裁面。
	     */
	    get farClipPlane(): number;
	    set farClipPlane(val: number);
	    /**
	     * 每个layer自己的远平面，如果为0则使用相机的。
	     */
	    get layerCullDistances(): number[];
	    set layerCullDistances(v: number[]);
	    /**
	     * 投影矩阵。
	     */
	    get projectionMatrix(): M4ReadOnly;
	    /**
	     * 观察矩阵。
	     */
	    get viewMatrix(): M4ReadOnly;
	    /**
	     * 观察矩阵的逆。
	     */
	    get viewMatrixInverse(): M4ReadOnly;
	    set postProcess(val: PostProcessAsset | undefined);
	    get postProcess(): PostProcessAsset | undefined;
	    constructor(entity: Entity, isUI?: boolean);
	    /**
	     * 使用此相机进行剔除。
	     *
	     * @param cullResult 要存储剔除结果的列表。
	     * @param lightMode 作为剔除依据的光照模式。
	     */
	    cull(cullResult: Kanata.ScalableList, lightMode: string): void;
	    /**
	     * 使用此相机的View进行RenderTarget的清屏。
	     */
	    clear(): void;
	    /**
	     * 使用此相机进行绘制。
	     *
	     * @param renderList 要绘制的渲染列表。
	     * @param lightMode 作为绘制依据的光照模式。
	     */
	    draw(renderList: Kanata.ScalableList, lightMode: string): void;
	    /**
	     * 将世界坐标系位置转换到齐次裁剪空间。
	     */
	    convertWorldPositionToClip(worldPos: V3ReadOnly, dst?: Vector3): Vector3;
	    /**
	     * 将齐次裁剪空间转换到世界坐标系位置。
	     */
	    convertClipPositionToWorld(clipPos: V3ReadOnly, dst?: Vector3): Vector3;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode' {
	/**
	 * RGNode.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 1/13/2021, 8:29:55 PM
	 */
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import BaseCamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/baseCamera';
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	import Screen from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen';
	import BaseLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/baseLight'; type RenderGraph = import('!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph').default; type Game = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/game').default; type RenderSystem = import('!!Only Export Engine Module, Cant Use Internal Module：engine/system/render').default;
	export type TRGNodeAny = RGNode<any, any, any>;
	/**
	 * RGNode支持传输的数据类型。
	 * 可扩展。
	 *
	 * @category Render
	 */
	export interface IRGData {
	    /**
	     * 空数据类型。
	     */
	    None: void;
	    /**
	     * 相机类型。
	     */
	    Camera: BaseCamera;
	    /**
	     * 渲染目标类型。
	     */
	    RenderTarget: RenderTexture | Screen;
	    /**
	     * Mesh列表，一般作为剔除节点的输出，作为渲染节点的输入。
	     */
	    MeshList: Kanata.ScalableList;
	    /**
	     * 灯光列表，一般用于ForwardAdd。
	     */
	    LightList: BaseLight[];
	}
	/**
	 * RGNode支持的节点类型。
	 */
	export enum ERGNodeType {
	    Camera = "Camera",
	    Clear = "Clear",
	    Cull = "Cull",
	    Render = "Render",
	    Script = "Script"
	}
	/**
	 * 渲染节点基类。
	 */
	export default abstract class RGNode<TInputs extends {
	    [key: string]: keyof IRGData;
	}, TOutput extends keyof IRGData, IOptions> {
	    /**
	     * 节点输入的数据类型。
	     */
	    abstract inputTypes: TInputs;
	    /**
	     * 节点输出的数据类型。
	     */
	    abstract outputType: TOutput;
	    /**
	     * 节点的初始化配置参数。
	     */
	    get options(): IOptions;
	    /**
	     * 节点名字。
	     */
	    get name(): string;
	    /**
	     * 节点id。
	     */
	    get id(): number;
	    /**
	     * 获取当前游戏实例。
	     */
	    get game(): Game;
	    /**
	     * 获取当前节点输出。
	     */
	    get output(): IRGData[TOutput] | undefined;
	    /**
	     * 不要直接调用，请使用`renderGraph.createNode`方法。
	     */
	    constructor(parent: RenderGraph,id: number,name: string,options: IOptions);
	    /**
	     * 节点初始化后的回调。
	     */
	    onInit(options: IOptions): void;
	    /**
	     * 获取某个节点的输入。
	     */
	    getInput<TKey extends keyof TInputs>(key: TKey): IRGData[TInputs[TKey]];
	    /**
	     * 重置节点状态，清空输入，一般用于可缓存的节点优化。
	     */
	    reset(): void;
	    /**
	     * 节点在真正被第一次使用时的回调。
	     */
	    onActive(context: RenderSystem, options: IOptions): void;
	    /**
	     * 节点在每帧执行时的回调。
	     */
	    onExecute(context: RenderSystem, options: IOptions): void;
	    /**
	     * 节点在被图中移除时的回调。
	     */
	    onDisable(context: RenderSystem, options: IOptions): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes/postProcessing' {
	/**
	 * postProcessing.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 5/24/2021, 3:06:37 PM
	 */
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import RGNode, { ERGNodeType, IRGData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode';
	import RenderSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render';
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material';
	import Screen from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen';
	export enum EBuiltinPostProcess {
	    FXAA = 0,
	    BLIT = 1,
	    BLOOM = 2,
	    HDR = 3,
	    DOF = 4,
	    BLUR = 5
	}
	export const ppEffectMap: {
	    0: string;
	    1: string;
	    2: string;
	    3: string;
	    4: string;
	    5: string;
	};
	/**
	 * 后处理过程中每个Pass的数据。
	 *
	 * @category Render
	 */
	export interface IPostProcessPassData {
	    effect: Effect;
	    renderTarget: RenderTexture | Screen;
	    lightMode: string;
	}
	/**
	 * 后处理节点通用参数。
	 *
	 * @category Render
	 */
	export interface IRGPostProcessNodeOptions {
	    renderToScreen?: boolean;
	    hdr?: boolean;
	}
	export const RGPostProcessNodeTable: {
	    [key: string]: new (...args: any) => RGPostProcessNode<any, any>;
	};
	/**
	 * 后处理节点基类。
	 *
	 * @category Render
	 */
	export abstract class RGPostProcessNode<TInput extends {
	    [key: string]: keyof IRGData;
	} = {}, TOptions extends IRGPostProcessNodeOptions = IRGPostProcessNodeOptions> extends RGNode<TInput, 'RenderTarget', TOptions> {
	    /**
	     * 装饰器，用于像后处理资源系统注册后处理类型`type`和实现节点的绑定关系。
	     * 使用如：
	     *
	     * ```ts
	     * @RGPostProcessNode.serialize('BLIT')
	     * export class RGBlitPostProcessNode extends RGPostProcessNode {
	     * ......
	     * }
	     * ```
	     */
	    static serialize(type: string): (clz: new (...args: any) => RGPostProcessNode<any, any>) => void;
	    type: ERGNodeType;
	    outputType: "RenderTarget";
	    /**
	     * 返回需要使用的所有Pass，将会按顺序执行。
	     */
	    abstract onGetPasses(context: RenderSystem, options: TOptions): IPostProcessPassData[];
	    /**
	     * 可用于创建需要使用的所有初始化数据。
	     */
	    onCreatedData(context: RenderSystem, materials: Material[], passes: IPostProcessPassData[], options: TOptions): void;
	    /**
	     * 可用于每帧更新数据，比如Uniform。
	     */
	    onFillData(context: RenderSystem, materials: Material[], passes: IPostProcessPassData[], options: TOptions): void;
	    /**
	     * @hidden
	     */
	    getEffectByName(name: string): Effect;
	    /**
	     * @hidden
	     */
	    onActive(context: RenderSystem, options: TOptions): void;
	    /**
	     * @hidden
	     */
	    onExecute(context: RenderSystem, options: TOptions): void;
	    /**
	     * @hidden
	     */
	    onDisable(): void;
	}
	interface IRGBlitPostProcessNodeOptions extends IRGPostProcessNodeOptions {
	    dstTex?: RenderTexture | Screen;
	}
	/**
	 * 拷贝后处理节点。
	 *
	 * @category Render
	 */
	export class RGBlitPostProcessNode extends RGPostProcessNode<{
	    sourceTex: 'RenderTarget';
	}, IRGBlitPostProcessNodeOptions> {
	    inputTypes: {
	        sourceTex: "RenderTarget";
	    };
	    onGetPasses(context: RenderSystem, options: IRGBlitPostProcessNodeOptions): IPostProcessPassData[];
	}
	/**
	 * 深度场后处理节点。
	 *
	 * @category Render
	 */
	export class RGDofPostProcessNode extends RGPostProcessNode<{
	    sourceTex: 'RenderTarget';
	    depthTex: 'RenderTarget';
	}> {
	    inputTypes: {
	        sourceTex: "RenderTarget";
	        depthTex: "RenderTarget";
	    };
	    onGetPasses(context: RenderSystem, options: IRGPostProcessNodeOptions): IPostProcessPassData[];
	    onFillData(context: RenderSystem, materials: Material[]): void;
	}
	export const HDR_PIXEL_FORMAT: Kanata.ETextureFormat;
	/**
	 * Tone mapping后处理节点参数。
	 *
	 * @category Render
	 */
	export interface IRGHDRPostProcessNodeOptions extends IRGPostProcessNodeOptions {
	    exposure?: number;
	}
	/**
	 * Tone mapping后处理节点。
	 *
	 * @category Render
	 */
	export class RGHDRPostProcessNode extends RGPostProcessNode<{
	    sourceTex: 'RenderTarget';
	}, IRGHDRPostProcessNodeOptions> {
	    inputTypes: {
	        sourceTex: "RenderTarget";
	    };
	    onGetPasses(context: RenderSystem, options: IRGHDRPostProcessNodeOptions): IPostProcessPassData[];
	    onFillData(context: RenderSystem, materials: Material[], passes: IPostProcessPassData[], options: IRGHDRPostProcessNodeOptions): void;
	}
	/**
	 * 快速近似抗锯齿节点。
	 */
	export class RGFXAAPostProcessNode extends RGPostProcessNode<{
	    sourceTex: 'RenderTarget';
	}> {
	    inputTypes: {
	        sourceTex: "RenderTarget";
	    };
	    onGetPasses(context: RenderSystem, options: IRGPostProcessNodeOptions): IPostProcessPassData[];
	}
	/**
	 * Bloom后处理节点参数。
	 *
	 * @category Render
	 */
	export interface IRGBloomPostProcessNodeOptions extends IRGPostProcessNodeOptions {
	    threshold?: number;
	    softThreshold?: number;
	    radius?: number;
	    intensity?: number;
	}
	/**
	 * Bloom后处理节点。
	 *
	 * @category Render
	 */
	export class RGBloomPostProcessNode extends RGPostProcessNode<{
	    sourceTex: 'RenderTarget';
	}, IRGBloomPostProcessNodeOptions> {
	    /**
	     * 采样间隔，每`sampleRate`个像素点进行一次采样。
	     *
	     * 越低的采样间隔能造成越好的效果，必须设置成**2的自然数次幂**。
	     *
	     * \**需要在游戏初始化时进行设置才能生效。*
	     */
	    static sampleRate: number;
	    inputTypes: {
	        sourceTex: "RenderTarget";
	    };
	    onGetPasses(context: RenderSystem, options: IRGBloomPostProcessNodeOptions): IPostProcessPassData[];
	    onCreatedData(context: RenderSystem, materials: Material[], passes: IPostProcessPassData[], options: IRGBloomPostProcessNodeOptions): void;
	    onFillData(context: RenderSystem, materials: Material[], passes: IPostProcessPassData[], options: IRGBloomPostProcessNodeOptions): void;
	}
	/**
	 * Bloom后处理节点参数。
	 *
	 * @category Render
	 */
	export interface IRGGaussianBlurPostProcessNodeOptions extends IRGPostProcessNodeOptions {
	    radius?: number;
	}
	/**
	 * GaussianBlur后处理节点。
	 *
	 * @category Render
	 */
	export class RGGaussianBlurPostProcessNode extends RGPostProcessNode<{
	    sourceTex: 'RenderTarget';
	}, IRGGaussianBlurPostProcessNodeOptions> {
	    /**
	     * 采样间隔，每`sampleRate`个像素点进行一次采样。
	     *
	     * 越低的采样间隔能造成越好的效果，必须设置成**2的自然数次幂**。
	     *
	     * \**需要在游戏初始化时进行设置才能生效。*
	     */
	    static sampleRate: number;
	    inputTypes: {
	        sourceTex: "RenderTarget";
	    };
	    onGetPasses(context: RenderSystem, options: IRGGaussianBlurPostProcessNodeOptions): IPostProcessPassData[];
	    onCreatedData(context: RenderSystem, materials: Material[], passes: IPostProcessPassData[], options: IRGGaussianBlurPostProcessNodeOptions): void;
	    onFillData(context: RenderSystem, materials: Material[], passes: IPostProcessPassData[], options: IRGGaussianBlurPostProcessNodeOptions): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import type { DeepImmutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	interface IAvatarAsset {
	    name: string;
	    exposedPaths?: number[];
	    paths: string[];
	    buffer: string;
	    optimized: boolean;
	}
	export interface IAnimationEventInfo {
	    frameId: number;
	    functionName: string;
	    numberParameter?: number;
	    stringParameter?: string;
	    objectReferenceParameter?: any;
	}
	export interface IMetaAssetInfo {
	    propsIndex: number;
	    curveContentList: Array<{
	        frameId: number;
	        value: string | null;
	    }>;
	}
	export type AvatarAsset = DeepImmutable<IAvatarAsset>;
	interface IAvatarMaskAsset {
	    name: string;
	    paths: {
	        [key: string]: number;
	    };
	}
	export type AvatarMaskAsset = DeepImmutable<IAvatarMaskAsset>;
	/**
	 * 动画片段的播放模式，适用于genetic animation组件。
	 * @export
	 * @enum {number}
	 */
	export enum WrapMode {
	    /**
	     * 同Once。
	     */
	    Default = 0,
	    /**
	     * 当动画片段播放到尾部时，动画片段会自动停止，并把时间重置回动画片段的起始时间。
	     */
	    Once = 1,
	    /**
	     * 当动画片段播放到尾部时，动画片段会重置回动画片段的起始时间然后继续播放。
	     */
	    Loop = 2,
	    /**
	     * 当动画片段播放到尾部时，动画片段会从动画片段的终止时间反向继续播放，当再次回到动画片段的起始时间时又会继续正向播放，如此不断循环。
	     */
	    PingPong = 4,
	    /**
	     * 当动画片段播放到尾部时，动画片段会一直停留在动画片段的终止时间（动画并不会停止）。
	     */
	    ClampForever = 8
	}
	interface IAnimationClipAsset {
	    file: {
	        boneSrc?: string;
	        metaSrc?: string;
	    };
	    metaAssets?: Array<IMetaAssetInfo>;
	    eventList: IAnimationEventInfo[];
	    data: {
	        name?: string;
	        frameRate: number;
	        frameLength: number;
	        paths?: string[];
	        props?: Array<[number, string]>;
	        wrapMode?: WrapMode;
	        startTime?: number;
	        stopTime?: number;
	        loopTime?: boolean;
	        cycleOffset?: number;
	    };
	    resourceid?: string;
	}
	export type AnimationClipAsset = DeepImmutable<IAnimationClipAsset>;
	interface IAudioResourceClipConfig {
	    file: {
	        src: string;
	    };
	    data: {
	        length: number;
	        preloadAudioData: boolean;
	    };
	    editorInfo: {
	        name: string;
	    };
	}
	export type AudioClipResourceConfig = DeepImmutable<IAudioResourceClipConfig>;
	export interface ISampleInfo<T> {
	    pathIndex: number;
	    type: T;
	    keyframeCount: number;
	}
	export interface IKeyframeContent {
	    frameId: number;
	    value: number;
	    inTangent: number;
	    outTangent: number;
	}
	export interface IAnimationClipSrcData {
	    keyframeData: {
	        bone: {
	            sampleList: Array<ISampleInfo<number>>;
	            contentList: IKeyframeContent[];
	        };
	        meta: {
	            sampleList: Array<ISampleInfo<string>>;
	            contentList: IKeyframeContent[];
	        };
	        frameRate: number;
	        totalFrameCount: number;
	    };
	    eventList: IAnimationEventInfo[];
	    data: {
	        name?: string;
	        paths: string[];
	        wrapMode: WrapMode;
	        startTime: number;
	        stopTime: number;
	        loopTime: boolean;
	        cycleOffset: number;
	    };
	}
	interface IES100Reflection {
	    attributes: Array<{
	        key: number;
	        type: Kanata.EVertexFormat;
	        count?: number;
	    }>;
	    uniforms: Array<{
	        key: number;
	        type: Kanata.EUniformType;
	        count?: number;
	    }>;
	    images: Array<{
	        key: number;
	        type: number;
	        count?: number;
	    }>;
	}
	export enum EnumPipelineType {
	    ForwardBase = 0,
	    ForwardAdd = 1,
	    ShadowCaster = 2,
	    PostProcess = 3,
	    Skybox = 4,
	    ImageBasedLighting = 5
	}
	export type PipelineTypeString = Exclude<keyof typeof EnumPipelineType, number>;
	interface IEffectAsset {
	    version: number;
	    name: string;
	    properties?: Array<{
	        key: number;
	        type: Kanata.EUniformType;
	        default: [number];
	    } | {
	        key: number;
	        type: Kanata.EUniformType;
	        default: [number, number];
	    } | {
	        key: number;
	        type: Kanata.EUniformType;
	        default: [number, number, number];
	    } | {
	        key: number;
	        type: Kanata.EUniformType;
	        default: [number, number, number, number];
	    }>;
	    images?: Array<{
	        key: number;
	        type: number;
	        default: string;
	    }>;
	    defaultRenderQueue: number;
	    passes: Array<{
	        lightMode: PipelineTypeString;
	        macros: {
	            [key: string]: number;
	        };
	        variants: {
	            [key: number]: number;
	        };
	        useMaterialRenderStates: boolean;
	        renderStates?: IMaterialPassRenderStates;
	    }>;
	    variants: Array<{
	        shaders: number[];
	        reflection: IES100Reflection;
	    }>;
	    shaders: string[];
	    strings: string[];
	    resourceid?: string;
	}
	export type EffectAsset = DeepImmutable<IEffectAsset>;
	interface IVariantResourceDescription {
	    file: {
	        src: {
	            es20: [string, string];
	            vulkan?: [string, string];
	            metal?: [string, string];
	        };
	    };
	}
	export type VariantResourceDescription = DeepImmutable<IVariantResourceDescription>;
	interface IFontResourceDescription {
	    file: {
	        src: string;
	    };
	}
	export type FontResourceDescription = DeepImmutable<IFontResourceDescription>;
	interface IRawResourceDescription {
	    file: {
	        src: string;
	    };
	}
	export type RawResourceDescription = DeepImmutable<IRawResourceDescription>;
	interface IAtlasResourceDescription {
	    spriteframes: Array<{
	        filename: string;
	        spriteframe: string;
	    }>;
	}
	export type AtlasResourceDescription = DeepImmutable<IAtlasResourceDescription>;
	interface ISpriteframeResourceDescription {
	    texture: string;
	    rect: [number, number, number, number];
	    trim?: [number, number, number, number];
	    slicedRect?: [number, number, number, number];
	    resourceid?: string;
	}
	export type SpriteframeResourceDescription = DeepImmutable<ISpriteframeResourceDescription>;
	interface IBitmapFontResourceDescription {
	    lineHeight: number;
	    fontSize: number;
	    width: number;
	    height: number;
	    texture: string;
	    allowChangeFontSize: boolean;
	    allowChangeFontColor: boolean;
	    frames: {
	        [charCode: string]: {
	            x: number;
	            y: number;
	            offsetX: number;
	            offsetY: number;
	            width: number;
	            height: number;
	        };
	    };
	}
	export type BitmapFontResourceDescription = DeepImmutable<IBitmapFontResourceDescription>;
	interface ITextureResourceDescription {
	    data: {
	        width: number;
	        height: number;
	        useMipmap: boolean;
	        mipmap: number;
	        minLod?: number;
	        maxLod?: number;
	        sRGB: boolean;
	        wrapU: number;
	        wrapV: number;
	        filterMode: number;
	        pixelFormat: number;
	        anisoLevel: number;
	    };
	    file?: {
	        src: string;
	    };
	    resourceid?: string;
	}
	export type TextureResourceDescription = DeepImmutable<ITextureResourceDescription>;
	interface IScriptableAssetResourceDescription {
	    content: {
	        [key: string]: any;
	    };
	    meta: {
	        type: string;
	    };
	}
	export type ScriptableAssetResourceDescription = DeepImmutable<IScriptableAssetResourceDescription>;
	interface ITap {
	    id: number;
	    left: number;
	    top: number;
	    width: number;
	    height: number;
	    viewModules: Array<string>;
	    selected: number;
	}
	export type Tap = DeepImmutable<ITap>;
	interface IPopup {
	}
	export type Popup = DeepImmutable<IPopup>;
	interface IIDELayoutResourceDescription {
	    windowWidth: number;
	    windowHeight: number;
	    taps: Array<Tap>;
	    popups: Array<Popup>;
	}
	export type IDELayoutResourceDescription = IIDELayoutResourceDescription;
	interface ITutorialSectionItem {
	    order: number;
	    section: string;
	}
	export type TutorialSectionItem = DeepImmutable<ITutorialSectionItem>;
	interface ITutorialHooks {
	    script: string;
	    callback: string;
	    args?: {
	        [key: string]: any;
	    };
	}
	export type TutorialHooks = DeepImmutable<ITutorialHooks>; enum ILoadIDELayoutMode {
	    compatible = 0,
	    incompatible = 1
	}
	export type LoadIDELayoutMode = DeepImmutable<ILoadIDELayoutMode>;
	interface ITutorialResourceDescription {
	    version: number;
	    title: string;
	    subTitle: string;
	    description: string;
	    autoComplete: boolean;
	    sections: Array<ITutorialSectionItem>;
	    layout?: string;
	    layoutMode?: ILoadIDELayoutMode;
	    welcomePage?: string;
	    onEnter?: ITutorialHooks;
	    onExit?: ITutorialHooks;
	}
	export type TutorialResourceDescription = DeepImmutable<ITutorialResourceDescription>;
	interface ITutorialPageItem {
	    page: string;
	}
	interface ITutorialSectionResourceDescription {
	    version: number;
	    title: string;
	    description: string;
	    url?: string;
	    image?: string;
	    autoComplete: boolean;
	    pages: Array<ITutorialPageItem>;
	    layout?: string;
	    layoutMode?: ILoadIDELayoutMode;
	    welcomePage?: string;
	    onEnter?: ITutorialHooks;
	    onExit?: ITutorialHooks;
	}
	export type TutorialSectionResourceDescription = DeepImmutable<ITutorialSectionResourceDescription>; enum ICriteriaPassType {
	    All = 0,
	    Any = 1
	}
	export type CriteriaPassType = DeepImmutable<ICriteriaPassType>; enum IPageMediaType {
	    Image = 0,
	    Video = 1
	}
	export type PageMediaType = DeepImmutable<IPageMediaType>;
	interface ICriteria {
	    criteria: string;
	    args?: {
	        [key: string]: any;
	    };
	}
	export type Criteria = DeepImmutable<ICriteria>; enum ISelectType {
	    Window = 0,
	    View = 1
	}
	export type SelectType = DeepImmutable<ISelectType>; enum IMaskType {
	    FullUnmasked = 0,
	    BlockInteractions = 1
	}
	export type MaskType = DeepImmutable<IMaskType>; enum IControlSelectorMode {
	    cssSelector = 0,
	    Text = 1,
	    Reference = 2
	}
	export type ControlSelectorMode = DeepImmutable<IControlSelectorMode>;
	interface IViewControl {
	    selectorMode: IControlSelectorMode;
	    cssSelector?: string;
	    text?: string;
	    referenceObject?: string;
	}
	export type ViewControl = DeepImmutable<IViewControl>;
	interface IEditorTip {
	    lineStart: number;
	    lineEnd: number;
	    tipText: string;
	}
	export type EditorTip = DeepImmutable<IEditorTip>;
	interface IUnmaskedView {
	    viewType: string;
	    maskType?: IMaskType;
	    controls?: Array<ViewControl>;
	    activeFile?: string;
	    autoOpenFile?: boolean;
	    editorTips?: Array<EditorTip>;
	}
	export type UnmaskedView = IUnmaskedView;
	interface ITutorialPageResourceDescription {
	    activeWindow: string;
	    narrativeTitle: string;
	    narrativeDescription: string;
	    enableInstruction: boolean;
	    instructionTitle: string;
	    instructionDescription: string;
	    criteriaPassType: ICriteriaPassType;
	    criterias: Array<ICriteria>;
	    enableMasking: boolean;
	    unmaskedViews: Array<IUnmaskedView>;
	    nextButton: string;
	    doneButton: string;
	    autoComplete: boolean;
	    mediaType: IPageMediaType;
	    image?: string;
	    video?: string;
	    onEnter?: ITutorialHooks;
	    onExit?: ITutorialHooks;
	}
	export type TutorialPageResourceDescription = ITutorialPageResourceDescription;
	interface ITutorialWelcomeButton {
	    text: string;
	    onClick: Function;
	    color?: string;
	    bgColor?: string;
	}
	export type TutorialWelcomeButton = DeepImmutable<ITutorialWelcomeButton>; enum ITutorialWelcomeCententMode {
	    Plain = 1,
	    Markdown = 2
	}
	export type TutorialWelcomeCententMode = DeepImmutable<ITutorialWelcomeCententMode>;
	interface ITutorialWelcomeResourceDescription {
	    title: string;
	    mode: ITutorialWelcomeCententMode;
	    markdown?: string;
	    content?: string;
	    image?: HTMLImageElement | ArrayBuffer;
	    buttons: Array<ITutorialWelcomeButton>;
	}
	export type TutorialWelcomeResourceDescription = ITutorialWelcomeResourceDescription;
	interface ITextureCubeResourceDescription {
	    desc: {
	        width: number;
	        height: number;
	        useMipmap: boolean;
	        mipmap: number;
	        wrapU: number;
	        wrapV: number;
	        wrapW: number;
	        filterMode: number;
	        pixelFormat: number;
	        anisoLevel: number;
	        rgb_etc1?: number;
	        rgb_pvrtc?: number;
	        rgba_pvrtc?: number;
	        ktx_dataOffset?: number;
	        pvr_dataOffset?: number;
	    };
	    files: {
	        right: string;
	        left: string;
	        top: string;
	        bottom: string;
	        back: string;
	        front: string;
	    };
	    resourceid?: string;
	}
	export type TextureCubeResourceDescription = DeepImmutable<ITextureCubeResourceDescription>;
	export enum MeshIndiceFormat {
	    BIT16 = 1,
	    BIT32 = 2
	}
	interface IMeshResourceDescription {
	    data: {
	        vertexLayout: string;
	        vertexStart: number;
	        vertexLength: number;
	        indiceStart: number;
	        indiceLength: number;
	        indiceFormat: MeshIndiceFormat;
	        capsule: {
	            x: number;
	            y: number;
	            z: number;
	            radius: number;
	        };
	        subMeshs: Array<{
	            start: number;
	            length: number;
	        }>;
	        boundBox: {
	            center: number[];
	            size: number[];
	        };
	        releaseRawBuffer?: boolean;
	        rootBone?: string;
	        bones?: string[];
	        bonePoseStart?: number;
	        bonePoseLength?: number;
	    };
	    file: {
	        src: string;
	    };
	    resourceid?: string;
	}
	export type MeshResourceDescription = DeepImmutable<IMeshResourceDescription>;
	export type MaterialRenderStateKeys = "blendOn" | "blendOnMask" | "blendSrc" | "blendSrcMask" | "blendSrcAlpha" | "blendSrcAlphaMask" | "blendDst" | "blendDstMask" | "blendDstAlpha" | "blendDstAlphaMask" | "blendFunc" | "blendFuncMask" | "cullOn" | "cullOnMask" | "cullFace" | "cullFaceMask" | "depthWrite" | "depthWriteMask" | "depthTestOn" | "depthTestOnMask" | "depthTestComp" | "depthTestCompMask" | "stencilWriteMask" | "stencilWriteMaskMask" | "stencilTestOn" | "stencilTestOnMask" | "stencilRef" | "stencilRefMask" | "stencilReadMask" | "stencilReadMaskMask" | "stencilComp" | "stencilCompMask" | "stencilPass" | "stencilPassMask" | "stencilFail" | "stencilFailMask" | "stencilZFail" | "stencilZFailMask" | "primitiveType" | "primitiveTypeMask";
	export interface IMaterialPassRenderStates {
	    blendOn?: boolean;
	    blendOnMask?: boolean;
	    blendSrc?: Kanata.EBlendFactor;
	    blendSrcMask?: boolean;
	    blendSrcAlpha?: Kanata.EBlendFactor;
	    blendSrcAlphaMask?: boolean;
	    blendDst?: Kanata.EBlendFactor;
	    blendDstMask?: boolean;
	    blendDstAlpha?: Kanata.EBlendFactor;
	    blendDstAlphaMask?: boolean;
	    blendFunc?: Kanata.EBlendEquation;
	    blendFuncMask?: boolean;
	    cullOn?: boolean;
	    cullOnMask?: boolean;
	    cullFace?: Kanata.ECullMode;
	    cullFaceMask?: boolean;
	    depthWrite?: boolean;
	    depthWriteMask?: boolean;
	    depthTestOn?: boolean;
	    depthTestOnMask?: boolean;
	    depthTestComp?: Kanata.ECompareFunc;
	    depthTestCompMask?: boolean;
	    stencilWriteMask?: number;
	    stencilWriteMaskMask?: boolean;
	    stencilTestOn?: boolean;
	    stencilTestOnMask?: boolean;
	    stencilRef?: number;
	    stencilRefMask?: boolean;
	    stencilReadMask?: number;
	    stencilReadMaskMask?: boolean;
	    stencilComp?: Kanata.ECompareFunc;
	    stencilCompMask?: boolean;
	    stencilPass?: Kanata.EStencilOp;
	    stencilPassMask?: boolean;
	    stencilFail?: Kanata.EStencilOp;
	    stencilFailMask?: boolean;
	    stencilZFail?: Kanata.EStencilOp;
	    stencilZFailMask?: boolean;
	    primitiveType?: Kanata.EPrimitiveType;
	    primitiveTypeMask?: boolean;
	}
	interface IMaterialResourceDescription {
	    useInstance?: boolean;
	    effect: string;
	    textures?: {
	        [key: string]: string;
	    };
	    shaderParams?: {
	        [key: string]: number[];
	    };
	    renderStates?: IMaterialPassRenderStates;
	    renderQueue?: number;
	    shaderDefinations?: {
	        [key: string]: boolean;
	    };
	}
	export type MaterialResourceDescription = DeepImmutable<IMaterialResourceDescription>;
	interface IPhysicMaterialResourceDescription {
	    dynamicFriction: number;
	    name: string;
	    staticFriction: number;
	    bounciness: number;
	    frictionCombine: phys3D.CombineMode;
	    bounceCombine: phys3D.CombineMode;
	}
	export type PhysicMaterialResourceDescription = DeepImmutable<IPhysicMaterialResourceDescription>;
	interface IPrefabResourceDescription {
	    meta: {
	        name: string;
	        type: "2D" | "3D";
	    };
	    gameObjectList: Array<{
	        name: string;
	        components: number[];
	        children: number[];
	        data: {
	            active: boolean;
	            layer?: number;
	        };
	    }>;
	    componentList: Array<{
	        type: string;
	        data: any;
	    }>;
	    bufferDataUUIDList?: string[];
	}
	export type PrefabResourceDescription = DeepImmutable<IPrefabResourceDescription>;
	export enum FogMode {
	    None = 0,
	    Linear = 1,
	    Exponential = 2,
	    ExponentialSquared = 3
	}
	export enum AmbientMode {
	    Skybox = 0,
	    Gradient = 1,
	    Color = 2
	}
	export enum LightMapType {
	    Subtractive = 0,
	    ShadowMask = 1
	}
	export interface LightMapsDescription {
	    color: string;
	    shadowMask?: string;
	}
	export interface EnvironmentMapDescription {
	    color: string;
	}
	export interface PanoramaDescription {
	    color: string;
	}
	export enum UIAdaptationType {
	    FitHeight = 0,
	    FitWidth = 1,
	    Contain = 2,
	    Custom = 3
	}
	export interface IScene2DMeta {
	    type: "2D";
	    name: string;
	    config: {
	        resolution: {
	            width: number;
	            height: number;
	        };
	        adaptationType?: UIAdaptationType;
	    };
	}
	export interface IScene3DMeta {
	    type: "3D";
	    name: string;
	    config: {
	        light: {
	            ambientMode?: AmbientMode;
	            ambientColor?: [number, number, number, number];
	            ambientIntensity?: number;
	            ambientSkyColor?: [number, number, number, number];
	            ambientEquatorColor?: [number, number, number, number];
	            ambientGroundColor?: [number, number, number, number];
	            reflectionIntensity?: number;
	            reflectionResolution?: number;
	            fogMode?: FogMode;
	            fogColor?: [number, number, number];
	            fogStart?: number;
	            fogRange?: number;
	            fogDensity?: number;
	            skyBox?: string;
	            subtractiveShadowColor?: [number, number, number, number];
	            lightMapDatas?: LightMapsDescription[];
	            lightMapType?: LightMapType;
	            environmentMapDatas?: EnvironmentMapDescription[];
	            panoramaDatas?: PanoramaDescription[];
	            shCoefficients?: [];
	        };
	        physics?: {
	            gravity?: [number, number, number];
	        };
	    };
	}
	interface ISceneResourceDescription extends IPrefabResourceDescription {
	    meta: IScene2DMeta | IScene3DMeta;
	}
	export type SceneResourceDescription = DeepImmutable<ISceneResourceDescription>;
	interface IRenderTextureAsset {
	    data: {
	        width: number;
	        height: number;
	    };
	}
	export type RenderTextureAsset = DeepImmutable<IRenderTextureAsset>;
	interface IPostProcessStep {
	    type: string;
	    data: object;
	    disabled?: boolean;
	}
	interface IPPStepFXAA extends IPostProcessStep {
	    type: "FXAA";
	    data: {};
	}
	interface IPPStepBlit extends IPostProcessStep {
	    type: "BLIT";
	    data: {};
	}
	interface IPPStepHDR extends IPostProcessStep {
	    type: "HDR";
	    data: {
	        exposure: number;
	    };
	}
	interface IPPStepBloom extends IPostProcessStep {
	    type: "BLOOM";
	    data: {
	        threshold: number;
	        softThreshold: number;
	        radius: number;
	        intensity: number;
	    };
	}
	interface IPPStepGaussianBlur extends IPostProcessStep {
	    type: "BLUR";
	    data: {
	        radius: number;
	    };
	}
	interface IPPStepCustom extends IPostProcessStep {
	    custom: true;
	}
	export type SpecializedPPStep = IPPStepFXAA | IPPStepBlit | IPPStepHDR | IPPStepBloom | IPPStepGaussianBlur | IPPStepCustom;
	interface IPostProcessAsset {
	    steps: Array<SpecializedPPStep>;
	}
	export type PostProcessDescription = DeepImmutable<IPostProcessAsset>;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D' {
	import { TextureResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import Texture, { TextureFilterMode, TextureSource } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture';
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	/**
	 * Texture2D构造参数。
	 */
	export interface ITexture2DDesc {
	    filterMode?: TextureFilterMode;
	    wrapU?: Kanata.EWrapMode;
	    wrapV?: Kanata.EWrapMode;
	    anisoLevel?: number;
	}
	/**
	 * 2D贴图资源。
	 */
	export default class Texture2D extends Texture {
	    /**
	     * 贴图的填充模式。
	     */
	    get filterMode(): TextureFilterMode;
	    /**
	     * 各向异性参数，有效值为1-16。
	     */
	    get anisoLevel(): number;
	    /**
	     * 像素格式。
	     */
	    get pixelFormat(): Kanata.ETextureFormat;
	    /**
	     * 横向采样包围模式。
	     */
	    get wrapU(): Kanata.EWrapMode;
	    /**
	     * 纵向采样包围模式。
	     */
	    get wrapV(): Kanata.EWrapMode;
	    /**
	     * 是否使用mipmap。
	     */
	    get useMipmap(): boolean;
	    get mipmapLevel(): number | undefined;
	    /**
	     * 贴图高。
	     * @readonly
	     * @type {number}
	     * @memberof Texture2D
	     */
	    get height(): number;
	    /**
	     * 贴图宽。
	     */
	    get width(): number;
	    /**
	     * 是否可动态写入。
	     */
	    get writeable(): boolean;
	    /**
	     * 仅在图片为非压缩纹理时，获取原始图片的url。
	     */
	    get imageSrc(): string | undefined;
	    set imageSrc(imgSrc: string | undefined);
	    set meta(meta: TextureResourceDescription["data"] | undefined);
	    /**
	     * 创建Texture2D。
	     */
	    constructor(desc?: ITexture2DDesc);
	    /**
	     * 上传局部纹理。
	     * 仅在动态贴图的模式下有效。
	     *
	     * @param 上传贴图时是否进行反预乘，暂时无效
	     */
	    updateSubTexture(source: TextureSource, x: number, y: number, width: number, height: number, needUnpackPremultiplyAlpha?: boolean): void;
	    /**
	     * 使用Image来初始化。
	     *
	     * @param image Image对象。
	     * @param generateMipmap 是否生成mipmap。
	     * @param needUnpackPremultiplyAlpha 上传贴图时是否进行反预乘。
	     *
	     * @returns 是否初始化成功。
	     */
	    initWithImage(image: Kanata.IImage, generateMipmap?: boolean, needUnpackPremultiplyAlpha?: boolean): boolean;
	    /**
	     * 使用wxCanvas来初始化。
	     *
	     * @param canvas HTMLCanvas或wxCanvas。
	     * @returns 是否初始化成功
	     */
	    initWithCanvas(canvas: HTMLCanvasElement): boolean;
	    /**
	     * 使用原始RGBA buffer进行初始化
	     *
	     * @param generateMipmap 是否生成mipmap
	     * @param needUnpackPremultiplyAlpha 上传贴图时是否进行反预乘
	     * @returns 是否初始化成功
	     */
	    initWithRGBABuffer(arraybuffer: ArrayBufferView, width: number, height: number, generateMipmap?: boolean, needUnpackPremultiplyAlpha?: boolean): boolean;
	    /**
	     * 使用压缩纹理初始化。
	     * 目前支持 PVR/ASTC (IOS) , ETC1/ETC2 (Android)。
	     *
	     * @param {TexturePixelFormat} pixelFormat 纹理格式。
	     * @param {ArrayBuffer} bufferSrc 原始buffer,如有mipmap，则逐级连接。
	     */
	    initWithCompressTexture(pixelFormat: Kanata.ETextureFormat, bufferSrc: ArrayBuffer, width: number, height: number, mipmapLevel?: number): boolean;
	    /**
	     * 创建动态纹理，可用于后续`updateSubTexture`更新。
	     */
	    initDynamicTexture(width: number, height: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/buildin-textures' {
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D'; const BuildInTextures: {
	    transparent: Texture2D;
	    white: Texture2D;
	    black: Texture2D;
	    red: Texture2D;
	    green: Texture2D;
	    blue: Texture2D;
	    yellow: Texture2D;
	    bump: Texture2D;
	    babyblue: Texture2D;
	    babygreen: Texture2D;
	    babyred: Texture2D;
	};
	/**
	 * 内置纯色贴图资源，避免不必要的getAsset调用。
	 * @export
	 */
	export default BuildInTextures;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader/base' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import { ILoadTask } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task';
	import { ILoadFileOptions, ILoadOptions } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/interface';
	export default abstract class BaseLoader {
	    /**
	     * 加载一个资源。如果资源所需的文件不在本地，则会先下载文件。
	     *
	     * 可以用以下代码来获取加载结果：
	     * ```typescript
	     * engine.loader.load("xxx").promise.then(asset => {
	     *   // handle asset
	     * }).catch(err => {
	     *   // handle error
	     * });
	     * ```
	     * @param assetID 资源基于`小游戏根目录/assets/`的相对路径。
	     * @param options 加载选项。
	     */
	    abstract load<T>(assetID: string, options?: ILoadOptions): ILoadTask<T>;
	    /**
	     * 读取已下载的文件内容。
	     *
	     * @param fileID 文件在项目中的相对路径。
	     */
	    abstract getFile<T>(fileID: string): T | null;
	    /**
	     * 获取一个已经反序列化过的资源。
	     * @param assetID 资源的相对路径。
	     */
	    abstract getAsset<T>(assetID: string): T | null;
	    /**
	     * 根据id获取文件的真实地址（tmp/或者usr/）。
	     *
	     * \**如果用于获取图片，会获取到texture描述文件的路径。*
	     * @param fileID 文件在项目中的相对路径。
	     * @returns 如果文件存在就返回路径，如果不存在就返回空字符串""。
	     */
	    abstract getFileSrc(fileID: string): string;
	    /**
	     * 根据Texture2D的相对路径，获取下载后的图片的真实路径（tmp/或者usr/）。
	     * @param fileID Texture2D在项目中的相对路径。
	     * @returns 如果文件存在就返回路径，如果不存在或非图片就返回空字符串""。
	     */
	    abstract getImageSrc(fileID: string): string;
	    /**
	     * 查询资源在项目中是否存在。
	     * @param assetID 资源的相对路径。
	     */
	    abstract assetExists(assetID: string): boolean;
	    /**
	     * 读取一个文件的内容。如果文件不在本地，则会先下载。
	     *
	     * \**暂不支持字体。*
	     *
	     * @param {string} url
	     * @param {ILoadFileOptions} options
	     */
	    loadFile(url: string, options: ILoadFileOptions): LitePromise<any>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader/game' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import LoadTask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task';
	import BaseLoader from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader/base';
	import { ILoadOptions } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/interface';
	export class Loader extends BaseLoader {
	    getAssetDependentGroups(assetID: string): string[];
	    getAssetDependentGroupHashs(assetID: string): string[] | null;
	    hasGroup(groupID: string): boolean;
	    hasRegistry(filename: string): boolean;
	    /**
	     * 读取/下载并注册一个 register.json
	     * @param url registerJSON的路径，可以为绝对路径也可以为相对路径。如果是相对路径，会与base进行拼接
	     * @param base 资源的基础路径。
	     *    如果registerJSON url和资源组的url为相对路径，则base会参与拼接成为最终路径。
	     *    如果取值为lanDebug，则会取开发者工具的局域网调试服务器地址。
	     */
	    register(url: string, baseRaw: string | string[]): LitePromise<void>;
	    /**
	     *
	     * @template T 资源类型
	     * @param {string} assetid 资源id
	     * @param {ILoadOptions} [options={}] 加载参数
	     * @returns {LoadTask<T>}
	     * @memberof Loader
	     */
	    load<T>(assetID: string, options?: ILoadOptions): LoadTask<T>;
	    innerLoad<T>(assetID: string, options?: ILoadOptions): LoadTask<T>;
	    getFile<T>(fileID: string): T | null;
	    getFileSrc(fileID: string): string;
	    getImageSrc(fileID: string): string;
	    assetExists(assetID: string): boolean;
	    getAssetWithType<T>(assetID: string, type: string): T | null;
	    /**
	     * 同步获取一个资源实例
	     *
	     * @template T
	     * @param {string} assetID 资源ID
	     * @param {string} backupAssetID 备份资源ID
	     * @returns {T}
	     * @memberof Loader
	     */
	    getAsset<T>(assetID: string): T | null;
	} const _default: Loader;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/cache' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import { UserFile } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file';
	import FileStorage from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/storage'; type compareFunction = (a: UserFile, b: UserFile) => number; class CacheManager extends FileStorage {
	    /**
	     * 缓存空间不足的警告阈值，单位 B 字节。当 sizeLimit - currentSize <= freeSpaceThreshold 时，将执行 onNeedRelease() 回调函数。
	     * 如果 onNeedRelease() 返回非 -1 的正整数，如 40*1024*1024，则释放 40 MB 缓存空间。
	     * 如果 freeSpaceThreshold < 1，则以 sizeLimit * freeSpaceThreshold 作为阈值。
	     *
	     * @type {number}
	     * @memberof CacheManager
	     */
	    freeSpaceThreshold: number;
	    /**
	     * 当剩余缓存空间小于警告阈值时。
	     *
	     * @memberof CacheManager
	     */
	    onNeedRelease: (res: {
	        currentSize: number;
	        sizeLimit: number;
	        cacheSize: number;
	    }) => number;
	    /**
	     * 缓存淘汰策略函数，用法同传入 Array.prototype.sort 的函数。
	     * 当淘汰缓存时，会对已有缓存进行排序，然后依次淘汰在排序结果中靠前的缓存直到满足所需释放的缓存空间大小。
	     * 如果 compare 不为 null，则根据 compare 返回的结果进行排序，否则按照最近最少使用的策略进行排序。
	     *
	     * @type {(compareFunction | null)}
	     * @memberof CacheManager
	     */
	    compare: compareFunction | null;
	    check(assetID: string): boolean;
	    releaseUseless(): LitePromise<void>;
	    save(temp: string, dist: string, size: number): void;
	    /**
	     * 释放指定大小的缓存空间。CacheManager 会根据传入的 size 去删除文件，以腾出缓存空间。
	     *
	     * @param {number} size 要释放的缓存空间的大小，单位 B 字节。
	     * @returns {LitePromise<void[]>}
	     * @memberof CacheManager
	     */
	    release(size: number): LitePromise<number>;
	    /**
	     * 必须得在初始化的时候设置
	     * @param delimiter
	     */
	    setDelimiter(delimiter: string): void;
	    init(): LitePromise<void>;
	} const _default: CacheManager;
	export default _default;
	export { CacheManager };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import { IFile, File, State } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/base';
	import FileStorage from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/storage';
	export { IFile, File, State };
	export const FILE_READY_CROSS_CONTEXT_TYPE = "file-ready";
	export class DirectFile extends File {
	    get existed(): boolean;
	    load(): LitePromise<void>;
	}
	export class UserFile extends File {
	    get existed(): boolean;
	    get content(): any;
	    set content(content: any);
	    get retry(): number;
	    set retry(retry: number);
	    get priority(): number;
	    set priority(priority: number);
	    loadTimes: number;
	    useTimes: number;
	    lastLoadTime: number;
	    lastUseTime: number;
	    constructor(storage?: FileStorage);
	    download(): LitePromise<void>;
	    write(): LitePromise<void>;
	    read(): LitePromise<void>;
	    load(): LitePromise<void>;
	    abort(): void;
	    remove(): LitePromise<void>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/error' {
	export enum ErrorCode {
	    OK = 0,
	    Unexpected = 1,
	    LoadFile_Unexpected = 101,
	    LoadFile_EmptyPath = 102,
	    LoadFile_LoadFontFailed = 103,
	    LoadFile_LoadImageFailed = 104,
	    LoadFile_JSONParseFailed = 105,
	    LoadFile_NotExist = 106,
	    LoadFile_UnexpectedData = 107,
	    DownloadFile_Unexpected = 201,
	    DownloadFile_UnexpectedStatusCode = 202,
	    DownloadFile_EmptyData = 203,
	    DownloadFile_Aborted = 204,
	    WriteFile_MaximumSizeExceeded = 212,
	    LoadTask_Aborted = 402,
	    LoadContext_NotCreated = 502,
	    LoadContext_ManifestNotLoaded = 503,
	    LoadContext_NotLoaded = 504,
	    Deserialize_InvalidResource = 522,
	    Register_Failed = 602,
	    Load_FileNotRegistered = 612,
	    Load_AssetNotRegistered = 613,
	    Load_GroupNotRegistered = 614,
	    Load_InvalidURL = 615,
	    Cache_NoEnoughSpace = 702,
	    Cache_EliminateEmpty = 706,
	    OpenData_OpenIDNotExist = 1002,
	    OpenData_GetOpenIDNotRejected = 1003,
	    OpenData_InvalidSpriteFrameData = 1004,
	    OpenData_InvalidSpriteFrameURL = 1005,
	    OpenData_LoadSpriteFrameFailed = 1006,
	    OpenData_ExpressionEvaluateFailed = 1007,
	    OpenData_NoPermission = 1012
	} type ErrorDetail = {
	    [key: string]: any;
	} | null;
	export class EngineError extends Error {
	    code: ErrorCode;
	    detail: ErrorDetail;
	    constructor(code: ErrorCode, detail: ErrorDetail);
	}
	interface ILoadFileErrorDetail {
	    path: string;
	    type: string;
	    data?: any;
	    error?: any;
	}
	export class LoadFile_UnexpectedError extends EngineError {
	    constructor(detail: ILoadFileErrorDetail);
	}
	export class LoadFile_EmptyPathError extends EngineError {
	    constructor(detail: ILoadFileErrorDetail);
	}
	export class LoadFile_LoadFontFailedError extends EngineError {
	    constructor(detail: ILoadFileErrorDetail);
	}
	export class LoadFile_LoadImageFailedError extends EngineError {
	    constructor(detail: ILoadFileErrorDetail);
	}
	export class LoadFile_JSONParseFailedError extends EngineError {
	    constructor(detail: ILoadFileErrorDetail);
	}
	export class LoadFile_NotExistError extends EngineError {
	    constructor(detail: ILoadFileErrorDetail);
	}
	export class LoadFile_UnexpectedDataError extends EngineError {
	    constructor(detail: ILoadFileErrorDetail);
	}
	export class DownloadFile_UnexpectedError extends EngineError {
	    constructor(detail: {
	        url: string;
	        error: any;
	    });
	}
	export class DownloadFile_UnexpectedStatusCodeError extends EngineError {
	    constructor(detail: {
	        url: string;
	        statusCode: number;
	        dataLength: number;
	        header: {
	            [key: string]: string;
	        };
	    });
	}
	export class DownloadFile_EmptyDataError extends EngineError {
	    constructor(detail: {
	        url: string;
	        statusCode: number;
	        dataLength: number;
	        header: {
	            [key: string]: string;
	        };
	    });
	}
	export class WriteFile_MaximumSizeExceededError extends EngineError {
	    constructor(detail: {
	        type: "downloadFile" | "saveFile" | "copyFile" | "writeFile";
	        size?: number;
	        url?: string;
	        path?: string;
	    });
	}
	export class DownloadFile_AbortedError extends EngineError {
	    constructor(detail: {
	        url: string;
	    });
	}
	export class LoadTask_AbortedError extends EngineError {
	    constructor(detail: {
	        id: string;
	        groupID?: string;
	    });
	} type LoadContextErrorDetail = ({
	    fileID: string;
	    groupID?: string;
	    state?: string;
	    history?: string;
	} | {
	    assetID: string;
	    groupID?: string;
	    state?: string;
	    history?: string;
	}) & {
	    error?: Error | null;
	};
	export class LoadContext_NotCreatedError extends EngineError {
	    constructor(detail: LoadContextErrorDetail);
	}
	export class LoadContext_ManifestNotLoadedError extends EngineError {
	    constructor(detail: LoadContextErrorDetail);
	}
	export class LoadContext_NotLoadedError extends EngineError {
	    constructor(detail: LoadContextErrorDetail);
	}
	export class Deserialize_InvalidResourceError extends EngineError {
	    constructor(detail: {
	        type: string;
	    });
	}
	export class Register_FailedError extends EngineError {
	    constructor(detail: {
	        url: string;
	        error: any;
	    });
	}
	export class Load_FileNotRegisteredError extends EngineError {
	    constructor(detail: {
	        fileID: string;
	    });
	}
	export class Load_AssetNotRegisteredError extends EngineError {
	    constructor(detail: {
	        assetID: string;
	    });
	}
	export class Load_GroupNotRegisteredError extends EngineError {
	    constructor(detail: {
	        groupID: string;
	    });
	}
	export class Load_InvalidURLError extends EngineError {
	    constructor(detail: {
	        url: string;
	    });
	} type CacheSizeErrorDetail = {
	    size: number;
	    count: number;
	};
	export class Cache_NoEnoughSpaceError extends EngineError {
	    constructor(detail: CacheSizeErrorDetail);
	}
	export class Cache_EliminateEmptyError extends EngineError {
	    constructor(detail: CacheSizeErrorDetail);
	}
	export class OpenData_OpenIDNotExistError extends EngineError {
	    constructor();
	}
	export class OpenData_GetOpenIDNotRejectedError extends EngineError {
	    constructor();
	}
	export class OpenData_InvalidSpriteFrameDataError extends EngineError {
	    constructor(detail?: {
	        data: string;
	    } | null);
	}
	export class OpenData_InvalidSpriteFrameURLError extends EngineError {
	    constructor(detail?: {
	        data: string;
	    } | null);
	}
	export class OpenData_LoadSpriteFrameFailedError extends EngineError {
	    constructor(detail: {
	        reason: string;
	    });
	}
	export class OpenData_ExpressionEvaluateFailedError extends EngineError {
	    constructor();
	}
	export class OpenData_NoPermissionError extends EngineError {
	    constructor();
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/api' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	export const stat: (path: string, recursive?: boolean) => LitePromise<{
	    stats: engineWX.Stats | engineWX.StatsArray;
	}>; const mkdir: (dirPath: string) => LitePromise<void>; const rmdir: (dirPath: string) => LitePromise<void>; const saveFile: (src: string, dist: string) => LitePromise<string>; const copyFile: (src: string, dist: string) => LitePromise<void>; const writeFile: (data: string | ArrayBuffer, path: string) => LitePromise<void>; const unlink: (path: string) => LitePromise<void>;
	export { mkdir, rmdir, saveFile, copyFile, writeFile, unlink };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/priority-download/download' {
	import { Task } from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/task';
	export type DownloadResponse = {
	    filePath: string;
	    dataLength: number;
	};
	export enum EDownloadEvent {
	    BEGIN = 0,
	    SUCCESS = 1,
	    FAILED = 2
	}
	export type DownloadSessionEventListener = (e: EDownloadEvent, ...others: any[]) => void;
	export class DownloadSession extends Task<DownloadResponse> {
	    task: engineWX.DownloadTask | null;
	    retry: number;
	    constructor(urls: string[], filePath: string, retry: number, priority: number, listener?: DownloadSessionEventListener);
	    download(urls: string[], filePath: string, urlIndex?: number): any;
	    abort(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/priority-download' {
	import { TaskManager } from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/task';
	import { DownloadResponse, DownloadSession, DownloadSessionEventListener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/priority-download/download';
	/**
	 * 对wxDownloadFile的一个封装，允许带优先级的任务执行
	 *
	 * @export
	 * @class WXPriorityDownload
	 */
	export class PriorityDownload extends TaskManager<DownloadResponse> {
	    /**
	     * 对外暴露的入下载队函数
	     *
	     * @param {number} priority 优先级
	     * @param {(download: (url) => void) => void} getDownloadParam 拍好队之后的回调函数，download即启动下载
	     * @returns
	     */
	    queue(urls: string[], filePath?: string, retry?: number, priority?: number, listener?: DownloadSessionEventListener): DownloadSession;
	} const _default: PriorityDownload;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext' {
	/** @ts-ignore */
	import * as Kanata from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src';
	export function initGlobalContextByCanvas(antialias: boolean, ignore_assert: boolean, disable_log: boolean): void; class PhysicsManager {
	    clear(): void;
	    bindRigidbodyToEntity(rigidbody: phys3D.Rigidbody, entity: Kanata.Entity3D, name: string): void;
	    bindColliderToEntity(collider: phys3D.Collider, entity: Kanata.Entity3D): void;
	    bindCCToEntity(cc: phys3D.CharacterController, entity: Kanata.Entity3D): void;
	    unbindCCT(cc: phys3D.CharacterController): void;
	    alignRigidbodyWithEntity(rigidbody: phys3D.Rigidbody, entity: Kanata.Entity3D): void;
	    unbindRigidbody(rigidbody: phys3D.Rigidbody): void;
	    unbindCollider(collider: phys3D.Collider): void;
	    recursivelySyncCCBackEntity(entity: Kanata.Entity3D, dirty?: boolean): void;
	    PhysSystem: any;
	    RawVec3f: any;
	    RawVec2f: any;
	    PhysMesh: any;
	    Collider: any;
	    MeshCollider: any;
	    CombineMode: any;
	    Material: any;
	    CapsuleCollider: any;
	    Joint: any;
	    ContactPoint: any;
	    Collision: any;
	    SphereCollider: any;
	    Bounds: any;
	    StaticRigidbody: any;
	    DynamicRigidbody: any;
	    RawQuaternion: any;
	    BoxCollider: any;
	    RaycastHit: any;
	    CharacterController: any;
	} const gctx: {
	    Phys3D: PhysicsManager;
	};
	/**
	 * 引擎全局配置。
	 */
	export interface IEngineSettings {
	    /** log过滤器 */
	    logFilter: boolean;
	    /** log等级 */
	    logLevel: string;
	    /** 最大缓存极限 */
	    cacheSizeLimit: number;
	    /** 是否开启MSAA */
	    realSizeLimit: number;
	    /** 设计分辨率宽 */
	    designWidth: number;
	    /** 设计分辨率高 */
	    designHeight: number;
	    /** 渲染分辨率宽 */
	    renderWidth: number;
	    /** 渲染分辨率高 */
	    renderHeight: number;
	    /** 是否开启MSAA */
	    mainScreenMSAA: boolean;
	    /** loader下载文件的默认根路径 */
	    baseURL: string;
	    /** 如果baseURL找不到并且重试次数`globalHTTPRetry`大于0，则会依次尝试使用 */
	    backupURLs: string[];
	    /** 全局loader下载文件重试次数 */
	    globalHTTPRetry: string;
	    /** 物理引擎的重力 */
	    gravity: number;
	    /** 物理引擎的模拟步进固定间隔 */
	    fixedDeltaTime: number;
	    useEngineSubcontext: boolean;
	    /** 物理碰撞矩阵，以十六进制字符串表示 */
	    physics3DLayerCollisionMatrix: string;
	    /** 拼缓存的文件名的 */
	    cacheDelimiter: string;
	    /** 自动生成的worker文件入口路径 */
	    workerPath: string;
	    /** worker执行任务超时时间 */
	    workerTimeout: number;
	    gfxIgnoreAssert: boolean;
	    profileGfx: string;
	    /** 全局Uniform定义 */
	    shaderGlobalProperties: {
	        key: string;
	        type: 'Float' | 'Vector2' | 'Vector3' | 'Vector4' | 'Matrix4' | 'Texture';
	        default: number | number[] | string;
	    }[];
	}
	export default gctx;
	export { Kanata };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render/renderEnv' {
	/**
	 * renderEnv.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 8/2/2021, 1:35:23 PM
	 */
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Screen from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen';
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect';
	/**
	 * 全局渲染环境管理器。
	 */
	export class RenderEnv {
	    /**
	     * Backend的版本。
	     */
	    get version(): string;
	    /**
	     * Backend的类型。
	     */
	    get backendType(): any;
	    /**
	     * 画布宽。
	     */
	    get canvasWidth(): number;
	    /**
	     * 画布高。
	     */
	    get canvasHeight(): number;
	    /**
	     * 当前支持的压缩纹理类型。
	     */
	    get supportCompressTextures(): Kanata.TCompressTexture[];
	    /**
	     * 当前支持的渲染特性。
	     */
	    get features(): Kanata.IFeatures;
	    /**
	     * 当前环境是否支持GPU Instance。
	     */
	    get useInstance(): boolean;
	    /**
	     * 为某个lightMode注册Fallback的Effect。
	     */
	    registerFallbackEffect(lightMode: string, effect?: Effect): void;
	    /**
	     * 移除某个lightMode的Fallback Effect。
	     */
	    unregisterFallbackEffect(lightMode: string): void;
	    /**
	     * 开始一帧的渲染。
	     */
	    beginFrame(): void;
	    /**
	     * 结束一帧的渲染。
	     */
	    endFrame(): void;
	    /**
	     * 直接通过View清除当前画布。
	     */
	    clearView(view: Kanata.View): void;
	    /**
	     * 设置渲染目标。
	     */
	    setRenderTarget(target: Screen | RenderTexture): void;
	    /**
	     * 修改全局宏信息。
	     */
	    changeMacros(macros: {
	        [name: string]: string | number | boolean;
	    }): void;
	    /**
	     * 获取全局宏信息。
	     */
	    getMacro(key: string): string | number | boolean;
	    /**
	     * 修改虚拟宏信息。
	     */
	    changeVirtualMacros(macros: {
	        [name: string]: boolean;
	    }): void;
	    /**
	     * 获取虚拟宏信息。
	     */
	    getVirtualMacro(key: string): boolean;
	} const _default: RenderEnv;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/nativeBuffer' {
	export class NativeBufferReader {
	    byteOffset: number;
	    f32View: Float32Array;
	    constructor(buffer: ArrayBuffer, startOffset?: number);
	    align4(): void;
	    startSegment(): void;
	    endSegment(): void;
	    checkSegmentCanRead(): boolean;
	    clear(): void;
	    readUint32(): number;
	    readUint16(): number;
	    readUint8(): number;
	    readInt32(): number;
	    readFloat32(): number;
	}
	export class NativeBufferWriter {
	    constructor(buffer: ArrayBuffer, startOffset?: number);
	    clear(): void;
	    align4(): void;
	    pushSegment(): void;
	    popSegment(): void;
	    writeUint32(value: number): void;
	    writeUint8(value: number): void;
	    writeFloat32(value: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/raw' {
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { RawResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	/**
	 * 原始资源。
	 * @export
	 * @class RawResource
	 * @extends {BaseResource}
	 */
	export default class RawResource extends BaseResource {
	    value: any;
	    /**
	     * 从文件内容初始化原始资源。
	     * @param {*} value
	     * @memberof RawResource
	     */
	    constructor(value: any);
	    /**
	     * 原始资源反序列化函数。
	     * @static
	     * @param {RawResourceDescription} resourceDescription 资源配置。
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {RawResource}
	     * @memberof RawResource
	     */
	    static DeserializeResource(resourceDescription: RawResourceDescription, loadContext: BaseLoadContext): RawResource;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/atlas' {
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { AtlasResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	/**
	 * 图集资源
	 * @export
	 * @class Atlas
	 * @extends {BaseResource}
	 */
	export default class AtlasResource extends BaseResource {
	    /**
	     * 从文件内容初始化图集资源。
	     * @param {*} value
	     * @memberof AtlasResource
	     */
	    constructor();
	    /**
	     * 图集资源反序列化函数。
	     * @static
	     * @param {RawResourceDescription} resourceDescription 资源配置。
	     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
	     * @param {string[]} dependencies 依赖资源id列表。
	     * @returns {AtlasResource}
	     * @memberof AtlasResource
	     */
	    static DeserializeResource(resourceDescription: AtlasResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): AtlasResource;
	    get spriteframes(): {
	        [name: string]: SpriteFrame | null;
	    };
	    getSpriteframeByKey(key: string): SpriteFrame | null;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/scriptableAsset' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	/**
	 * 自定义资源基类。
	 *
	 * 可以通过继承这个类来创造自定义资源，具体使用方法请参考[用户手册](todo)。
	 * 加载自定义资源时，会把所有依赖的资源先加载了，所以也可以作为预加载资源包的入口来使用。
	 */
	export default class ScriptableAsset extends BaseResource {
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader' {
	import ILoader from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader/base';
	export default function (): ILoader;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audioClip' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; enum LoadTypeEnum {
	    /**
	     * 加载audioclip后，音频数据在内存中保持压缩状态，播放时才解码为PCM。由于播放时才解码音频，因此会带来轻微的播放延迟。Compressed_In_Memory选项应尽量用于较大的音频文件，因为Compressed_On_Load加载时解码将占用大量内存。
	     */
	    Compressed_In_Memory = 0,
	    /**
	     * 加载audioclip后，立即将音频数据解码为PCM。由于加载后立即解码，故可降低因解码所带来的轻微播放延迟。但解码后的PCM数据所占内存将为保持压缩状态时所占内存的数倍，具体取决于音频数据的采样率和压缩方式。因此尽量对较小的音频文件使用此选项。
	     */
	    Decompress_On_Load = 1
	} class AudioClip extends BaseResource {
	    /**
	     * 音频播放链接，可以用于调用wx.createInnerAudio播放音频
	     * @memberof AudioClip
	     */
	    readonly value: string;
	    /**
	     * 音频时长，单位秒。当preloadAudioData=false 且 audioclip被用于时间线系统时，此属性才有用。
	     */
	    get length(): number;
	    set length(val: number);
	    /**
	     * 是否把音频下载到本地。
	     * true：当通过engine.loader.load或其他方式加载audioclip资源时，会把音频文件下载到本地。播放音频时，实际是播放一个本地音频文件。只有preloadAudioData=true时，audioclip才能用于AudioSource。
	     * false: 该audioclip只能使用基础音频接口wx.createInnerAudioContext播放。此时是边播放边下载。
	     * @memberof AudioClip
	     */
	    get preloadAudioData(): boolean;
	    set preloadAudioData(val: boolean);
	    /**
	     * 设置audioclip的加载方式。只有当preloadAudioData=true时，此属性才有效
	     * @memberof AudioClip
	     */
	    get loadType(): LoadTypeEnum;
	    set loadType(val: LoadTypeEnum);
	    get _stopTime(): number;
	    /**
	     * 音频播放链接，可以用于调用wx.createInnerAudio播放音频
	     * @memberof AudioClip
	     */
	    get fileSrc(): string;
	    /**
	     * 获取音频解码后的PCM数据。当preloadAudioData=true，且文件大小<9M，才有效。否则报错
	     * @param callback 回调函数
	     * @memberof AudioClip
	     */
	    getAudioBuffer(
	    /**
	     * @param buffer 解码后的PCM数据
	     */
	    callback: (buffer: AudioBuffer) => void): void;
	    /**
	     * 当音频解码后的PCM数据没有被引用时，主动释放。
	     * @param buffer 通过getAudioBuffer函数获取的PCM数据。
	     * @param time 多少秒后开始释放。默认30秒。
	     * @memberof AudioClip
	     */
	    releaseAudioBuffer(buffer: AudioBuffer, time?: number): void;
	} namespace AudioClip {
	    /**
	     * 音频剪辑audioclip加载方式
	     */
	    export import LoadType = LoadTypeEnum;
	}
	export default AudioClip;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBehaviour' {
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import type { FrameData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/interface';
	export interface ITypeofPlayableBehaviour<T extends PlayableBehaviour> {
	    PlayableClass: typeof Playable;
	    new (...args: any): T;
	} class PlayableBehaviour {
	    /**
	     * 每帧执行的回调，在ProcessFrame回调之前执行。
	     *
	     * @param {Playable} playable
	     * @param {FrameData} info
	     * @memberof PlayableBehaviour
	     */
	    PrepareFrame(playable: Playable, info: FrameData): void;
	    /**
	     * 每帧执行的回调。
	     *
	     * @param {Playable} playable
	     * @param {FrameData} info
	     * @param {*} playerData
	     * @memberof PlayableBehaviour
	     */
	    ProcessFrame(playable: Playable, info: FrameData, playerData: any): void;
	} namespace PlayableBehaviour {
	    export import PlayableClass = Playable;
	}
	export default PlayableBehaviour;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/scriptPlayable' {
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import PlayableBehaviour, { ITypeofPlayableBehaviour } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBehaviour'; type PlayableGraph = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph').default;
	export default class ScriptPlayable<T extends PlayableBehaviour> {
	    static Create<T extends PlayableBehaviour>(graph: PlayableGraph, behaviourCtor: ITypeofPlayableBehaviour<T>): Playable;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/timelinePlayable' {
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import PlayableBehaviour from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBehaviour';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	export class TimelinePlayable extends Playable {
	}
	export default class TimelinePlayableBehaviour extends PlayableBehaviour {
	    static PlayableClass: typeof TimelinePlayable;
	    static Create(graph: PlayableGraph, trackAssets: TrackAsset[]): Playable;
	    compile(graph: PlayableGraph, timelinePlayable: Playable, trackAssets: TrackAsset[]): void;
	    createTrackPlayable(graph: PlayableGraph, timelinePlayable: Playable, trackAsset: TrackAsset): void;
	    createTrackOutput(graph: PlayableGraph, timelinePlayable: Playable, trackAsset: TrackAsset, port: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableOutput' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	export default class PlayableOutput {
	    isOutputValid(): boolean;
	    getReferenceTrackAsset(): Nullable<TrackAsset>;
	    setReferenceTrackAsset(val: any): void;
	    getSourceOutputPort(): number;
	    getSourcePlayable(): Nullable<Playable>;
	    setSourcePlayable(playable: any, port: number): void;
	    getUserData(): any;
	    setUserData(userData: any): void;
	    getWeight(): number;
	    setWeight(weight: any): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/interface' {
	import PlayableOutput from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableOutput';
	export enum EPlayState {
	    Paused = 0,
	    Playing = 1
	}
	export enum EEvaluationType {
	    Evaluate = 0,
	    Playback = 1
	}
	export interface FrameData {
	    deltaTime: number;
	    timeLooped?: boolean;
	    effectiveParentSpeed?: number;
	    effectiveSpeed?: number;
	    playState?: EPlayState;
	    effectiveWeight?: number;
	    weight?: number;
	    evaluationType?: EEvaluationType;
	    frameIndex?: number;
	    output?: PlayableOutput;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import type TimelineAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineAsset';
	import type TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import type TimelineClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip';
	import type PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	export enum EPlayableType {
	    /** 激活类型。 */
	    Activation = 0,
	    /** 动画类型。 */
	    Animation = 1,
	    /** 音频类型。 */
	    Audio = 2,
	    /** 控制类型（暂不支持） */
	    Control = 3,
	    /** 自定义类型（暂不支持） */
	    Custom = 4
	}
	export const PlayableTypeToTypeName: {
	    [key in EPlayableType]: string;
	};
	export enum EPlaybaleTrackType {
	    /** 激活类型。 */
	    Activation = 0,
	    /** 动画类型。 */
	    Animation = 1,
	    /** 音频类型。 */
	    Audio = 2,
	    /** 控制类型（暂不支持） */
	    Control = 3,
	    /** 自定义类型。 */
	    Custom = 4,
	    /** 组类型。 */
	    Group = 5
	}
	export const TrackTypeToTypeName: {
	    [key in EPlaybaleTrackType]: string;
	};
	export enum EPostPlaybackState {
	    Active = 0,
	    Inactive = 1,
	    LeaveAsIs = 2,
	    Revert = 3
	}
	export enum ClipCaps {
	    /**
	     * 任何特性都不支持。No features are supported.
	     */
	    None = 0,
	    /**
	     * 支持循环。
	     */
	    Looping = 1,
	    /**
	     * 支持clip的外推。
	     */
	    Extrapolation = 2,
	    /**
	     * 支持设置clip本地时间的偏移量。
	     */
	    ClipIn = 4,
	    /**
	     * 支持控制播放速度。
	     */
	    SpeedMultiplier = 8,
	    /**
	     * 支持混合。
	     */
	    Blending = 16,
	    /**
	     * 所有特性都支持。
	     */
	    All = -1
	}
	export enum EAnimationPlayableAssetLoopMode {
	    UseSourceAsset = 0,
	    Off = 1,
	    On = 2
	}
	export enum ETimelineClipBlendCurveMode {
	    Auto = 0,
	    Manual = 1
	}
	export enum TimelineClipExtrapolation {
	    None = 0,
	    Hold = 1,
	    Loop = 2,
	    PingPong = 3,
	    Continue = 4
	}
	export enum ETrackOffset {
	    ApplySceneOffsets = 0,
	    ApplyTransformOffsets = 1,
	    Auto = 2
	}
	export interface ITimelinePlayableAssetRootInfo {
	    name: string;
	    tracks: number[];
	    frameRate: number;
	    durationMode: TimelineAsset.DurationMode;
	    fixedDuration: number;
	}
	export interface ITimelinePlayableAssetTrackBaseInfo {
	    name: string;
	    type: EPlaybaleTrackType;
	    trackAssetTypeName?: string;
	    locked: boolean;
	    muted: boolean;
	    children: number[];
	    clips: number[];
	    trackLocalId: string;
	}
	export interface ITimelineActivationTrackInfo extends ITimelinePlayableAssetTrackBaseInfo {
	    type: EPlaybaleTrackType.Activation;
	    postPlaybackState: EPostPlaybackState;
	}
	export interface ITimelineAudioTrackInfo extends ITimelinePlayableAssetTrackBaseInfo {
	    type: EPlaybaleTrackType.Audio;
	    volume: number;
	    stereoPan: number;
	    spatialBlend: number;
	}
	export interface ITimelineAnimationTrackInfo extends ITimelinePlayableAssetTrackBaseInfo {
	    type: EPlaybaleTrackType.Animation;
	    infinityClip: string;
	    applyAvatarMask: boolean;
	    trackOffset: ETrackOffset;
	    avatarMask: string | null;
	    position: number[];
	    rotation: number[];
	    infiniteClipOffsetPosition: number[];
	    infiniteClipOffsetRotation: number[];
	    matchTargetFields: {
	        PositionX: boolean;
	        PositionY: boolean;
	        PositionZ: boolean;
	        RotationX: boolean;
	        RotationY: boolean;
	        RotationZ: boolean;
	    };
	}
	export interface ITimelineControlTrackInfo extends ITimelinePlayableAssetTrackBaseInfo {
	    type: EPlaybaleTrackType.Control;
	}
	export interface ITimelineCustomTrackInfo extends ITimelinePlayableAssetTrackBaseInfo {
	    type: EPlaybaleTrackType.Custom;
	    trackAssetTypeName: string;
	    trackAssetUUID: string;
	    [key: string]: any;
	}
	export interface ITimelinePlayableAssetClipBaseInfo {
	    start: number;
	    duration: number;
	    blendInDuration: number;
	    blendOutDuration: number;
	    clipIn: number;
	    timeScale: number;
	    mixInCurve: IHermiteCruvePoint[];
	    mixOutCurve: IHermiteCruvePoint[];
	    mixInCurveMode: ETimelineClipBlendCurveMode;
	    mixOutCurveMode: ETimelineClipBlendCurveMode;
	    postExtrapolationMode: TimelineClipExtrapolation;
	    preExtrapolationMode: TimelineClipExtrapolation;
	    postExtrapolationTime: number | "INFINITY";
	    preExtrapolationTime: number | "INFINITY";
	    type: EPlayableType;
	    playableAssetTypeName?: string;
	    data: {
	        playableAssetUUID: string;
	    };
	}
	export interface ITimelineActivationClipInfo extends ITimelinePlayableAssetClipBaseInfo {
	    type: EPlayableType.Activation;
	}
	export interface ITimelineAudioClipInfo extends ITimelinePlayableAssetClipBaseInfo {
	    type: EPlayableType.Audio;
	    data: ITimelinePlayableAssetClipBaseInfo["data"] & {
	        clip: string;
	        loop: boolean;
	        volume: number;
	    };
	}
	export interface ITimelineAnimationClipInfo extends ITimelinePlayableAssetClipBaseInfo {
	    type: EPlayableType.Animation;
	    data: ITimelinePlayableAssetClipBaseInfo["data"] & {
	        recordable: boolean;
	        clip: string;
	        applyFootIK: boolean;
	        loop: EAnimationPlayableAssetLoopMode;
	        useTrackMatchFields: boolean;
	        matchTargetFields: {
	            PositionX: boolean;
	            PositionY: boolean;
	            PositionZ: boolean;
	            RotationX: boolean;
	            RotationY: boolean;
	            RotationZ: boolean;
	        };
	        position: number[];
	        rotation: number[];
	    };
	}
	export interface ITimelineControlClipInfo extends ITimelinePlayableAssetClipBaseInfo {
	    type: EPlayableType.Activation;
	    data: ITimelinePlayableAssetClipBaseInfo["data"] & {
	        active: boolean;
	    };
	}
	export interface ITimelineCustomClipInfo extends ITimelinePlayableAssetClipBaseInfo {
	    type: EPlayableType.Custom;
	    playableAssetTypeName: string;
	    data: ITimelinePlayableAssetClipBaseInfo["data"] & {
	        [key: string]: any;
	    };
	}
	export interface IHermiteCruvePoint {
	    time: number;
	    value: number;
	    inTangent: number | "INFINITY";
	    outTangent: number | "INFINITY";
	}
	export interface ITimelinePlayableAssetInnerAnimationClipInfo {
	    positionCurves: Array<ITimelinePlayableAssetAnimationCurve>;
	    rotationCurves: Array<ITimelinePlayableAssetAnimationCurve>;
	    scaleCurves: Array<ITimelinePlayableAssetAnimationCurve>;
	}
	export interface ITimelinePlayableAssetAnimationCurve {
	    path: string;
	    curveData: IHermiteCruvePoint[];
	}
	export interface ITimelinePlayableAsset {
	    root: ITimelinePlayableAssetRootInfo;
	    trackList: Array<ITimelinePlayableAssetTrackBaseInfo | ITimelineActivationTrackInfo | ITimelineAudioTrackInfo | ITimelineAnimationTrackInfo | ITimelineControlTrackInfo | ITimelineCustomTrackInfo>;
	    clipList: Array<ITimelineActivationClipInfo | ITimelineAudioClipInfo | ITimelineAnimationClipInfo | ITimelineControlClipInfo | ITimelineCustomClipInfo>;
	}
	export default abstract class PlayableAsset {
	    abstract createPlayable(graph: PlayableGraph, owner?: any): Nullable<Playable> /** Playable */;
	    abstract get duration(): number;
	}
	export abstract class ITimelineAsset extends PlayableAsset {
	    abstract createTrack(type: EPlaybaleTrackType | string, name: string, parent: Nullable<TrackAsset>): TrackAsset;
	    abstract deleteTrack(trackAsset: TrackAsset): boolean;
	    abstract deleteClip(clip: TimelineClip): boolean;
	}
	export abstract class ITrackAsset extends PlayableAsset {
	    abstract createTrackMixer(graph: PlayableGraph): Playable;
	    abstract createClip(type: EPlayableType | string): TimelineClip;
	}
	export const DefaultDuration = 5; abstract class TimelineClipAsset extends PlayableAsset {
	    abstract get clipCaps(): ClipCaps;
	    playableAssetUUID: string;
	    get duration(): number;
	} namespace TimelineClipAsset { }
	export { TimelineClipAsset };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/activation/activationPlayableAsset' {
	import { ClipCaps, TimelineClipAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph'; class ActivationPlayableAsset extends TimelineClipAsset {
	    /**
	     * @override
	     * @readonly
	     * @memberof ActivationPlayableAsset
	     */
	    get clipCaps(): ClipCaps;
	    /**
	     * 创建Playable实例。
	     * @override
	     *
	     * @param {PlayableGraph} graph
	     * @returns {Playable}
	     * @memberof ActivationPlayableAsset
	     */
	    createPlayable(graph: PlayableGraph): Playable;
	} namespace ActivationPlayableAsset { }
	export default ActivationPlayableAsset;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationMixerPlayable' {
	import AvatarMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatarMask';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Animator from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import type { FrameData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/interface';
	import PlayableBehaviour from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBehaviour';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import { AnimationUtility } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Utility';
	export class AnimationMixerPlayable extends Playable {
	    animator?: Animator;
	    layerIndex: number;
	    staticAnimatorNativeMixer: Nullable<AnimationUtility.IAnimationCore>;
	    get applyAvatarMask(): boolean;
	    set applyAvatarMask(val: boolean);
	    get avatarMask(): Nullable<AvatarMask>;
	    set avatarMask(val: Nullable<AvatarMask>);
	}
	export default class AnimationMixerPlayableBehaviour extends PlayableBehaviour {
	    static PlayableClass: typeof AnimationMixerPlayable;
	    static Create(graph: PlayableGraph): AnimationMixerPlayable;
	    ProcessFrame(playable: AnimationMixerPlayable, info: FrameData, playerData: any): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationClipPlayable' {
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import AnimatorState from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorState';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	export default class AnimationClipPlayable extends Playable {
	    hasAddDummyParent: boolean;
	    get frameIndex(): number;
	    get animationClip(): AnimationClip;
	    set animationClip(val: AnimationClip);
	    get animatorState(): AnimatorState | undefined;
	    set animatorState(val: AnimatorState | undefined);
	    constructor(graph: PlayableGraph);
	    static Create(graph: PlayableGraph, clip: AnimationClip): AnimationClipPlayable;
	    evaluateAt(localTime: number): void;
	    updateFrameIndex(): void;
	    addDummyParent(): void;
	    removeDummyParent(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationPlayableAsset' {
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import { ClipCaps, EAnimationPlayableAssetLoopMode, TimelineClipAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import AnimationClipPlayable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationClipPlayable';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Quaternion from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion'; class AnimationPlayableAsset extends TimelineClipAsset {
	    matchTargetFields: {
	        PositionX: boolean;
	        PositionY: boolean;
	        PositionZ: boolean;
	        RotationX: boolean;
	        RotationY: boolean;
	        RotationZ: boolean;
	    };
	    get clip(): Nullable<AnimationClip>;
	    set clip(val: Nullable<AnimationClip>);
	    get loop(): EAnimationPlayableAssetLoopMode;
	    set loop(val: EAnimationPlayableAssetLoopMode);
	    get recordable(): boolean;
	    set recordable(val: boolean);
	    get position(): Vector3;
	    set position(val: Vector3);
	    get rotation(): Quaternion;
	    set rotation(val: Quaternion);
	    get clipCaps(): ClipCaps;
	    createPlayable(graph: PlayableGraph): AnimationClipPlayable;
	} namespace AnimationPlayableAsset { }
	export default AnimationPlayableAsset;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioPlayer' {
	export default class AudioPlayer {
	    get canplay(): boolean;
	    get isDestroyed(): boolean;
	    get isSeeking(): boolean;
	    get loop(): boolean;
	    set loop(v: boolean);
	    get duration(): number;
	    get src(): string;
	    set src(v: string);
	    get volume(): number;
	    set volume(v: number);
	    get obeyMuteSwitch(): boolean;
	    set obeyMuteSwitch(v: boolean);
	    get currentTime(): number;
	    get paused(): boolean;
	    static create(): AudioPlayer;
	    constructor();
	    play(): void;
	    stop(): void;
	    seek(v: number): void;
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/shared' {
	import { ISerializedObject } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/deserialize';
	/**
	 * @export
	 * @param {void} this
	 * @param {(any | any)} target
	 * @param {{ [key: string]: any }} [context]
	 * @param {boolean} [targetIsResource]
	 * @returns {(ISerializedObject | ISerializedObject["data"])}
	 */
	export function Serialize(this: void, target: any | any, context?: {
	    [key: string]: any;
	}, targetIsResource?: boolean /** scriptableAsset的情况下，资源也要走通用序列还模版的能力 不能直接返回uuid */): ISerializedObject | ISerializedObject["data"];

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; abstract class AudioBaseNode {
	    /**
	     * 节点id
	     * @memberof AudioBaseNode
	     */
	    get id(): string;
	    set id(val: string);
	    /**
	     * 节点名称
	     * @memberof AudioBaseNode
	     */
	    get name(): string;
	    /**
	     * 节点主路路由输入接口
	     * @memberof AudioBaseNode
	     */
	    get input(): Nullable<AudioNode>;
	    /**
	     * 节点主路路由输出接口
	     * @memberof AudioBaseNode
	     */
	    get output(): Nullable<AudioNode>;
	    /**
	     * 节点侧链路由输出接口
	     * @memberof AudioBaseNode
	     */
	    get outputSideChain(): Nullable<AudioNode>;
	    /**
	     * 节点主路路由输出信号的接收者节点列表
	     * @memberof AudioBaseNode
	     */
	    get outputList(): AudioBaseNode[];
	    /**
	     * 节点主路路由输入信号的发送者节点列表
	     * @memberof AudioBaseNode
	     */
	    get inputList(): AudioBaseNode[];
	    /**
	     * 节点侧链输入信号的发送者列表
	     * @memberof AudioBaseNode
	     */
	    get sideChainInputList(): AudioBaseNode[][];
	    /**
	     * 节点侧链输出信号的接收者节点列表。列表描述了信号被哪些节点的哪个侧链接口所接收。
	     * @memberof AudioBaseNode
	     */
	    get outputSideChainList(): Map<AudioNode | AudioParam, AudioBaseNode.ISideChainInterfaceInfo>;
	    /**
	     * 节点的侧链接口数量
	     * @memberof AudioBaseNode
	     */
	    get numberOfSideChain(): number;
	    /**
	     * 节点的创造者。即节点被谁创造
	     * @memberof AudioBaseNode
	     */
	    get creator(): any;
	    set creator(val: any);
	    /**
	     * 节点是否已销毁
	     * @memberof AudioBaseNode
	     */
	    get isDestroyed(): boolean;
	    /**
	     * 构造函数
	     * @param creator 节点的创建者。可为空。
	     * @memberof AudioBaseNode
	     */
	    constructor(creator?: any);
	    /**
	     * 根据参数名，获取可被快照捕获的参数（即该参数可应用Transition）对应的id
	     * @param name
	     * @memberof AudioBaseNode
	     */
	    getParameterIdByName(name: string): string;
	    /**
	     * 根据索引获取侧链接口
	     * @param {number} index 侧链接口索引
	     * @memberof AudioBaseNode
	     */
	    getSideChain(index: number): AudioNode | AudioParam | null;
	    /**
	     * 断开与指定节点在主路路由上的输出链接。则主路路由信号不会再输出到该节点。
	     * @param {AudioBaseNode} destination 需要断开链接的节点。为空则表示断开主路路由所有输出链接。
	     * @memberof AudioBaseNode
	     */
	    disconnect(destination?: AudioBaseNode): void;
	    /**
	     * 断开侧链所有输出链接
	     * @memberof AudioBaseNode
	     */
	    disconnectSideChain(): void;
	    /**
	     * 断开与指定侧链接口的输出链接
	     * @param {AudioParam | AudioNode} sideChain 需要断开的侧链接口。可以为被封装过的WebAudio AudioParam对象，或被封装过的WebAudio AudioNode对象
	     * @memberof AudioBaseNode
	     */
	    disconnectSideChain(sideChain: AudioParam | AudioNode): void;
	    /**
	     * 断开与指定节点的所有侧链接口的输出链接
	     * @param {AudioBaseNode} baseNode 需要断开所有侧链接口输出链接的节点
	     * @memberof AudioBaseNode
	     */
	    disconnectSideChain(baseNode: AudioBaseNode): void;
	    /**
	     * 断开与指定节点的指定侧链接口的输出链接
	     * @param {AudioBaseNode} baseNode 需要断开侧链接口输出链接的节点
	     * @param {number} sideChainIndex 侧链接口索引
	     * @memberof AudioBaseNode
	     */
	    disconnectSideChain(baseNode: AudioBaseNode, sideChainIndex: number): void;
	    /**
	     * 断开与指定节点的主路路由输入链接。
	     * @param {AudioBaseNode} source 需要断开链接的节点。为空则表示断开主路路由所有输入链接
	     * @memberof AudioBaseNode
	     */
	    disconnectSource(source?: AudioBaseNode): void;
	    /**
	     * 断开所有侧链接口的所有输入链接
	     * @memberof AudioBaseNode
	     */
	    disconnectSideChainSource(): void;
	    /**
	     * 断开指定侧链接口的所有输入链接
	     * @param {number} index 侧链接口索引
	     * @memberof AudioBaseNode
	     */
	    disconnectSideChainSource(index: number): void;
	    /**
	     * 断开指定侧链接口与指定节点的链接
	     * @param {AudioBaseNode} source 输入信号节点
	     * @param {number} index 侧链接口索引
	     * @memberof AudioBaseNode
	     */
	    disconnectSideChainSource(source: AudioBaseNode, index: number): any;
	    /**
	     * 与指定节点创建主路路由链接。即将主路路由信号输出指定节点
	     * @param {AudioBaseNode} destination 需要链接的节点
	     * @memberof AudioBaseNode
	     */
	    connect(destination: AudioBaseNode): void;
	    /**
	     * 与指定节点的指定侧链接口创建链接。即将信号输出到指定节点的指定侧链接口。
	     * @param {AudioBaseNode} destination 需要链接的节点
	     * @param {number} index 侧链索引
	     * @memberof AudioBaseNode
	     */
	    connectSideChain(destination: AudioBaseNode, index: number): void;
	    /**
	     * 接收指定节点的主路路由信号
	     * @param {AudioBaseNode} source 信号源节点
	     * @memberof AudioBaseNode
	     */
	    connectSource(source: AudioBaseNode): void;
	    /**
	     * 以本节点指定侧链接口，接收指定节点的信号
	     * @param {AudioBaseNode} source 信号源节点
	     * @param {number} 本节点侧链节点索引
	     * @memberof AudioBaseNode
	     */
	    connectSideChainSource(source: AudioBaseNode, index: number): void;
	    /**
	     * 销毁节点。
	     * @memberof AudioBaseNode
	     */
	    destroy(): void;
	} namespace AudioBaseNode {
	    /**
	     * 节点侧链接口
	     */
	    interface ISideChainInterfaceInfo {
	        /**
	         * 音频节点对象
	         */
	        node: AudioBaseNode;
	        /**
	         * 节点的侧链接口索引
	         */
	        index: number;
	    }
	}
	export default AudioBaseNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioListenerNode' {
	import AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode'; class AudioListenerNode extends AudioBaseNode {
	    /**
	     * 是否启用音频监听器节点。
	     * true：启用。接收输入信号
	     * false：禁用。不接收输入信号
	     * @memberof AudioListenerNode
	     */
	    get active(): boolean;
	    set active(val: boolean);
	    /**
	     * 将接收到的信号输出到音频硬件设备
	     * @memberof AudioListenerNode
	     */
	    connect(): void;
	    /**
	     * 不将接收到的信号输出到音频硬件设备
	     * @memberof AudioListenerNode
	     */
	    disconnect(): void;
	} namespace AudioListenerNode { }
	export default AudioListenerNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioListener' {
	import AudioEffectComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectComponent'; class AudioListener extends AudioEffectComponent {
	} namespace AudioListener { }
	export default AudioListener;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode'; abstract class AudioEffectNode extends AudioBaseNode {
	    /**
	     * 是否绕过音效。
	     * true：绕过。即禁用音效。
	     * false: 不绕过。即启用音效。
	     * @memberof AudioEffectNode
	     */
	    get bypass(): boolean;
	    set bypass(val: boolean);
	    /**
	     * 节点主路路由输入接口
	     * @memberof AudioEffectNode
	     */
	    get input(): AudioNode | null;
	    /**
	     * 节点主路路由输出接口
	     * @memberof AudioEffectNode
	     */
	    get output(): AudioNode | null;
	    /**
	     * 节点侧链路由输出接口
	     * @memberof AudioEffectNode
	     */
	    get outputSideChain(): AudioNode | null;
	    /**
	     * 销毁节点。
	     * @memberof AudioEffectNode
	     */
	    destroy(): void;
	} namespace AudioEffectNode { }
	export default AudioEffectNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioPannerNode' {
	import AudioEffectNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode'; enum PannerDistanceModelEnum {
	    /**
	     * 反函数衰减模型。近距离时音量衰减较大，远距离时音量衰减较小。它适用于以下情况：可以在远距离听到，但当听者非常靠近声源时，音量会显著增加。
	     */
	    'inverse' = "inverse",
	    /**
	     * 指数函数衰减模型。类似于inverse。当rolloffFactor属性值大于1时，音量衰减比inverse衰减快。当rolloffFactor属性值小于1时，音量衰减比inverse衰减慢。当rolloffFactor属性值等于1时，音量衰减和inverse一模一样。
	     */
	    'exponential' = "exponential",
	    /**
	     * 线性衰减模型。音量将线性衰减。当AudioListener接近和远离AudioSource时，音量变化值将保持恒定。适用于不需要严格聚焦3D空间衰减设置的大型背景声音效果之间的淡入淡出。
	     */
	    'linear' = "linear"
	} enum PanningModelEnum {
	    /**
	     * 等功率平移空间化算法，简单高效，性能开销较少。
	     */
	    'equalpower' = "equalpower",
	    /**
	     * 质量更高的空间化算法，使用卷积法测量人体受试者的脉冲响应，性能开销较大。
	     */
	    'HRTF' = "HRTF"
	} class AudioPannerNode extends AudioEffectNode {
	    /**
	     * 2D声音的左右声道。
	     * 值-1：只有左声道；值0：双声道；值1：只有右声道
	     * @memberof AudioPannerNode
	     */
	    get stereoPan(): number;
	    set stereoPan(val: number);
	    /**
	     * 3D空间对音频源的影响程度。
	     * 值0：只有2D声音，忽略所有3D空间音效的影响；值1：完全3D音效。
	     * @memberof AudioPannerNode
	     */
	    get spatialBlend(): number;
	    set spatialBlend(val: number);
	    /**
	     * 在3D空间里，声音在播放方向上的圆锥体角度，以度为单位。
	     * 音频系统使用圆锥体来描述声音的传播方向。在此属性定义的圆锥体内，音量不会降低，即声音不受coneOuterGain属性影响（但是声音还是会受到距离和其他音效的影响）。
	     * 值360：表示声音向任意方向传播，即在任意方向上均可听到该声音。
	     * @memberof AudioPannerNode
	     */
	    get coneInnerAngle(): number;
	    set coneInnerAngle(val: number);
	    /**
	     * 在3D空间里，声音在播放方向上的圆锥体角度，以度为单位。
	     * 在此属性定义的圆锥体外，音量将减少到恒定的coneOuterGain属性定义的值。
	     * 值360：表示声音在任意方向上音量都不会受到coneOuterGain属性影响而减少（但是声音还是会受到距离和其他音效的影响）。
	     * @memberof AudioPannerNode
	     */
	    get coneOuterAngle(): number;
	    set coneOuterAngle(val: number);
	    /**
	     * 在3D空间里，声音在coneOuterAngle属性定义的圆锥体外的音量衰减值。
	     * 值1：表示不衰减；值0：表示静音。
	     * @memberof AudioPannerNode
	     */
	    get coneOuterGain(): number;
	    set coneOuterGain(val: number);
	    /**
	     * 计算3D空间音效所使用的算法。
	     * @memberof AudioPannerNode
	     */
	    get panningModel(): AudioPannerNode.PanningModel;
	    set panningModel(val: AudioPannerNode.PanningModel);
	    /**
	     * 3D空间音效里，音量随距离变化而变化的算法模型
	     * @memberof AudioPannerNode
	     */
	    get distanceModel(): AudioPannerNode.PannerDistanceModel;
	    set distanceModel(val: AudioPannerNode.PannerDistanceModel);
	    /**
	     * 此属性是distanceModel定义的算法中的一个因子。
	     * @memberof AudioPannerNode
	     */
	    get rolloffFactor(): number;
	    set rolloffFactor(val: number);
	    /**
	     * 在3D空间里，当AudioSource和AudioListener之间的距离小于该值，音量不因距离而衰减。若距离大于该值，声音开始衰减。
	     * @memberof AudioPannerNode
	     */
	    get minDistance(): number;
	    set minDistance(val: number);
	    /**
	     * 在3D空间里，当AudioSource和AudioListener之间的距离大于该值，音量保持不变，不再衰减。
	     * @memberof AudioPannerNode
	     */
	    get maxDistance(): number;
	    set maxDistance(val: number);
	    /**
	     * 在3D空间里，音源朝向X坐标
	     * @memberof AudioPannerNode
	     */
	    get orientationX(): number;
	    set orientationX(val: number);
	    /**
	     * 在3D空间里，音源朝向Y轴坐标
	     * @memberof AudioPannerNode
	     */
	    get orientationY(): number;
	    set orientationY(val: number);
	    /**
	     * 在3D空间里，音源朝向Z轴坐标
	     * @memberof AudioPannerNode
	     */
	    get orientationZ(): number;
	    set orientationZ(val: number);
	    /**
	     * 在3D空间里，音源位置X坐标
	     * @memberof AudioPannerNode
	     */
	    get positionX(): number;
	    set positionX(val: number);
	    /**
	     * 在3D空间里，音源位置Y坐标
	     * @memberof AudioPannerNode
	     */
	    get positionY(): number;
	    set positionY(val: number);
	    /**
	     * 在3D空间里，音源位置Z坐标
	     * @memberof AudioPannerNode
	     */
	    get positionZ(): number;
	    set positionZ(val: number);
	    /**
	     * 构造函数
	     * @param creator 节点创造者，可为空。
	     * @memberof AudioPannerNode
	     */
	    constructor(creator?: any);
	    /**
	     * 销毁节点
	     * @memberof AudioPannerNode
	     */
	    destroy(): void;
	} namespace AudioPannerNode {
	    /**
	     * 定义3D空间音效距离模型。
	     */
	    export import PannerDistanceModel = PannerDistanceModelEnum;
	    /**
	     * 定义计算3D空间音效可以使用的模型。
	     */
	    export import PanningModel = PanningModelEnum;
	    /**
	     * 3D空间音效节点类对象被创建时的参数默认值
	     */
	    const DEFUALT_VALUE: Readonly<{
	        /**
	         * 设置2D声音的左右声道。值-1：只有左声道；值0：双声道；值1：只有右声道
	         */
	        stereoPan: number;
	        /**
	         * 设置 3D 空间对音频源的影响程度。值0：只有2D声音，忽略所有3D空间音效的影响；值1：完全3D音效。
	         */
	        spatialBlend: number;
	        /**
	         * 设置使用的距离模型。
	         */
	        distanceModel: PannerDistanceModel;
	        /**
	         * 设置计算3D空间音效所使用的模型。
	         */
	        panningModel: PanningModel;
	        /**
	         * 即minDistance。distanceModel的最小参考距离。
	         */
	        refDistance: number;
	        /**
	         * distanceModel的最大参考距离
	         */
	        maxDistance: number;
	        /**
	         * distanceModel模型的一个因子。
	         */
	        rolloffFactor: number;
	        /**
	         * 设置声音在播放方向上的圆锥体角度，以度为单位。音频系统使用圆锥体来描述声音的传播方向。在此属性定义的圆锥体内，音量不会降低，即声音不受coneOuterGain属性影响（但是声音还是会受到距离和其他音效的影响）。值360：表示声音向任意方向传播，即在任意方向上均可听到该声音。
	         */
	        coneInnerAngle: number;
	        /**
	         * 设置声音在播放方向上的圆锥体角度，以度为单位。在此属性定义的圆锥体外，音量将减少到恒定的coneOuterGain属性定义的值。值360：表示声音在任意方向上音量都不会受到coneOuterGain属性影响而减少（但是声音还是会受到距离和其他音效的影响）
	         */
	        coneOuterAngle: number;
	        /**
	         * 设置声音在coneOuterAngle属性定义的圆锥体外的音量衰减值。注意，此属性值是无单位的。值1：表示不衰减；值0：表示静音。
	         */
	        coneOuterGain: number;
	    }>;
	}
	export default AudioPannerNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilterNode' {
	import AudioEffectNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode'; enum BiquadFilterTypeEnum {
	    /**
	     * 标准二阶谐振低通滤波器。具有12dB衰减。截止频率以下的频率通过；高于它的频率被衰减。
	     */
	    lowpass = "lowpass",
	    /**
	     * 标准二阶谐振高通滤波器，具有12dB衰减。截止频率以下的频率被衰减；高于它的频率通过。
	     */
	    highpass = "highpass",
	    /**
	     * 标准的二阶带通滤波器。超出给定频率范围的频率会衰减；它内部的频率通过。
	     */
	    bandpass = "bandpass",
	    /**
	     * 低频搁架滤波。低于指定频率的频率会衰减或增强，高于指定频率的频率不变
	     */
	    lowshelf = "lowshelf",
	    /**
	     * 高频搁架滤波。高于指定频率的频率会衰减或增强，低于指定频率的频率不变
	     */
	    highshelf = "highshelf",
	    /**
	     * 范围内的频率会增加或衰减。外面的频率不变。
	     */
	    peaking = "peaking",
	    /**
	     * 标准陷波滤波器，也称为带阻或带阻滤波器。它与带通滤波器相反
	     */
	    notch = "notch",
	    /**
	     * 标准二阶全通滤波器。它允许所有频率通过，但会更改各个频率之间的相位关系。
	     */
	    allpass = "allpass"
	} class AudioBiquadFilterNode extends AudioEffectNode {
	    /**
	     * 滤波器Q品质值。
	     * @memberof AudioBiquadFilterNode
	     */
	    get Q(): number;
	    set Q(val: number);
	    /**
	     * 失谐。音分为单位。
	     * @memberof AudioBiquadFilterNode
	     */
	    get detune(): number;
	    set detune(val: number);
	    /**
	     * 截止频率。
	     * @memberof AudioBiquadFilterNode
	     */
	    get frequency(): number;
	    set frequency(val: number);
	    /**
	     * 衰减或增益。
	     * @memberof AudioBiquadFilterNode
	     */
	    get gain(): number;
	    set gain(val: number);
	    /**
	     * 滤波器类型。
	     * @memberof AudioBiquadFilterNode
	     */
	    get type(): AudioBiquadFilterNode.BiquadFilterType;
	    set type(val: AudioBiquadFilterNode.BiquadFilterType);
	    /**
	     * 构建函数。
	     * @param creator 节点创造者。可为空。
	     * @memberof AudioBiquadFilterNode
	     */
	    constructor(creator: any);
	} namespace AudioBiquadFilterNode {
	    /**
	     * 定义双二阶滤波器支持的类型
	     */
	    export import BiquadFilterType = BiquadFilterTypeEnum;
	    /**
	     * 双二阶滤波器音效节点对象被创建时的参数默认值
	     */
	    const DEFUALT_VALUE: Readonly<{
	        /**
	         * 滤波器Q品质值。范围：0.0001 至 1000。
	         */
	        Q: number;
	        /**
	         * 失谐。音分为单位。范围：−153600 至 153600。
	         */
	        detune: number;
	        /**
	         * 截止频率。范围：10 至 22000
	         */
	        frequency: number;
	        /**
	         * 衰减或增益，单位DB。范围：-40 至 40。
	         */
	        gain: number;
	        /**
	         * 滤波器类型
	         */
	        type: BiquadFilterType;
	    }>;
	}
	export default AudioBiquadFilterNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilter' {
	import AudioEffectComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectComponent'; class AudioBiquadFilter extends AudioEffectComponent {
	    /**
	     * 截止频率
	     * @memberof AudioBiquadFilter
	     */
	    get frequency(): number;
	    set frequency(val: number);
	    /**
	     * 滤波器品质值
	     * @memberof AudioBiquadFilter
	     */
	    get Q(): number;
	    set Q(val: number);
	} namespace AudioBiquadFilter { }
	export default AudioBiquadFilter;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioLowPassFilter' {
	import AudioBiquadFilter from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilter'; class AudioLowPassFilter extends AudioBiquadFilter {
	} namespace AudioLowPassFilter { }
	export default AudioLowPassFilter;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioLowPassFilterNode' {
	import AudioBiquadFilterNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilterNode';
	import AudioEffectNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode'; class AudioLowPassFilterNode extends AudioEffectNode {
	    static readonly EffectName = "Lowpass";
	    /**
	     * 低通截止频率，单位为赫兹（范围从 10 至 22000，默认350）。
	     * @memberof AudioLowPassFilterNode
	     */
	    get frequency(): number;
	    set frequency(val: number);
	    /**
	     * 低通滤波器品质值（范围从 0.0001 至 100，默认1）。
	     * 控制在截止频率下，由于共振令原始信号放大而达到的峰值。
	     * Q值越大峰值越大，即在截止频率附近对原始信号影响越大。但Q值越大，滚降范围越窄，滤波器的过滤效果更好。
	     * @memberof AudioLowPassFilterNode
	     */
	    get Q(): number;
	    set Q(val: number);
	    /**
	     * 构造函数
	     * @param creator 节点创造者。可为空
	     * @memberof AudioLowPassFilterNode
	     */
	    constructor(creator: any);
	} namespace AudioLowPassFilterNode { }
	export default AudioLowPassFilterNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioHighPassFilter' {
	import AudioBiquadFilter from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilter'; class AudioHighPassFilter extends AudioBiquadFilter {
	} namespace AudioHighPassFilter { }
	export default AudioHighPassFilter;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioHighPassFilterNode' {
	import AudioBiquadFilterNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilterNode';
	import AudioEffectNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode'; class AudioHighPassFilterNode extends AudioEffectNode {
	    static readonly EffectName = "Highpass";
	    /**
	     * 高通截止频率，单位为赫兹（范围从 10 至 22000，默认350）
	     * @memberof AudioHighPassFilterNode
	     */
	    get frequency(): number;
	    set frequency(val: number);
	    /**
	     * 高通滤波器品质值（范围从 0.0001 至 100，默认1）。
	     * 控制在截止频率下，由于共振令原始信号放大而达到的峰值。
	     * Q值越大峰值越大，即在截止频率附近对原始信号影响越大。但Q值越大，滚降范围越窄，滤波器的过滤效果更好。
	     * @memberof AudioHighPassFilterNode
	     */
	    get Q(): number;
	    set Q(val: number);
	    /**
	     * 构造函数
	     * @param creator 节点创造者。可为空
	     * @memberof AudioHighPassFilterNode
	     */
	    constructor(creator?: any);
	} namespace AudioHighPassFilterNode { }
	export default AudioHighPassFilterNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioDistortionNode' {
	import AudioEffectNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode'; class AudioDistortionNode extends AudioEffectNode {
	    /**
	     * 失真程度。
	     * @memberof AudioDistortionNode
	     */
	    get level(): number;
	    set level(val: number);
	} namespace AudioDistortionNode {
	    /**
	     * 定义失真音效名称
	     */
	    const EffectName = "Distortion";
	    /**
	     * 失真音效节点对象被创建时的参数默认值
	     */
	    const DEFUALT_VALUE: Readonly<{
	        /**
	         * 失真程度。范围：0 - 1。
	         */
	        level: number;
	    }>;
	}
	export default AudioDistortionNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioDistortion' {
	import AudioEffectComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectComponent'; class AudioDistortion extends AudioEffectComponent {
	    /**
	     * 失真程度。
	     * @memberof AudioDistortion
	     */
	    get level(): number;
	    set level(val: number);
	} namespace AudioDistortion { }
	export default AudioDistortion;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioEchoNode' {
	import AudioEffectNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode'; class AudioEchoNode extends AudioEffectNode {
	    /**
	     * 回声延时，以 ms 为单位。取值 > 0。
	     * @memberof AudioEchoNode
	     */
	    get delay(): number;
	    set delay(val: number);
	    /**
	     * 每次延时的回声衰减率。范围 [0, 1]。
	     * 值1：表示无衰减，值0：表示完全衰减。
	     * @memberof AudioEchoNode
	     */
	    get decay(): number;
	    set decay(val: number);
	    /**
	     * 输出的回声信号量。范围 [0, 1]。
	     * @memberof AudioEchoNode
	     */
	    get dryMix(): number;
	    set dryMix(val: number);
	    /**
	     * 输出的原始信号量。范围 [0, 1]。
	     * @memberof AudioEchoNode
	     */
	    get wetMix(): number;
	    set wetMix(val: number);
	    /**
	     * 构造函数
	     * @param creator 节点创建者。可为空
	     * @memberof AudioEchoNode
	     */
	    constructor(creator?: any);
	    destroy(): void;
	} namespace AudioEchoNode {
	    /**
	     * 定义回声音效名称。
	     */
	    const EffectName = "Echo";
	    /**
	     * 回声音效节点对象被创建时的参数默认值
	     */
	    const DEFUALT_VALUE: Readonly<{
	        /**
	         * 回声延时，单位毫秒。
	         */
	        delay: number;
	        /**
	         * 每次延时的回声衰减率，范围：0 至 1。0：完全衰减，1：完全不衰减。
	         */
	        decay: number;
	        /**
	         * 输出的回声信号量。范围：0 至 1。
	         */
	        dryMix: number;
	        /**
	         * 输出的原始信号量。范围：0 至 1。
	         */
	        wetMix: number;
	    }>;
	}
	export default AudioEchoNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioEcho' {
	import AudioEffectComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectComponent'; class AudioEcho extends AudioEffectComponent {
	    /**
	     * 回声延时，以 ms 为单位。取值 > 0。
	     * @memberof AudioEcho
	     */
	    get delay(): number;
	    set delay(val: number);
	    /**
	     * 每次延时的回声衰减率。范围 [0, 1]。
	     * 值1：表示无衰减，值0：表示完全衰减。
	     * @memberof AudioEcho
	     */
	    get decay(): number;
	    set decay(val: number);
	    /**
	     * 输出的回声信号量。范围 [0, 1]。
	     * @memberof AudioEcho
	     */
	    get dryMix(): number;
	    set dryMix(val: number);
	    /**
	     * 输出的原始信号量。范围 [0, 1]。
	     * @memberof AudioEcho
	     */
	    get wetMix(): number;
	    set wetMix(val: number);
	} namespace AudioEcho { }
	export default AudioEcho;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioSendNode' {
	import AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; class AudioSendNode extends AudioBaseNode {
	    /**
	     * 发送多少信号到 接收者里
	     * @memberof AudioSendNode
	     */
	    get sendLevel(): number;
	    set sendLevel(val: number);
	    /**
	     * 构造函数
	     * @param creator 节点创造者，可为空。
	     * @memberof AudioSendNode
	     */
	    constructor(creator?: any);
	} namespace AudioSendNode {
	    /**
	     * 定义发送音效名称。
	     */
	    const EffectName = "Send";
	}
	export default AudioSendNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSimpleNode' {
	import AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode';
	/**
	 * 一个简单的音频节点。没有侧链接口。主路路由输入接口=输出接口。
	 * @class AudioSimpleNode
	 * @category Audio
	 */
	export default class AudioSimpleNode extends AudioBaseNode {
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioReceiveNode' {
	import AudioSimpleNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSimpleNode'; class AudioReceiveNode extends AudioSimpleNode {
	} namespace AudioReceiveNode {
	    /**
	     * 定义接收音效名称。
	     */
	    const EffectName = "Receive";
	}
	export default AudioReceiveNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/util' {
	/**
	 * snapshot cosin等功率算法
	 * @param {number} v0 初始值
	 * @param {number} v1 目标值
	 * @param {number} normalTime 标准化后的变化时间。0 - 1
	 */
	export function cosinEqualPower(v0: number, v1: number, normalTime: number): number;
	/**
	 * snapshot平方根等功率算法
	 * @param {number} v0 初始值
	 * @param {number} v1 目标值
	 * @param {number} normalTime 标准化后的变化时间。0 - 1
	 */
	export function squareRootEqualPower(v0: number, v1: number, normalTime: number): number;
	/**
	 * snapshot smoothstep平滑算法
	 * @param {number} v0 初始值
	 * @param {number} v1 目标值
	 * @param {number} normalTime 标准化后的变化时间。0 - 1
	 */
	export function smoothstep(v0: number, v1: number, normalTime: number): number;
	/**
	 * snapshot线性过渡算法
	 * @param {number} v0 初始值
	 * @param {number} v1 目标值
	 * @param {number} normalTime 标准化后的变化时间。0 - 1
	 */
	export function linearRamp(v0: number, v1: number, normalTime: number): number;
	/**
	 * snapshot Exponential 算法
	 * @param {number} v0 初始值
	 * @param {number} v1 目标值
	 * @param {number} normalTime 标准化后的变化时间。0 - 1
	 */
	export function exponential(v0: number, v1: number, normalTime: number): number;
	/**
	 * snapshot ExponentiallyApproaching 算法。该算法会在normalTime=1时达到v1的99.99%
	 * @param {number} v0 初始值
	 * @param {number} v1 目标值
	 * @param {number} normalTime 标准化后的变化时间。0 - 1
	 */
	export function exponentiallyApproaching(v0: number, v1: number, normalTime: number): number;
	/**
	 * 根据normalTime，从曲线curve中获取对应的线性插值后的值
	 * @param {Array<number>} curve 曲线
	 * @param {number} normalTime 标准化后的变化时间。0 - 1
	 */
	export function curveLinearInterpolat(curve: Array<number>, normalTime: number): number;
	/**
	 * 获取变形曲线
	 * @param {Function} mapping
	 * @param {number} length 曲线数组长度
	 * @returns {Float32Array} 返回变形曲线数组
	 */
	export function getWaveShaperCurve(mapping: (normalized: number, index: number, length: number, array: Float32Array) => number, length?: number): Float32Array;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioDuckNode' {
	import AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; class AudioDuckNode extends AudioBaseNode {
	    /**
	     * 声音压缩阈值。
	     * 当主路路由和侧链的混合信号（混合程度取决于sideChainMix属性的值）分贝值高于threshold属性值，则使用threshold值压缩主路路由信号（压缩分贝值高于threshold值的信号）。
	     * 如果混合信号分贝值低于threshold属性值，不压缩主路路由信号。
	     * 范围从 -80 至 0，单位dB。
	     * @memberof AudioDuckNode
	     */
	    get threshold(): number;
	    set threshold(val: number);
	    /**
	     * 压缩主路路由信号时使用的压缩比率。即输入多少dB增益变化，以产生1dB的输出变化。
	     * ratio越大，压缩效果越明显，压缩后声音越小。
	     * 范围从 1 至 20。
	     * @memberof AudioDuckNode
	     */
	    get ratio(): number;
	    set ratio(val: number);
	    /**
	     * 压缩主路路由信号时，降低增益10dB所需时间。
	     * 范围 0 至 1000，单位毫秒。
	     * @memberof AudioDuckNode
	     */
	    get attack(): number;
	    set attack(val: number);
	    /**
	     * 压缩主路路由信号时，升高增益10dB所需时间。
	     * 范围 0 至 1000，单位毫秒。
	     * @memberof AudioDuckNode
	     */
	    get release(): number;
	    set release(val: number);
	    /**
	     * 被压缩后的主路路由信号的补偿增益。
	     * 范围 -80 至 40，单位dB。
	     * @memberof AudioDuckNode
	     */
	    get makeUpGain(): number;
	    set makeUpGain(val: number);
	    /**
	     * 压缩主路路由信号时，使信号变成压缩比率ratio定义的信号的平滑变化程度。
	     * knee值越大，越平滑。
	     * 范围 0 至 40。
	     * @memberof AudioDuckNode
	     */
	    get knee(): number;
	    set knee(val: number);
	    /**
	     * 主路路由和侧链的信号混合程度。范围 0 至 1 。
	     * 值0：表示完全使用主路路由信号控制压缩器。
	     * 值1：表示完全使用侧链信号控制压缩器。
	     * @memberof AudioDuckNode
	     */
	    get sideChainMix(): number;
	    set sideChainMix(val: number);
	    set sourceMix(val: number);
	    /**
	     * 构造函数
	     * @param creator 音效节点创建者。可为空
	     * @memberof AudioDuckNode
	     */
	    constructor(creator?: any);
	    /**
	     * 销毁节点。
	     * @memberof AudioDuckNode
	     */
	    destroy(): void;
	} namespace AudioDuckNode {
	    /**
	     * 定义闪避音效名称。
	     */
	    const EffectName = "Duck Volume";
	}
	export default AudioDuckNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioAttenuationNode' {
	import AudioSimpleNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSimpleNode'; class AudioAttenuationNode extends AudioSimpleNode {
	    /**
	     * 控制信号衰减和增益程度
	     * @memberof AudioAttenuationNode
	     */
	    get volume(): number;
	    set volume(val: number);
	} namespace AudioAttenuationNode {
	    /**
	     * 定义衰减音效名称
	     */
	    const EffectName = "Attenuation";
	}
	export default AudioAttenuationNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/Audio' {
	import { ISnapshotParamConfig } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators';
	import AudioListenerClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioListener';
	import AudioSourceClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSource';
	import AudioEffectComponentClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectComponent';
	import AudioEffectNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode';
	import AudioBaseNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode';
	import AudioListenerNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioListenerNode';
	import AudioSourceNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSourceNode';
	import AudioPannerNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioPannerNode';
	import AudioLowPassFilterClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioLowPassFilter';
	import AudioLowPassFilterNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioLowPassFilterNode';
	import AudioHighPassFilterClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioHighPassFilter';
	import AudioHighPassFilterNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioHighPassFilterNode';
	import AudioBiquadFilterClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilter';
	import AudioBiquadFilterNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioBiquadFilterNode';
	import AudioDistortionNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioDistortionNode';
	import AudioDistortionClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioDistortion';
	import AudioEchoNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioEchoNode';
	import AudioEchoClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioEcho';
	import AudioSendNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioSendNode';
	import AudioReceiveNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioReceiveNode';
	import AudioDuckNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioDuckNode';
	import AudioAttenuationNodeClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioAttenuationNode'; namespace Audio {
	    /**
	     * 音频节点基类。
	     */
	    export import AudioBaseNode = AudioBaseNodeClass;
	    /**
	     * 音效节点类的基类。
	     */
	    export import AudioEffectNode = AudioEffectNodeClass;
	    /**
	     * 音效组件类的基类。
	     */
	    export import AudioEffectComponent = AudioEffectComponentClass;
	    /**
	     * 音频监听器组件类。
	     */
	    export import AudioListener = AudioListenerClass;
	    /**
	     * 音频监听器节点类。
	     */
	    export import AudioListenerNode = AudioListenerNodeClass;
	    /**
	     * 音频源组件类。
	     */
	    export import AudioSource = AudioSourceClass;
	    /**
	     * 音频源节点类。可用于播放audioclip资源。
	     */
	    export import AudioSourceNode = AudioSourceNodeClass;
	    /**
	     * 3D空间音效节点类。用于AudioSource组件处理3D空间音效。
	     */
	    export import AudioPannerNode = AudioPannerNodeClass;
	    /**
	     * 双二阶滤波器组件类。
	     */
	    export import AudioBiquadFilter = AudioBiquadFilterClass;
	    /**
	     * 低通滤波器音效组件类。可将音效作用于 AudioSource 和 AudioListener 组件。
	     */
	    export import AudioLowPassFilter = AudioLowPassFilterClass;
	    /**
	     * 高通滤波器音效组件类。可将音效作用于 AudioSource 和 AudioListener 组件。
	     */
	    export import AudioHighPassFilter = AudioHighPassFilterClass;
	    /**
	     * 失真音效组件类。可将音效作用于 AudioSource 和 AudioListener 组件。
	     */
	    export import AudioDistortion = AudioDistortionClass;
	    /**
	     * 回声音效组件类。可将音效作用于 AudioSource 和 AudioListener 组件。
	     */
	    export import AudioEcho = AudioEchoClass;
	    /**
	     * 双二阶滤波器音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioBiquadFilterNode = AudioBiquadFilterNodeClass;
	    /**
	     * 低通滤波器音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioLowPassFilterNode = AudioLowPassFilterNodeClass;
	    /**
	     * 高通滤波器音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioHighPassFilterNode = AudioHighPassFilterNodeClass;
	    /**
	     * 失真音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioDistortionNode = AudioDistortionNodeClass;
	    /**
	     * 回声音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioEchoNode = AudioEchoNodeClass;
	    /**
	     * 发送音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioSendNode = AudioSendNodeClass;
	    /**
	     * 接收音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioReceiveNode = AudioReceiveNodeClass;
	    /**
	     * 闪避音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioDuckNode = AudioDuckNodeClass;
	    /**
	     * 衰减音效节点类。可将音效作用于AudioMixer Group。
	     */
	    export import AudioAttenuationNode = AudioAttenuationNodeClass;
	    /**
	     * 定义切换快照时可使用的Transition类型
	     */
	    enum SnapshotTransitionType {
	        /**
	         * 线性过渡算法
	         */
	        Linear = 0,
	        /**
	         * 平滑过渡算法
	         */
	        Smoothstep = 1,
	        /**
	         * 使用余弦函数实现的等功率过渡算法
	         */
	        CosinEqualPower = 2,
	        /**
	         * 使用平方根函数实现的等功率过渡算法
	         */
	        SquareRootEqualPower = 3,
	        /**
	         * 在Transition开始时，立刻将参数值设置成目标快照所保存的参数值
	         */
	        BrickwallStart = 4,
	        /**
	         * 在Transition结束时，将参数值设置成目标快照所保存的参数值
	         */
	        BrickwallEnd = 5,
	        /**
	         * 指数逼近过渡算法
	         */
	        ExponentiallyApproaching = 6,
	        /**
	         * 指数过渡算法
	         */
	        Exponential = 7
	    }
	    /**
	     * 定义快照对象AudioMixerSnapshot保存的被捕获参数数据结构
	     */
	    interface ISnapshotParameterInfo extends ISnapshotParamConfig {
	        /**
	         * 参数值
	         */
	        value: any;
	        /**
	         * Transition类型
	         */
	        transitionType: SnapshotTransitionType;
	        /**
	         * 参数所属音效节点对象
	         */
	        effect: AudioBaseNode;
	        /**
	         * 参数名称
	         */
	        propertyName: string;
	    }
	    /**
	     * 判断指定node参数是否经过封装后的WebAudio的AudioNode类型
	     */
	    const IsAudioNode: (node: any) => boolean;
	    /**
	     * 判断指定param参数是否经过封装后的webAudio的AudioParam类型
	     */
	    const IsAudioParam: (param: any) => boolean;
	    /**
	     * 获取新的节点id
	     */
	    const GenId: () => string;
	    /**
	     * 获取经过封装的WebAudio上下文
	     */
	    const GetCtx: () => AudioContext;
	    /**
	     * 获取真实音频数量上限
	     */
	    const GetNumRealVoices: () => number;
	    /**
	     * 设置真实音频数量上限
	     */
	    const SetNumRealVoices: (val: number) => void;
	    /**
	     * 获取音频系统当前时间
	     */
	    const GetDspTime: () => number;
	    /**
	     * 获取经过封装的WebAudio上下文的AudioListener对象
	     */
	    const GetNativeListener: () => globalThis.AudioListener;
	    /**
	     * 获取经过封装的WebAudio上下文的AudioDestinationNode对象
	     */
	    const GetDestination: () => AudioDestinationNode;
	    /**
	     * 创建新的经过封装的WebAudio PannerNode对象
	     */
	    const CreatePanner: () => PannerNode;
	    /**
	     * 创建新的经过封装的WebAudio GainNode对象
	     */
	    const CreateGain: () => GainNode;
	    /**
	     * 创建新的经过封装的WebAudio StereoPannerNode对象
	     */
	    const CreateStereoPanner: () => StereoPannerNode;
	    /**
	     * 创建新的经过封装的WebAudio BiquadFilterNode对象
	     */
	    const CreateBiquadFilter: () => BiquadFilterNode;
	    /**
	     * 创建新的经过封装的WebAudio DelayNode对象
	     */
	    const CreateDelay: () => DelayNode;
	    /**
	     * 创建新的经过封装的WebAudio ConvolverNode对象
	     */
	    const CreateConvolver: () => ConvolverNode;
	    /**
	     * 创建新的经过封装的WebAudio DynamicsCompressorNode对象
	     */
	    const CreateDynamicsCompressor: () => DynamicsCompressorNode;
	    /**
	     * 创建新的经过封装的WebAudio AudioBufferSourceNode对象
	     */
	    const CreateBufferSource: () => AudioBufferSourceNode;
	    /**
	     * 创建新的经过封装的WebAudio WaveShaperNode对象
	     */
	    const CreateWaveShaper: () => WaveShaperNode;
	    /**
	     * 创建新的经过封装的WebAudio IIRFilterNode对象
	     */
	    const CreateIIRFilter: (feedforward: number[], feedback: number[]) => IIRFilterNode;
	}
	export default Audio;
	export type SnapshotTransitionType = Audio.SnapshotTransitionType;
	export type ISnapshotParameterInfo = Audio.ISnapshotParameterInfo;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/interface' {
	import { DeepImmutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import type { SnapshotTransitionType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/Audio';
	export const MASTER_GROUP_NAME = "Master";
	export interface IExposedInfo {
	    id: string;
	    name: string;
	    value?: any;
	}
	export interface IDescriptionEffect {
	    id: string;
	    snapshotParameters: {
	        [propertyName in string]: string;
	    };
	    bypass: boolean;
	    sendTarget: {
	        id: string;
	        sideChainIndex: number;
	    } | null;
	}
	export interface IDescriptionSnapshot {
	    id: string;
	    name: string;
	    values: {
	        [key in string]: number | string | boolean;
	    };
	    transitionOverride: {
	        [key in string]: SnapshotTransitionType;
	    };
	}
	export interface IDescriptionGroup {
	    id: string;
	    name: string;
	    children: Array<number>;
	    effects: Array<number>;
	    mute: boolean;
	    solo: boolean;
	    bypassEffects: boolean;
	    snapshotParameters: {
	        [propertyName in string]: string;
	    };
	}
	interface IDescriptionMixer {
	    output: null | {
	        mixer: string;
	        group: string;
	    };
	    masterGroup: number;
	    startSnapshot: number;
	    exposedParameters: Array<{
	        id: string;
	        name: string;
	    }>;
	    snapshotList: Array<IDescriptionSnapshot>;
	    groupList: Array<IDescriptionGroup>;
	    effectList: Array<IDescriptionEffect>;
	}
	export type MixerDescription = DeepImmutable<IDescriptionMixer>;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerSnapshot' {
	import { IDescriptionSnapshot } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/interface';
	import type AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode';
	import type { ISnapshotParameterInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/Audio';
	import { DeepImmutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	/**
	 * 混音器快照接口
	 * @category Audio
	 */
	export interface IAudioMixerSnapshot {
	    /**
	     * 快照id
	     * @memberof AudioMixerSnapshot
	     */
	    readonly id: string;
	    /**
	     * 快照名称
	     * @memberof AudioMixerSnapshot
	     */
	    name: string;
	    /**
	     * 保存了被捕获参数相关信息
	     * @memberof AudioMixerSnapshot
	     */
	    values: Map<string, ISnapshotParameterInfo>;
	    /**
	     * 获取指定参数被快照捕获的信息
	     * @param id 参数id
	     * @memberof AudioMixerSnapshot
	     */
	    getParameterInfo(id: string): ISnapshotParameterInfo | null;
	} class AudioMixerSnapshot implements IAudioMixerSnapshot {
	    get id(): string;
	    get name(): string;
	    set name(val: string);
	    get values(): Map<string, import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/Audio').default.ISnapshotParameterInfo>;
	    /**
	     * 根据parameterid获取对应的值
	     * @param {string} id effect的parameter的id
	     */
	    getParameterInfo(id: string): ISnapshotParameterInfo | null;
	    deserializeSnapshot(description: DeepImmutable<IDescriptionSnapshot>, parameterMap: Map<string, {
	        effect: AudioBaseNode;
	        propertyName: string;
	        nodeKey: string;
	        parameterKey?: string;
	    }>): void;
	    destroy(): void;
	} namespace AudioMixerSnapshot { }
	export default AudioMixerSnapshot;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerGroup' {
	import AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode';
	import type AudioMixer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixer';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	/**
	 * 混音器音频组AudioMixerGroup接口
	 * @category Audio
	 */
	export interface IAudioMixerGroup extends AudioBaseNode {
	    /**
	     * 音频组名称
	     * @memberof AudioMixerGroup
	     */
	    name: string;
	    /**
	     * 音频组Group所属的混音器AudioMixer对象
	     * @memberof AudioMixerGroup
	     */
	    readonly mixer: Nullable<AudioMixer>;
	    /**
	     * 音频组Group的子Group列表
	     * @memberof AudioMixerGroup
	     */
	    readonly children: Nullable<Array<AudioMixerGroup>>;
	    /**
	     * 音频组使用的音效节点对象列表
	     * @memberof AudioMixerGroup
	     */
	    readonly effects: Nullable<Array<AudioBaseNode>>;
	} class AudioMixerGroup extends AudioBaseNode implements IAudioMixerGroup {
	    get mixer(): Nullable<AudioMixer>;
	    get children(): AudioMixerGroup[];
	    get effects(): AudioBaseNode[];
	    get name(): string;
	    set name(val: string);
	    constructor(audioMixer: AudioMixer);
	} namespace AudioMixerGroup { }
	export default AudioMixerGroup;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/Instantiate' {
	import type AudioMixerAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/audioMixerAsset';
	import AudioMixer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixer';
	export default function Instantiate(asset: AudioMixerAsset): AudioMixer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/audioMixerAsset' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import { MixerDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/interface';
	import type AudioMixer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixer';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	/**
	 * 混音器资源
	 * @export
	 * @class AudioMixerAsset
	 * @category Asset
	 * @category Audio
	 */
	export default class AudioMixerAsset extends BaseResource {
	    readonly description: MixerDescription;
	    readonly outputMixer: Nullable<AudioMixerAsset>;
	    /**
	     * 通过资源描述文件创建AudioMixerAsset资源。
	     * @param description 混音器资源描述。
	     * @param outputMixer 混音器输出信号的接收者
	     * @memberof AudioMixerAsset
	     */
	    constructor(description: MixerDescription, outputMixer?: AudioMixerAsset);
	    /**
	     * 实例化AudioMixer。
	     * @returns {AudioMixer}
	     * @memberof AudioMixerAsset
	     * @returns {AudioMixer} AudioMixer实例。
	     */
	    instantiate(): AudioMixer;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixer' {
	import { IExposedInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/interface';
	import type AudioMixerSnapshot from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerSnapshot';
	import AudioMixerGroup from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerGroup';
	import type AudioMixerAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/audioMixerAsset';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	/**
	 * 混音器AudioMixer接口
	 * @category Audio
	 */
	export interface IAudioMixer {
	    /**
	     * AudioMixer id
	     * @memberof AudioMixer
	     */
	    readonly id: string;
	    /**
	     * 生成AudioMixer对象的AudioMixerAsset资源id
	     * @memberof AudioMixer
	     */
	    readonly resourceID: string;
	    /**
	     * AudioMixer Master Group
	     * @memberof AudioMixer
	     */
	    readonly masterGroup: Nullable<AudioMixerGroup>;
	    /**
	     * AudioMixer 信号输出到哪里
	     * 为空：信号输出到AudioListener
	     * 非空：信号输出到指定AudioMixer的指定Group里
	     * @memberof AudioMixer
	     */
	    readonly outputAudioMixerGroup: Nullable<AudioMixerGroup>;
	    /**
	     * AudioMixer是否已被销毁
	     * @memberof AudioMixer
	     */
	    readonly isDestroyed: boolean;
	    /**
	     * AudioMixer存储的快照列表
	     * @memberof AudioMixer
	     */
	    readonly snapshots: Array<AudioMixerSnapshot>;
	    /**
	     * AudioMixer初始化时使用的快照。
	     * @memberof AudioMixer
	     */
	    readonly startSnapshot: Nullable<AudioMixerSnapshot>;
	    /**
	     * 切换快照时，AudioMixer的目标快照
	     * @memberof AudioMixer
	     */
	    readonly targetSnapshot: Nullable<AudioMixerSnapshot>;
	    /**
	     * 暴露的参数列表
	     * @memberof AudioMixer
	     */
	    readonly exposed: {
	        [exposedName in string]: IExposedInfo;
	    };
	    /**
	     * 获取音频组Group
	     * @param {string} idOrPath group id或者group的path。比如 /Master/childGroupName/ (获取childGroupName的所有children) 或者 /Master/childGroupName/grandChildGroupName (获取 grandChildGroupName )
	     * @memberof AudioMixer
	     */
	    findMatchingGroup(idOrPath: string): Array<AudioMixerGroup>;
	    /**
	     * 获取快照对象
	     * @param idOrName 快照id或者快照名称
	     * @memberof AudioMixer
	     */
	    findSnapshot(idOrName: string): Nullable<AudioMixerSnapshot>;
	    /**
	     * 获取暴露参数值
	     * @param name 暴露参数名称
	     * @memberof AudioMixer
	     */
	    getExposed(name: string): any;
	    /**
	     * 设置暴露参数值
	     * @param name 暴露参数名称
	     * @memberof AudioMixer
	     */
	    setExposed(name: string, val: any): void;
	    /**
	     * 清除暴露参数。则在切换快照时，该参数会收到transition类型影响。
	     * @param name
	     * @memberof AudioMixer
	     */
	    clearExposed(name: string): boolean;
	    /**
	     * 切换到指定快照。
	     * @param name 快照名称
	     * @param duration 切换快照持续时间，单位秒
	     * @memberof AudioMixer
	     */
	    transitionTo(name: string, duration: number): void;
	    /**
	     * 切换到指定快照。
	     * @param name 快照对象
	     * @param duration 切换快照持续时间，单位秒
	     * @memberof AudioMixer
	     */
	    transitionTo(snapshot: AudioMixerSnapshot, duration: number): void;
	    /**
	     * 释放对此AudioMixer对象的引用。当AudioMixer被引用数为0时，AudioMixer才会自行销毁。
	     * @memberof AudioMixer
	     */
	    releaseAudioMixer(): void;
	}
	export default class AudioMixer implements IAudioMixer {
	    get id(): string;
	    get resourceID(): string;
	    get masterGroup(): Nullable<AudioMixerGroup>;
	    get outputAudioMixerGroup(): Nullable<AudioMixerGroup>;
	    get isDestroyed(): boolean;
	    get snapshots(): AudioMixerSnapshot[];
	    get startSnapshot(): Nullable<AudioMixerSnapshot>;
	    get targetSnapshot(): Nullable<AudioMixerSnapshot>;
	    get exposed(): {
	        [x: string]: IExposedInfo;
	    };
	    constructor(resourceID: string);
	    /**
	     * 根据group id或者group的path获取groups
	     * @param {string} idOrPath group id或者group的path。比如 /Master/childGroupName/ (获取childGroupName的所有children) 或者 /Master/childGroupName/grandChildGroupName (获取 grandChildGroupName )
	     * @returns {Array<AudioMixerGroup>}
	     */
	    findMatchingGroup(idOrPath: string): Array<AudioMixerGroup>;
	    findSnapshot(idOrName: string): Nullable<AudioMixerSnapshot>;
	    getExposed(name: string): any;
	    /**
	     * 设置exposed参数的值并立刻中断该参数的snapshot transition。调用setExposed后，该参数将不受snapshot控制。
	     * @param {string} name Exposed后的name
	     * @param {any} val 需要设置的值
	     * @returns {boolean} true: 设置成功； false:设置不成功
	     */
	    setExposed(name: string, val: any): boolean;
	    /**
	     * 重置exposed参数值，并使该参数可以受到snapshot控制
	     * @param {string} name Exposed后的name
	     * @returns {boolean} true: 设置成功； false:设置不成功
	     */
	    clearExposed(name: string): boolean;
	    /**
	     * 转移到指定snapshot
	     * 注意：如果transitionType不是BrickwallStart和BrickwallEnd，需要调用AudioParam相关transition方法（如：setTargetAtTime等方法）。
	     * 由于webAudio的原理，当该节点链路上没有声源节点，也没有output类型节点（如：destination扬声器节点），数据不会流通该节点，AudioParam相关transition方法产生的automation events并不会执行，导致AudioParam相关参数不会有任何变化。当transition结束时，transitionTo函数会调用effect[propertyName]另外再设置该参数值。
	     * 如果该propertyName的set方法里通过 AudioParam.value 直接设置参数值，则能在transition结束时改变该参数值。
	     * @param {string | AudioMixerSnapshot} nameOrSnapshot 目标snapshot或者目标snashot的name
	     * @param {number} duration 转移完成需要的时间。单位秒
	     */
	    transitionTo(nameOrSnapshot: string | AudioMixerSnapshot, duration: number): void;
	    deserializeMixer(audioMixerAsset: AudioMixerAsset, snapshotList: Array<AudioMixerSnapshot>, groupList: Array<AudioMixerGroup>): void;
	    releaseAudioMixer(): void;
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerPool' {
	import type AudioMixer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixer';
	export default class AudioMixerPool {
	    static RegisterMixer(mixer: AudioMixer): void;
	    static GetMixer(resourceID: string): AudioMixer | null;
	    static SubMixerCitedCount(resourceID: string): void;
	    static ReleaseMixer(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioGraph' {
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSourceNode' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AudioBaseNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioBaseNode';
	import AudioClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audioClip'; class AudioSourceNode extends AudioBaseNode {
	    /**
	     * 要播放的音频剪辑audioclip资源。
	     * @memberof AudioSourceNode
	     */
	    get clip(): Nullable<AudioClip>;
	    set clip(val: Nullable<AudioClip>);
	    /**
	     * 是否静音。
	     * @memberof AudioSourceNode
	     */
	    get mute(): boolean;
	    set mute(val: boolean);
	    /**
	     * 是否循环播放。
	     * @memberof AudioSourceNode
	     */
	    get loop(): boolean;
	    set loop(val: boolean);
	    /**
	     * 声音的原始音量。
	     * 值1：表示音量不变；值0：表示静音。
	     * @memberof AudioSourceNode
	     */
	    get volume(): number;
	    set volume(val: number);
	    /**
	     * 声音播放速率。
	     * 值1：表示正常播放速度。慢速或快速播放会引起音高的变化。
	     * @memberof AudioSourceNode
	     */
	    get pitch(): number;
	    set pitch(val: number);
	    set isVirtual(val: boolean);
	    /**
	     * 音频时长。
	     * @memberof AudioSourceNode
	     */
	    get duration(): number;
	    /**
	     * 是否暂停中
	     * @memberof AudioSourceNode
	     */
	    get paused(): boolean;
	    /**
	     * 资源是否就绪，可以播放。
	     * @memberof AudioSourceNode
	     */
	    get canplay(): boolean;
	    /**
	     * 是否播放中。
	     * @memberof AudioSourceNode
	     */
	    get playing(): boolean;
	    /**
	     * 当前音频的播放时间。
	     * @memberof AudioSourceNode
	     */
	    get currentTime(): number;
	    /**
	     * 构造函数
	     * @param creator 节点创造者。可为空
	     * @param clip audioclip资源
	     * @memberof AudioSourceNode
	     */
	    constructor(creator?: any, clip?: AudioClip);
	    /**
	     * 监听指定事件，在事件触发时执行指定回调。
	     * @param type 事件类型
	     * @param callback 回调函数
	     * @memberof AudioSourceNode
	     */
	    addEventListener(type: AudioSourceNode.IEvent, 
	    /**
	     * 回调函数
	     * @param {object} e 回调函数第一个参数
	     * @param {AudioSourceNode} e.target 事件触发者
	     * @param {AudioSourceNode.IEvent} e.type 事件类型
	     */
	    callback: (e: {
	        target: AudioSourceNode;
	        type: AudioSourceNode.IEvent;
	    }) => void): void;
	    /**
	     * 移除指定事件的所有监听。
	     * @param type 事件类型
	     * @memberof AudioSourceNode
	     */
	    removeEventListener(type: AudioSourceNode.IEvent): any;
	    /**
	     * 移除指定事件的指定监听。
	     * @param type 事件类型。
	     * @param callback 调用addEventListener时传入的回调函数。
	     * @memberof AudioSourceNode
	     */
	    removeEventListener(type: AudioSourceNode.IEvent, callback: (e: {
	        target: AudioSourceNode;
	        type: AudioSourceNode.IEvent;
	    }) => void): any;
	    /**
	     * 从音频的指定时间开始播放或者从暂停状态恢复播放
	     * @param {number} time 音频开始播放的时间，单位秒。缺省值为0。小于等于0：表示；从暂停状态恢复播放或者重新播放
	     * @memberof AudioSourceNode
	     */
	    play(time?: number): void;
	    /**
	     * 计划播放。
	     * 在音频系统时间坐标系上指定时间点，从音频的指定时间开始播放。
	     * 播放状态下不能调用playScheduled。
	     * @param {number} startCtxTime 音频系统时间坐标系上的时间点，单位秒。0或者小于音频系统当前时间，表示立刻播放。
	     * @param {number} startTime 以音频文件时间为参考的时间，单位秒。
	     * @memberof AudioSourceNode
	     */
	    playScheduled(startCtxTime: number, startTime: number): void;
	    /**
	     * 暂停播放
	     * @memberof AudioSourceNode
	     */
	    pause(): void;
	    /**
	     * 从音频的指定时间点播放。
	     * 只有暂停状态或者调用过play和playScheduled方法后才能调用seek，否则出错。
	     * @param {number} time 以音频文件时间为参考的时间，单位秒。
	     * @memberof AudioSourceNode
	     */
	    seek(time: number): void;
	    /**
	     * 停止播放
	     * @memberof AudioSourceNode
	     */
	    stop(): void;
	    /**
	     * 计划停止播放。
	     * 在音频系统时间坐标系上指定时间点，停止播放
	     * @param {number} startCtxTime 音频系统时间坐标系上的时间点，单位秒。0或者小于音频系统当前时间，表示立刻停止。
	     * @memberof AudioSourceNode
	     */
	    stopScheduled(startCtxTime: number): void;
	    /**
	     * 销毁节点。
	     * @memberof AudioSourceNode
	     */
	    destroy(): void;
	} namespace AudioSourceNode {
	    /**
	     * 音频源节点对象被创建时的参数默认值。
	     */
	    const DEFUALT_VALUE: Readonly<{
	        /**
	         * 是否静音
	         */
	        mute: boolean;
	        /**
	         * 初始音量
	         */
	        volume: number;
	        /**
	         * 是否循环播放
	         */
	        loop: boolean;
	        /**
	         * 播放速率。
	         */
	        pitch: number;
	    }>;
	    /**
	     * 可监听的播放相关回调事件名称。
	     */
	    enum IEvent {
	        ended = "ended"
	    }
	}
	export default AudioSourceNode;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectComponent' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AudioListenerNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioListenerNode';
	import AudioSourceNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSourceNode';
	import AudioEffectNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectNode';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component'; class AudioEffectComponent extends Component {
	    /**
	     * 音效节点对象
	     * @memberof AudioEffectComponent
	     */
	    get effectNode(): Nullable<AudioListenerNode | AudioEffectNode | AudioSourceNode>;
	} namespace AudioEffectComponent { }
	export default AudioEffectComponent;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSource' {
	import AudioEffectComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioEffectComponent';
	import AudioClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audioClip';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AudioSourceNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSourceNode';
	import AudioPannerNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioPannerNode';
	import type AudioMixerGroup from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerGroup'; class AudioSource extends AudioEffectComponent {
	    /**
	     * 要播放的音频剪辑audioclip资源。
	     * @memberof AudioSource
	     */
	    get clip(): Nullable<AudioClip>;
	    set clip(val: Nullable<AudioClip>);
	    /**
	     * 是否绕过AudioSource所在节点的所有音效。
	     * @memberof AudioSource
	     */
	    get bypassEffects(): boolean;
	    set bypassEffects(val: boolean);
	    /**
	     * 是否绕过AudioListener所在节点的所有音效。
	     * 无论AudioSource播放的声音是直接被AudioListener接收，还是先经过AudioMixer处理，再被AudioListener接收，此属性均有效。
	     * 当节点上有且只有一个AudioSource时，此属性才有效。即当节点上存在多个AudioSource时，这些AudioSource播放的声音一定会被AudioListener所在节点的所有音效处理。
	     * @memberof AudioSource
	     */
	    get bypassListenerEffects(): boolean;
	    set bypassListenerEffects(val: boolean);
	    /**
	     * 如果启用此选项，声音将在场景启动时自动播放。
	     * 如果禁用此选项，需要通过脚本调用 AudioSource.play 函数播放声音。
	     * @memberof AudioSource
	     */
	    get playOnAwake(): boolean;
	    set playOnAwake(val: boolean);
	    /**
	     * AudioSource播放的声音的优先级。
	     * 值为0：表示优先级最高。值为255：表示优先级最低。
	     * 值为0，AudioSource播放的声音不会被设置为虚拟音频，即AudioSource播放的声音一定会被听到。
	     * @memberof AudioSource
	     */
	    get audioPriority(): number;
	    set audioPriority(val: number);
	    /**
	     * 混音器音频组AudioMixer Group。
	     * 指定AudioSource播放的声音输出到指定混音器的指定音频组。
	     * 为空，则声音直接输出到AudioListener。当然，在输出到AudioListener前可能会先经过AudioListener所在节点的音效处理。
	     * @memberof AudioSource
	     */
	    get outputMixerGroup(): Nullable<AudioMixerGroup>;
	    set outputMixerGroup(val: Nullable<AudioMixerGroup>);
	    /**
	     * 是否静音。
	     * @memberof AudioSource
	     */
	    get mute(): boolean;
	    set mute(val: boolean);
	    /**
	     * 是否循环播放。
	     * @memberof AudioSource
	     */
	    get loop(): boolean;
	    set loop(val: boolean);
	    /**
	     * 声音播放速率。
	     * 值1：表示正常播放速度。慢速或快速播放会引起音高的变化。
	     * @memberof AudioSource
	     */
	    get pitch(): number;
	    set pitch(val: number);
	    /**
	     * 声音的原始音量。
	     * 值1：表示音量不变；值0：表示静音。
	     * @memberof AudioSource
	     */
	    get volume(): number;
	    set volume(val: number);
	    /**
	     * 2D声音的左右声道。
	     * 值-1：只有左声道；值0：双声道；值1：只有右声道
	     * @memberof AudioSource
	     */
	    get stereoPan(): number;
	    set stereoPan(val: number);
	    /**
	     * 3D空间对音频源的影响程度。
	     * 值0：只有2D声音，忽略所有3D空间音效的影响；值1：完全3D音效。
	     * @memberof AudioSource
	     */
	    get spatialBlend(): number;
	    set spatialBlend(val: number);
	    /**
	     * 在3D空间里，声音在播放方向上的圆锥体角度，以度为单位。
	     * 音频系统使用圆锥体来描述声音的传播方向。在此属性定义的圆锥体内，音量不会降低，即声音不受coneOuterGain属性影响（但是声音还是会受到距离和其他音效的影响）。
	     * 值360：表示声音向任意方向传播，即在任意方向上均可听到该声音。
	     * @memberof AudioSource
	     */
	    get coneInnerAngle(): number;
	    set coneInnerAngle(val: number);
	    /**
	     * 在3D空间里，声音在播放方向上的圆锥体角度，以度为单位。
	     * 在此属性定义的圆锥体外，音量将减少到恒定的coneOuterGain属性定义的值。
	     * 值360：表示声音在任意方向上音量都不会受到coneOuterGain属性影响而减少（但是声音还是会受到距离和其他音效的影响）。
	     * @memberof AudioSource
	     */
	    get coneOuterAngle(): number;
	    set coneOuterAngle(val: number);
	    /**
	     * 在3D空间里，声音在coneOuterAngle属性定义的圆锥体外的音量衰减值。
	     * 值1：表示不衰减；值0：表示静音。
	     * @memberof AudioSource
	     */
	    get coneOuterGain(): number;
	    set coneOuterGain(val: number);
	    /**
	     * 3D空间音效里，音量随距离变化而变化的算法模型
	     * @memberof AudioSource
	     */
	    get distanceModel(): AudioPannerNode.PannerDistanceModel;
	    set distanceModel(val: AudioPannerNode.PannerDistanceModel);
	    /**
	     * 计算3D空间音效所使用的算法。
	     * @memberof AudioSource
	     */
	    get panningModel(): AudioPannerNode.PanningModel;
	    set panningModel(val: AudioPannerNode.PanningModel);
	    /**
	     * 在3D空间里，当AudioSource和AudioListener之间的距离小于该值，音量不因距离而衰减。若距离大于该值，声音开始衰减。
	     * @memberof AudioSource
	     */
	    get minDistance(): number;
	    set minDistance(val: number);
	    /**
	     * 在3D空间里，当AudioSource和AudioListener之间的距离大于该值，音量保持不变，不再衰减。
	     * @memberof AudioSource
	     */
	    get maxDistance(): number;
	    set maxDistance(val: number);
	    /**
	     * 此属性是distanceModel定义的算法中的一个因子。
	     * @memberof AudioSource
	     */
	    get rolloffFactor(): number;
	    set rolloffFactor(val: number);
	    /**
	     * 声音是否处于虚拟状态。
	     * @memberof AudioSource
	     */
	    get isVirtual(): boolean;
	    set isVirtual(val: boolean);
	    /**
	     * 音频时长。
	     * @memberof AudioSource
	     */
	    get duration(): number;
	    /**
	     * 是否暂停中
	     * @memberof AudioSource
	     */
	    get paused(): boolean;
	    /**
	     * 资源是否就绪，可以播放。
	     * @memberof AudioSource
	     */
	    get canplay(): boolean;
	    /**
	     * 是否播放中。
	     * @memberof AudioSource
	     */
	    get playing(): boolean;
	    /**
	     * 当前音频的播放时间。
	     * @memberof AudioSource
	     */
	    get currentTime(): number;
	    /**
	     * 3D空间音效节点对象。
	     * @memberof AudioSource
	     */
	    get pannerNode(): AudioPannerNode | null;
	    /**
	     * 音频源节点对象。
	     * @memberof AudioSource
	     */
	    get audioSourceNode(): AudioSourceNode | null;
	    /**
	     * 从音频的指定时间开始播放或者从暂停状态恢复播放
	     * @param {number} time 音频开始播放的时间，单位秒。缺省值为0。小于等于0：表示；从暂停状态恢复播放或者重新播放
	     * @memberof AudioSource
	     */
	    play(time?: number): void;
	    /**
	     * 计划播放。
	     * 在音频系统时间坐标系上指定时间点，从音频的指定时间开始播放。
	     * 播放状态下不能调用playScheduled。
	     * @param {number} startCtxTime 音频系统时间坐标系上的时间点，单位秒。0或者小于音频系统当前时间，表示立刻播放。
	     * @param {number} startTime 以音频文件时间为参考的时间，单位秒。
	     * @memberof AudioSource
	     */
	    playScheduled(startCtxTime: number, startTime: number): void;
	    /**
	     * 暂停播放
	     * @memberof AudioSource
	     */
	    pause(): void;
	    /**
	     * 从音频的指定时间点播放。
	     * 只有暂停状态或者调用过play和playScheduled方法后才能调用seek，否则出错。
	     * @param {number} time 以音频文件时间为参考的时间，单位秒。
	     * @memberof AudioSource
	     */
	    seek(time: number): void;
	    /**
	     * 停止播放
	     * @memberof AudioSource
	     */
	    stop(): void;
	    /**
	     * 计划停止播放。
	     * 在音频系统时间坐标系上指定时间点，停止播放
	     * @param {number} startCtxTime 音频系统时间坐标系上的时间点，单位秒。0或者小于音频系统当前时间，表示立刻停止。
	     * @memberof AudioSource
	     */
	    stopScheduled(startCtxTime: number): void;
	    /**
	     * 使用AudioSource的配置，播放指定audioClip资源。
	     * 成功则返回新创建的AudioSourceNode对象。此对象会在AudioSource销毁时自动销毁。开发者也可以自行调用AudioSourceNode.destroy来销毁。
	     * @param {AudioClip} clip 需要播放的clip资源
	     * @param {number} volumeScale AudioSource音量的系数，即AudioSource.volume * volumeScale作为新的初始音量
	     * @param {number} startCtxTime 在音频系统时间坐标系上指定时间点开始播放，单位秒。 0或者小于音频系统当前时间，表示立刻播放。
	     * @param {number} startTime 从音频的指定时间开始播放。单位秒。
	     * @memberof AudioSource
	     */
	    playClip(clip: AudioClip, volumeScale?: number, startCtxTime?: number, startTime?: number): AudioSourceNode | null;
	} namespace AudioSource { }
	export default AudioSource;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioMixerPlayable' {
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import type { FrameData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/interface';
	import PlayableBehaviour from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBehaviour';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	export class AudioMixerPlayable extends Playable {
	    get volume(): number;
	    set volume(val: number);
	}
	export default class AudioMixerPlayableBehaviour extends PlayableBehaviour {
	    static PlayableClass: typeof AudioMixerPlayable;
	    static Create(graph: PlayableGraph): AudioMixerPlayable;
	    ProcessFrame(playable: AudioMixerPlayable, info: FrameData, playerData: any): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioClipPlayable' {
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AudioPlayer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioPlayer';
	import AudioClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audioClip';
	import type { FrameData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/interface';
	import AudioSource from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSource';
	import AudioSourceNode from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSourceNode';
	import type { AudioMixerPlayable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioMixerPlayable';
	export default class AudioClipPlayable extends Playable {
	    get audioPlayer(): Nullable<AudioPlayer | AudioSourceNode>;
	    get started(): boolean;
	    set started(val: boolean);
	    get volume(): number;
	    set volume(val: number);
	    get loop(): boolean;
	    set loop(val: boolean);
	    get audioClip(): AudioClip;
	    set audioClip(val: AudioClip);
	    constructor(graph: PlayableGraph);
	    static Create(graph: PlayableGraph, clip: AudioClip, volume: number, loop: boolean): AudioClipPlayable;
	    playAudio(audioMixerPlayable: AudioMixerPlayable, frameData: FrameData, audioSource: AudioSource): void;
	    stopAudio(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioPlayableAsset' {
	import { ClipCaps, TimelineClipAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import AudioClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audioClip';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import AudioClipPlayable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioClipPlayable'; class AudioPlayableAsset extends TimelineClipAsset {
	    get clipCaps(): ClipCaps;
	    /**
	     * 该Clip所使用的audio资源。
	     *
	     * @memberof AudioPlayableAsset
	     */
	    get clip(): Nullable<AudioClip>;
	    set clip(val: Nullable<AudioClip>);
	    /**
	     * 该Clip是否启用循环。
	     * @memberof AudioPlayableAsset
	     */
	    get loop(): boolean;
	    set loop(val: boolean);
	    /**
	     * 该Clip的音量。
	     * @memberof AudioPlayableAsset
	     */
	    get volume(): number;
	    set volume(val: number);
	    constructor();
	    createPlayable(graph: PlayableGraph): AudioClipPlayable;
	} namespace AudioPlayableAsset { }
	export default AudioPlayableAsset;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/util' {
	import { EPlayableType, EPlaybaleTrackType, ITimelineActivationTrackInfo, ITimelineAnimationTrackInfo, ITimelineAudioTrackInfo, ITimelineControlTrackInfo, ITimelineCustomTrackInfo, ITimelinePlayableAssetTrackBaseInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import { SerializableCtor } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type'; type TimelineAsset = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineAsset').default; type TrackAsset = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset').default;
	export function GetTrackAssetClassTypeNameByType(type: EPlaybaleTrackType | string): string;
	export function GetTrackAssetClassCtorByType(type: EPlaybaleTrackType | string): SerializableCtor;
	export function GetClipPlayableAssetClassTypeNameByType(type: EPlayableType | string): string;
	export function GetClipPlayableAssetClassCtorByType(type: EPlayableType | string): SerializableCtor;
	/**
	 * 生成并反序列化trackAsset
	 * @param trackData
	 * @param parent
	 * @param parentIsTimelineAsset
	 * @param autoAddTrack 若为true，则自动把track 加到parent中
	 */
	export function CreateDeserializeTrackAsset(trackData: ITimelinePlayableAssetTrackBaseInfo | ITimelineActivationTrackInfo | ITimelineAudioTrackInfo | ITimelineAnimationTrackInfo | ITimelineControlTrackInfo | ITimelineCustomTrackInfo, parent: Nullable<TrackAsset | TimelineAsset>, parentIsTimelineAsset: boolean, autoAddTrack?: boolean): TrackAsset;
	export function ReconstructTrackBasedOnExistedTracks(trackData: ITimelinePlayableAssetTrackBaseInfo | ITimelineActivationTrackInfo | ITimelineAudioTrackInfo | ITimelineAnimationTrackInfo | ITimelineControlTrackInfo | ITimelineCustomTrackInfo, parent: Nullable<TrackAsset | TimelineAsset>, parentIsTimelineAsset: boolean): boolean;
	export function GenTrackLocalId(digit?: number): string;
	/**
	 * TODO 生成trackName或者clipName
	 *
	 * @export
	 * @param {string} baseName
	 * @returns
	 */
	export function GenerateUniqueActorName(baseName: string): string;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip' {
	import HermiteCurve from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hermiteCurve';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import AudioClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audioClip';
	import { ETimelineClipBlendCurveMode, ClipCaps as ClipCapsClass, EPlayableType, TimelineClipExtrapolation, TimelineClipAsset as TimelineClipAssetClass } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import type TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import ActivationPlayableAssetClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/activation/activationPlayableAsset';
	import AnimationPlayableAssetClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationPlayableAsset';
	import AudioPlayableAssetClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioPlayableAsset'; class TimelineClip {
	    readonly parent: TrackAsset;
	    /**
	     * TimlineClip的类型。
	     *
	     * @type {TimelineClip.PlayableType}
	     * @memberof TimelineClip
	     */
	    type: TimelineClip.PlayableType;
	    /**
	     * TimelineClip的起始时间。
	     *
	     * @type {number}
	     * @memberof TimelineClip
	     */
	    start: number;
	    /**
	     * TimelineClip的持续时间。
	     *
	     * @type {number}
	     * @memberof TimelineClip
	     */
	    duration: number;
	    /**
	     * TimelineClip混合渐入的持续时间。
	     *
	     * @type {number}
	     * @memberof TimelineClip
	     */
	    blendInDuration: number;
	    /**
	     * TimelineClip混合渐出的持续时间。
	     *
	     * @type {number}
	     * @memberof TimelineClip
	     */
	    blendOutDuration: number;
	    /**
	     * TimelineClip 的局部偏移时间。
	     *
	     * @type {number}
	     * @memberof TimelineClip
	     */
	    clipIn: number;
	    /**
	     * TimelineClip的播放速度倍数。
	     *
	     * @type {number}
	     * @memberof TimelineClip
	     */
	    timeScale: number;
	    /**
	     * clip混入时变化的模式。
	     *
	     * @type {TimelineClip.TimelineClipBlendCurveMode}
	     * @memberof TimelineClip
	     */
	    mixInCurveMode: TimelineClip.TimelineClipBlendCurveMode;
	    /**
	     * clip混出时变化的模式。
	     *
	     * @type {TimelineClip.TimelineClipBlendCurveMode}
	     * @memberof TimelineClip
	     */
	    mixOutCurveMode: TimelineClip.TimelineClipBlendCurveMode;
	    /**
	     * 后外推的时长。
	     *
	     * @memberof TimelineClip
	     */
	    postExtrapolationTime: number;
	    /**
	     * 前外推的时长。
	     *
	     * @memberof TimelineClip
	     */
	    preExtrapolationTime: number;
	    /**
	     * 后外推模式。
	     *
	     * @memberof TimelineClip
	     */
	    postExtrapolationMode: TimelineClipExtrapolation;
	    /**
	     * 前外推模式。
	     *
	     * @memberof TimelineClip
	     */
	    preExtrapolationMode: TimelineClipExtrapolation;
	    /**
	     * Animation或Audio所使用的clip资源。
	     *
	     * @readonly
	     * @type {(Nullable<AnimationClip | AudioClip>)}
	     * @memberof TimelineClip
	     */
	    get clip(): Nullable<AnimationClip | AudioClip>;
	    /**
	     * 该TimelineClip所使用的TimelineClipAsset资源。
	     *
	     * @type {Nullable<TimelineClip.TimelineClipAsset>}
	     * @memberof TimelineClip
	     */
	    playableAsset: Nullable<TimelineClip.TimelineClipAsset>;
	    /**
	     * 混入曲线。
	     * @memberof TimelineClip
	     */
	    get mixInCurve(): HermiteCurve;
	    set mixInCurve(val: HermiteCurve);
	    /**
	     * 混出曲线。
	     *
	     * @readonly
	     * @memberof TimelineClip
	     */
	    get mixOutCurve(): HermiteCurve;
	    set mixOutCurve(val: HermiteCurve);
	    get end(): number;
	    constructor(parent: TrackAsset);
	} namespace TimelineClip {
	    class TimelineClipCapsExtensions {
	        static SupportsLooping(clip: TimelineClip): boolean;
	        static SupportsExtrapolation(clip: TimelineClip): boolean;
	        static SupportsClipIn(clip: TimelineClip): boolean;
	        static SupportsSpeedMultiplier(clip: TimelineClip): boolean;
	        static SupportsBlending(clip: TimelineClip): boolean;
	        static HasAll(caps: ClipCapsClass, flags: ClipCapsClass): boolean;
	        static HasAny(caps: ClipCapsClass, flags: ClipCapsClass): boolean;
	    }
	    export import ClipExtrapolation = TimelineClipExtrapolation;
	    export import ClipCaps = ClipCapsClass;
	    export import PlayableType = EPlayableType;
	    export import TimelineClipBlendCurveMode = ETimelineClipBlendCurveMode;
	    export import TimelineClipAsset = TimelineClipAssetClass;
	    export import ActivationPlayableAsset = ActivationPlayableAssetClass;
	    export import AnimationPlayableAsset = AnimationPlayableAssetClass;
	    export import AudioPlayableAsset = AudioPlayableAssetClass;
	}
	export default TimelineClip;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { EPlayState } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/interface'; type PlayableGraph = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph').default; type TimelineClip = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip').default; class Playable {
	    id: number;
	    playState: EPlayState;
	    /**
	     * 所属的TimelineClip。
	     *
	     * @memberof Playable
	     */
	    get timelineClip(): Nullable<TimelineClip>;
	    set timelineClip(clip: Nullable<TimelineClip>);
	    constructor(playableGraph: PlayableGraph);
	    /**
	     * 创建一个Playable实例。
	     *
	     * @static
	     * @param {PlayableGraph} graph
	     * @param {...any[]} rest
	     * @returns {Playable}
	     * @memberof Playable
	     */
	    static Create(graph: PlayableGraph, ...rest: any[]): Playable;
	    getDuration(): number;
	} namespace Playable {
	}
	export default Playable;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable'; type PlayableOutput = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableOutput').default;
	export default class PlayableGraph {
	    isPlaying: boolean;
	    get localTime(): number;
	    static Create(): PlayableGraph;
	    createPlayable<T extends Playable>(ctor: new (...args: any) => T): T;
	    connect(source: Playable, sourceOutputPort: number, destination: Playable, destinationInputPort: number): boolean;
	    setOutput(output: PlayableOutput, port: number): void;
	    clearOutput(): void;
	    getRootPlayable(index: any): void;
	    getOutputCount(): number;
	    getOutput(index: number): Nullable<PlayableOutput>;
	    play(): void;
	    stop(): void;
	    setLocalTime(time: number): void;
	    evaluate(forceUpdate?: boolean): void;
	    destroy(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationPlayableOutput' {
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import PlayableOutput from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableOutput';
	export default class AnimationPlayableOutput extends PlayableOutput {
	    readonly playableGraph: PlayableGraph;
	    constructor(playableGraph: PlayableGraph);
	    static Create(graph: PlayableGraph): PlayableOutput;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioPlayableOutput' {
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import PlayableOutput from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableOutput';
	export default class AudioPlayableOutput extends PlayableOutput {
	    readonly playableGraph: PlayableGraph;
	    constructor(playableGraph: PlayableGraph);
	    static Create(graph: PlayableGraph): PlayableOutput;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/scriptPlayableOutput' {
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import PlayableOutput from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableOutput';
	export default class ScriptPlayableOutput extends PlayableOutput {
	    readonly playableGraph: PlayableGraph;
	    constructor(playableGraph: PlayableGraph);
	    static Create(graph: PlayableGraph): PlayableOutput;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBinding' {
	import { EPlaybaleTrackType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import PlayableOutput from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableOutput'; type TrackAsset = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset').default; type PlayableGraph = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph').default;
	/**
	 * 此类用来表示trackAsset的output绑定，
	 * trackAsset中记录playableBinding，
	 * playableOutput由playableBinding在创建timelinPlayable时生成
	 * trackAsset不理解playableOutput。
	 */
	export default class PlayableBinding {
	    referenceTrackAsset: TrackAsset;
	    trackBindingType: EPlaybaleTrackType;
	    createOutputMethod?: (graph: PlayableGraph) => PlayableOutput;
	    constructor(track: TrackAsset, trackBindingType: EPlaybaleTrackType);
	    createOutput(graph: PlayableGraph): Nullable<PlayableOutput>;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableUtilities' {
	import Animator from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator';
	import { AnimationMixerPlayable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationMixerPlayable';
	export default class PlayableUtilities {
	    /**
	     * 根据sourcePlayable生成一个runtimeAnimatorController，增加相应数量的state，并将state与对应的playable进行绑定。
	     * @param animator
	     * @param sourcePlayable
	     */
	    static GenerateAnimatorControllerFromPlayableAsset(animator: Animator, sourcePlayable: AnimationMixerPlayable): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableDirector' {
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import TimelineAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineAsset';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset'; enum EDiectorWrapMode {
	    Hold = 0,
	    Loop = 1,
	    None = 2
	} class PlayableDirector extends Component {
	    readonly entity: Entity3D;
	    /**
	     * Timeline实例在播放前需要延后的时间（单位秒）。
	     * @type {number}
	     * @memberof PlayableDirector
	     */
	    get initialTime(): number;
	    set initialTime(val: number);
	    /**
	     * Timeline资源。
	     * @type {Nullable<TimelineAsset>}
	     * @memberof PlayableDirector
	     */
	    get playableAsset(): Nullable<TimelineAsset>;
	    set playableAsset(val: Nullable<TimelineAsset>);
	    /**
	     * 播放模式。
	     * @memberof PlayableDirector
	     */
	    wrapMode: EDiectorWrapMode;
	    /**
	     * 在组件onAwake时开始播放。
	     * @memberof PlayableDirector
	     */
	    get playOnAwake(): boolean;
	    set playOnAwake(val: boolean);
	    /**
	     * Timeline的持续时间。
	     * @readonly
	     * @type {number}
	     * @memberof PlayableDirector
	     */
	    get duration(): number;
	    set localTime(val: number);
	    /**
	     * 是否在播放中。
	     *
	     * @readonly
	     * @memberof PlayableDirector
	     */
	    get isPlaying(): boolean;
	    readonly priority: number;
	    sceneBindingsMap: Map<TrackAsset, Nullable<Component>>;
	    playableGraph: PlayableGraph;
	    constructor(entity: Entity3D);
	    /**
	     * 播放。
	     * @param {TimelineAsset} [asset]
	     * @param {PlayableDirector.DiectorWrapMode} [mode]
	     * @memberof PlayableDirector
	     */
	    play(asset?: TimelineAsset, mode?: PlayableDirector.DiectorWrapMode): void;
	    /**
	     * 暂停。
	     * @memberof PlayableDirector
	     */
	    pause(): void;
	    /**
	     * 继续播放。
	     *
	     * @memberof PlayableDirector
	     */
	    resume(): void;
	    /**
	     * 停止。
	     *
	     * @memberof PlayableDirector
	     */
	    stop(): void;
	    /**
	     * 获取Track绑定的组件。
	     *
	     * @param {TrackAsset} trackAsset
	     * @returns {Nullable<Component>}
	     * @memberof PlayableDirector
	     */
	    getComponentBinding(trackAsset: TrackAsset): Nullable<Component>;
	    /**
	     * 回到初始状态。
	     *
	     * @memberof PlayableDirector
	     */
	    writeDefaults(): void;
	} namespace PlayableDirector {
	    export import DiectorWrapMode = EDiectorWrapMode;
	}
	export default PlayableDirector;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/extrapolation' {
	import type TimelineClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip';
	import type TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	export default class Extrapolation {
	    static CalculateExtrapolationTimes(trackAsset: TrackAsset): void;
	    static SortClipsByStartTime(clips: TimelineClip[]): TimelineClip[];
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import { EPlayableType, EPlaybaleTrackType, ITrackAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import TimelineClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip';
	import PlayableBinding from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBinding'; type TimelineAsset = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineAsset').default; abstract class TrackAsset implements ITrackAsset {
	    /**
	     * 该Track的所有片段。
	     * @type {TimelineClip[]}
	     * @memberof TrackAsset
	     */
	    clips: TimelineClip[];
	    /**
	     * 该Track的子Track。
	     *
	     * @type {TrackAsset[]}
	     * @memberof TrackAsset
	     */
	    children: TrackAsset[];
	    /**
	     * Track的name。
	     *
	     * @memberof TrackAsset
	     */
	    name: string;
	    /**
	     * track的类型。
	     * @readonly
	     * @type {TrackAsset.PlaybaleTrackAssetType}
	     * @memberof TrackAsset
	     */
	    type: TrackAsset.PlaybaleTrackAssetType;
	    /**
	     * 这个track是否不输出执行结果。
	     *
	     * @type {boolean}
	     * @memberof TrackAsset
	     */
	    muted: boolean;
	    /**
	     * 若该Track是根轨道的话，该属性为所属的TimelineAsset。
	     * 若该Track是子轨道的话，该属性为父TrackAsset
	     *
	     * @type {(Nullable<TrackAsset | TimelineAsset>)}
	     * @memberof TrackAsset
	     */
	    parent: Nullable<TrackAsset | TimelineAsset>;
	    /**
	     * 该Track所属的TimelineAsset。
	     *
	     * @readonly
	     * @type {Nullable<TimelineAsset>}
	     * @memberof TrackAsset
	     */
	    get timelineAsset(): Nullable<TimelineAsset>;
	    /**
	     * 是否是子轨道。
	     *
	     * @readonly
	     * @memberof TrackAsset
	     */
	    get isSubTrack(): boolean;
	    /**
	     * 该track的起始时间。
	     *
	     * @readonly
	     * @memberof TrackAsset
	     */
	    get start(): number;
	    /**
	     * 该track的终止时间。
	     *
	     * @readonly
	     * @memberof TrackAsset
	     */
	    get end(): number;
	    /**
	     * 该track的持续时间。
	     *
	     * @readonly
	     * @memberof TrackAsset
	     */
	    get duration(): number;
	    /**
	     * 增加子track。
	     *
	     * @param {*} track
	     * @memberof TrackAsset
	     */
	    addSubTrack(track: TrackAsset): void;
	    /**
	     * 移除子track。
	     *
	     * @param {TrackAsset} track
	     * @memberof TrackAsset
	     */
	    removeSubTrack(track: TrackAsset): void;
	    /**
	     * 移除所有子Track。
	     *
	     * @memberof TrackAsset
	     */
	    removeAllSubTracks(): void;
	    /**
	     * 移除timelineClip。
	     *
	     * @param {TimelineClip} clip
	     * @memberof TrackAsset
	     */
	    removeClip(clip: TimelineClip): void;
	    /**
	     * 添加TimelineClip。
	     *
	     * @param {TimelineClip} clip
	     * @memberof TrackAsset
	     */
	    addClip(clip: TimelineClip): void;
	    /**
	     * 根据类型，创建TimelineClip。
	     *
	     * @param {(EPlayableType | string)} [type]
	     * @returns {TimelineClip}
	     * @memberof TrackAsset
	     */
	    createClip(type?: EPlayableType | string): TimelineClip;
	    /**
	     * 创建一个timelineClip的空壳。
	     * @intrenal
	     * @returns {TimelineClip}
	     * @memberof TrackAsset
	     */
	    createNewTimelineClipInternal(): TimelineClip;
	    createPlayable(): null;
	    createClipPlayable(graph: PlayableGraph, clip: TimelineClip): Nullable<Playable>;
	    /**
	     * 生成这个track下的所有clips，形成一个树状结构。
	     * @intenral
	     * @param graph
	     */
	    createPlayableGraph(graph: PlayableGraph): Playable;
	    /**
	     * 创建MixerPlayable，需要重载。
	     *
	     * @param {PlayableGraph} graph
	     * @returns {Playable}
	     * @memberof TrackAsset
	     */
	    createTrackMixer(graph: PlayableGraph): Playable;
	} namespace TrackAsset {
	    /** Track资源类型 */
	    export import PlaybaleTrackAssetType = EPlaybaleTrackType;
	}
	export default TrackAsset;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioTrack' {
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset'; class AudioTrack extends TrackAsset {
	    /**
	     * 音量，范围[0, 1]。
	     * @memberof AudioTrack
	     */
	    get volume(): number;
	    set volume(val: number);
	    set stereoPan(val: number);
	    set spatialBlend(val: number);
	    type: TrackAsset.PlaybaleTrackAssetType;
	} namespace AudioTrack { }
	export default AudioTrack;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/activation/activationMixerPlayable' {
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import { EPostPlaybackState } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import type { FrameData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/interface';
	import PlayableBehaviour from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBehaviour';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	export class ActivationMixerPlayable extends Playable {
	}
	export default class ActivationMixerPlayableBehaviour extends PlayableBehaviour {
	    static PlayableClass: typeof ActivationMixerPlayable;
	    get postPlaybackState(): EPostPlaybackState;
	    set postPlaybackState(val: EPostPlaybackState);
	    static Create(graph: PlayableGraph): Playable;
	    OnPlayableDestroy(): void;
	    ProcessFrame(playable: Playable, info: FrameData, playerData: Entity | Transform3D): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/activation/activationTrack' {
	import { EPlaybaleTrackType, EPostPlaybackState } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset'; class ActivationTrack extends TrackAsset {
	    type: EPlaybaleTrackType;
	    /**
	     * 执行结束后，active的状态。
	     *
	     * @memberof ActivationTrack
	     */
	    get postPlaybackState(): EPostPlaybackState;
	    set postPlaybackState(val: EPostPlaybackState);
	} namespace ActivationTrack { }
	export default ActivationTrack;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationTrack' {
	import { TimelineClipExtrapolation, EPlaybaleTrackType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import AvatarMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatarMask';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import TimelineClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip';
	import AnimationPlayableAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationPlayableAsset'; class AnimationTrack extends TrackAsset {
	    matchTargetFields: {
	        PositionX: boolean;
	        PositionY: boolean;
	        PositionZ: boolean;
	        RotationX: boolean;
	        RotationY: boolean;
	        RotationZ: boolean;
	    };
	    type: EPlaybaleTrackType;
	    /**
	     * 是否使用AvatarMask。
	     * @memberof AnimationTrack
	     */
	    get applyAvatarMask(): boolean;
	    set applyAvatarMask(val: boolean);
	    /**
	     * AvatarMask资源。
	     * @memberof AnimationTrack
	     */
	    get avatarMask(): Nullable<AvatarMask>;
	    set avatarMask(val: Nullable<AvatarMask>);
	    /**
	     * 无限长的AnimationClip资源。
	     * @memberof AnimationTrack
	     */
	    get infinityClip(): Nullable<AnimationClip>;
	    set infinityClip(val: Nullable<AnimationClip>);
	    get infinityTimelineClip(): Nullable<AnimationTrack.InfinityTimelineClip>;
	} namespace AnimationTrack {
	    class InfinityTimelineClip extends TimelineClip {
	        readonly parent: TrackAsset;
	        start: number;
	        duration: number;
	        blendInDuration: number;
	        blendOutDuration: number;
	        clipIn: number;
	        timeScale: number;
	        postExtrapolationTime: number;
	        preExtrapolationTime: number;
	        postExtrapolationMode: TimelineClipExtrapolation;
	        preExtrapolationMode: TimelineClipExtrapolation;
	        playableAsset: AnimationPlayableAsset;
	        constructor(parent: TrackAsset, animationClip: AnimationClip);
	    }
	}
	export default AnimationTrack;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/groupTrack' {
	import { EPlaybaleTrackType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset'; class GroupTrack extends TrackAsset {
	    type: EPlaybaleTrackType;
	    get outputBinding(): null;
	    canCompileClips(): boolean;
	} namespace GroupTrack { }
	export default GroupTrack;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineAsset' {
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import { EPlayableType, EPlaybaleTrackType, ITimelineAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import type TimelineClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip';
	import AudioTrackClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/audio/audioTrack';
	import ActivationTrackClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/activation/activationTrack';
	import AnimationTrackClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/animation/animationTrack';
	import GroupTrackClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/groupTrack'; enum EDurationMode {
	    /** 根据最后一个Clip的结束时间作为Timeline资源的执行时长。 */
	    BasedOnClips = 0,
	    /** 固定长度模式，可以设置Duration的固定长度。  */
	    FixedLength = 1
	} class TimelineAsset extends BaseResource implements ITimelineAsset {
	    /**
	     * Timeline资源的名字。
	     * @memberof TimelineAsset
	     */
	    get name(): string;
	    set name(val: string);
	    /**
	     * Timeline执行的时长模式。
	     *
	     * @memberof TimelineAsset
	     */
	    get durationMode(): EDurationMode;
	    set durationMode(val: EDurationMode);
	    /**
	     * 若DurationMode为FixedLength时，该值表示该Timeline资源的总执行时长。
	     * @memberof TimelineAsset
	     */
	    get fixedDuration(): number;
	    set fixedDuration(val: number);
	    /**
	     * Timeline资源的帧率。
	     *
	     * @memberof TimelineAsset
	     */
	    get frameRate(): number;
	    set frameRate(val: number);
	    /**
	     * 根轨道（track）的列表。
	     * @readonly
	     * @memberof TimelineAsset
	     */
	    get rootTracks(): TrackAsset[];
	    /**
	     * 有输出的的轨道列表。如剔除了GroupTrack以及subTrack。
	     *
	     * @readonly
	     * @type {TrackAsset[]}
	     * @memberof TimelineAsset
	     */
	    get outputTracks(): TrackAsset[];
	    /**
	     * 所有轨道展平后的列表。
	     *
	     * @readonly
	     * @type {TrackAsset[]}
	     * @memberof TimelineAsset
	     */
	    get flattenTracks(): TrackAsset[];
	    /**
	     * Timeline持续的事件。
	     *
	     * @readonly
	     * @memberof TimelineAsset
	     */
	    get duration(): number;
	    constructor();
	    /**
	     * 创建playable实例。
	     *
	     * @param {PlayableGraph} graph
	     * @returns {Playable}
	     * @memberof TimelineAsset
	     */
	    createPlayable(graph: PlayableGraph): Playable;
	    /**
	     * SDK 新建一个trackAsset。
	     *
	     * @param {(TimelineAsset.PlaybaleTrackAssetType | string)} type 若是custom trackAsset，type为其装饰器上的serialize名字
	     * @param {string} name
	     * @param {Nullable<TrackAsset>} [parent=null] 若是null，表示所创建的trackAsset是该timeline的rootTrack
	     * @returns {TrackAsset}
	     * @memberof TimelineAsset
	     */
	    createTrack(type: TimelineAsset.PlaybaleTrackAssetType | string, name: string, parent?: Nullable<TrackAsset>): TrackAsset;
	    /**
	     * 删除Track。
	     *
	     * @param {TrackAsset} trackAsset
	     * @returns {boolean}
	     * @memberof TimelineAsset
	     */
	    deleteTrack(trackAsset: TrackAsset): boolean;
	    /**
	     * 删除TimelineClip。
	     *
	     * @param {TimelineClip} clip
	     * @returns {boolean}
	     * @memberof TimelineAsset
	     */
	    deleteClip(clip: TimelineClip): boolean;
	} namespace TimelineAsset {
	    /** 执行的时长模式。 */
	    export import DurationMode = EDurationMode;
	    /** Track资源类型 */
	    export import PlaybaleTrackAssetType = EPlaybaleTrackType;
	    /** Clip资源类型 */
	    export import PlaybaleClipAssetType = EPlayableType;
	    /** 音频Track */
	    export import AudioTrack = AudioTrackClass;
	    /** 激活Track */
	    export import ActivationTrack = ActivationTrackClass;
	    /** 动画Track */
	    export import AnimationTrack = AnimationTrackClass;
	    /** 组Track */
	    export import GroupTrack = GroupTrackClass;
	}
	export default TimelineAsset;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/ide/load' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	export type Meta = {
	    uuid: string;
	    type: string;
	    size: number;
	    fileType: string;
	    filePath: string;
	    dependencies: string[];
	    fileDependencies: string[];
	};
	export function loadAllMeta(resourceID: string): LitePromise<{
	    [id: string]: Meta;
	}>;
	export function loadMeta(resourceID: string): LitePromise<Meta>;
	export function loadContent(filePath: string, fileType: string, fetchUseCache?: boolean): LitePromise<any>;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/ide' {
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	export default class IDELoadContext extends BaseLoadContext {
	    get progress(): {
	        total: number;
	        current: number;
	    };
	    get loaded(): boolean;
	    uuid?: string;
	    size: number;
	    constructor(id: string, fetchCache: boolean);
	    loadMeta(): LitePromise<any>;
	    getDependencies(): string[];
	    load(): LitePromise<any>;
	    getFileSrc(fileID: string): string;
	    getImageSrc(fileID: string): string;
	    getFile<T>(fileID: string): T | null;
	    getAsset(): any;
	    static clearTypeList: Array<string>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader/ide' {
	import { ILoadOptions } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/interface';
	import LoadTask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task';
	import BaseLoader from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader/base';
	/**
	 * @export
	 * @class IDELoader
	 * @extends {BaseLoader}
	 */
	export class IDELoader extends BaseLoader {
	    constructor();
	    /**
	     *
	     * @template T 资源类型
	     * @param {string} assetid 资源id
	     * @param {ILoadOptions} [options={}] 加载参数
	     * @returns {LoadTask<T>}
	     * @memberof Loader
	     */
	    load<T>(assetID: string, options?: ILoadOptions): LoadTask<T>;
	    /**
	     * 同上load, 只是editor内部专用，不检查是否入口资源
	     */
	    innerLoad<T>(assetID: string, options?: ILoadOptions): LoadTask<T>;
	    getFile<T>(fileID: string): T | null;
	    getFileSrc(fileID: string): string;
	    getImageSrc(fileID: string): string;
	    assetExists(assetID: string): boolean;
	    getAssetWithType<T>(assetID: string, type: string): T | null;
	    /**
	     * 同步获取一个资源实例
	     *
	     * @template T
	     * @param {string} assetID 资源ID
	     * @param {string} backupAssetID 备份资源ID
	     * @returns {T}
	     * @memberof Loader
	     */
	    getAsset<T>(assetID: string): T | null;
	    clearLoadCache(id?: string): void;
	    /**
	     * IDE编辑态切换场景时使用，用来清除RT之类有残留的资源。
	     */
	    clearCacheOnPlayingScene(): void;
	} const _default: IDELoader;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/decorators' {
	 const Decorators: {
	    /**
	     * ceated by janzen
	     * 用来对外暴露引擎的decorators
	     */
	    CreateAssetMenu(fileName?: string, menuName?: string, order?: number): ClassDecorator;
	    EditorWindow(name: string, windowLabel: string): ClassDecorator;
	    Criterion(criterionName?: string): ClassDecorator;
	    PropInspector(name: string): ClassDecorator;
	    Inspector(typeName: string): ClassDecorator;
	    InsepctorName(typeName: string): (classCtor: any) => void;
	    CustomBuildComponent(typeName: string): ClassDecorator;
	    CustomComponentInspector(typeName: string): ClassDecorator;
	    CustomPropertyInspector(typeName: string): ClassDecorator;
	    UseSerializedData(typeName: string): ClassDecorator;
	    SerializedData(typeName: string): ClassDecorator;
	    context: (aliasTable: {
	        [key: string]: string;
	    }) => (classCtor: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').SerializableCtor) => void;
	    serialize: (typeName: string, isValueType?: boolean) => ClassDecorator;
	    trackAssetConfig: ({ clipTypeName, bindingTypeName, color, visible }: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').ITrackConfig) => ClassDecorator;
	    audioEffectComponentConfig: (options: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').IAudioEffectComponentConfig) => ClassDecorator;
	    audioSideChainInterface: (options: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').ISideChainConfig) => PropertyDecorator;
	    snapshotParameter: (options: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').ISnapshotParamConfig) => PropertyDecorator;
	    componentDimensionType: (dimensionType: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').EComponentDimensionType) => (classCtor: Function) => void;
	    writable: (value: boolean) => (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
	    property: {
	        (config: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').IPropertyConfig): PropertyDecorator & ParameterDecorator;
	        multi(config: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').IPropertyMultiConfig): PropertyDecorator & ParameterDecorator;
	        enum(config: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').IPropertyEnumConfig): PropertyDecorator & ParameterDecorator;
	        array(index: number, config: import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators').IPropertyConfig & {
	            type: string;
	        }): PropertyDecorator & ParameterDecorator;
	    };
	};
	export default Decorators;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animation' {
	import type { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import type { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import type AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import AnimationEventClass from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimationEvent';
	import { AnimationUtility } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Utility';
	import Skeleton from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skeleton';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter'; class Animation extends Component {
	    readonly entity: Entity3D;
	    /**
	     * 动画播放的时长。
	     */
	    get time(): number;
	    /**
	     * 组件是否有
	     */
	    get isPlaying(): boolean;
	    /**
	     * 组件的播放模式。
	     */
	    get mode(): Animation.WrapMode;
	    /**
	     * 正在播放的动画名称。
	     */
	    get playingClip(): Nullable<string>;
	    /**
	     * 组件初始化时默认播放的动画名称。
	     */
	    get clip(): Nullable<string>;
	    /**
	     * 是否进行动态动画绑定，对于动画数目特别多的使用场景会降低初始化的耗时。
	     */
	    bindAnimationClipOnNeed: boolean;
	    /**
	     * 动画组件所控制的骨骼。
	     */
	    get skeleton(): Nullable<Skeleton>;
	    set skeleton(skeleton: Nullable<Skeleton>);
	    /**
	     * 初次被加载到场景上时是否自动播放，如果开启此选项，组件将在初次被加载到场景上时播放`默认播放的动画名`所对应的动画。
	     */
	    autoPlay: boolean;
	    /**
	     * 组件播放动画的速度。
	     */
	    speed: number;
	    /**
	     * 组件所控制的动画集，运行时直接更改此对象内容需要手动调用`rebind`方法。
	     */
	    clips: {
	        [key: string]: Nullable<AnimationClip>;
	    };
	    constructor(entity: Entity3D);
	    /**
	     * 播放指定动画。
	     * @param name 动画名称
	     * @param time 初始偏移时长
	     * @param mode 播放方式
	     * @returns
	     */
	    play(name?: string, time?: number, mode?: Animation.WrapMode): void;
	    /**
	     * 暂停动画播放。
	     */
	    pause(): void;
	    /**
	     * 恢复动画播放。
	     */
	    resume(): void;
	    /**
	     * 停止动画播放。
	     */
	    stop(): void;
	    /**
	     * 获取名称对应的动画资源。
	     * @param name 动画名称
	     * @returns
	     */
	    getClip(name: string): Nullable<AnimationClip>;
	    /**
	     * 添加动画。
	     * @param name 动画名称
	     * @param clip 动画资源
	     */
	    addClip(name: string, clip: AnimationClip): void;
	    /**
	     * 删除动画。
	     * @param name 动画名称
	     */
	    removeClip(name: string): void;
	    /**
	     * 重置骨骼节点位置。
	     */
	    writeDefaults(): void;
	    /**
	     * 重新绑定骨骼与动画。
	     */
	    rebind(): void;
	    update(dt: number): void;
	} namespace Animation {
	    /**
	       * 动画事件类。
	       */
	    export import AnimationEvent = AnimationEventClass;
	    /**
	     * 动画播放模式
	     */
	    enum WrapMode {
	        /**
	         * 同Once。
	         */
	        Default = 0,
	        /**
	         * 当动画片段播放到尾部时，动画片段会自动停止，并把时间重置回动画片段的起始时间。
	         */
	        Once = 1,
	        /**
	         * 当动画片段播放到尾部时，动画片段会重置回动画片段的起始时间然后继续播放。
	         */
	        Loop = 2,
	        /**
	         * 当动画片段播放到尾部时，动画片段会从动画片段的终止时间反向继续播放，当再次回到动画片段的起始时间时又会继续正向播放，如此不断循环。
	         */
	        PingPong = 4,
	        /**
	         * 当动画片段播放到尾部时，动画片段会一直停留在动画片段的终止时间（动画并不会停止）。
	         */
	        ClampForever = 8
	    }
	}
	export default Animation;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/SkinnedAnimationRenderer' {
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import { EnumRendererType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/materials/buildinShaderDesc';
	import Animation from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animation';
	import type { Entity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import type { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import type AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import AnimationEvent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimationEvent';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import MeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	/**
	 * 烘焙动画组件。
	 */
	export default class SkinnedAnimationRenderer extends MeshRenderer {
	    readonly entity: Entity3D;
	    get time(): number;
	    get isPlaying(): boolean;
	    get mode(): Animation.WrapMode;
	    get playingClip(): Nullable<string>;
	    get clip(): Nullable<string>;
	    autoPlay: boolean;
	    speed: number;
	    default: Nullable<Texture2D>;
	    clips: {
	        [key: string]: {
	            clip: Nullable<AnimationClip>;
	            map: Nullable<Texture2D>;
	        };
	    };
	    onDeserialized(data: {
	        autoPlay: boolean;
	        clip?: string;
	        clips: Array<{
	            name?: string;
	            clip?: string;
	            map?: string;
	        }>;
	    }, context: {
	        [key: string]: any[];
	    }, builtContext: {
	        [key: string]: SmartArray<any>;
	    }): void;
	    play(name?: string, time?: number, mode?: Animation.WrapMode): void;
	    pause(): void;
	    resume(): void;
	    stop(): void;
	    writeDefaults(): void;
	    update(dt: number): void;
	    constructor(entity: Entity3D);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/ideLayout' {
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { Popup, Tap, IDELayoutResourceDescription } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	/**
	 * 编辑器布局文件
	 */
	export default class IDELayout extends BaseResource {
	    get taps(): Array<Tap>;
	    set taps(taps: Array<Tap>);
	    get popups(): Array<Popup>;
	    set popups(popups: Array<Popup>);
	    get windowWidth(): number;
	    set windowWidth(windowWidth: number);
	    get windowHeight(): number;
	    set windowHeight(windowHeight: number);
	    static DeserializeResource(resourceDescription: IDELayoutResourceDescription, loadContext: BaseLoadContext, dependencies: string[] | undefined): BaseResource;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorial' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { TutorialResourceDescription, TutorialSectionResourceDescription, IDELayoutResourceDescription, TutorialWelcomeResourceDescription, TutorialHooks, LoadIDELayoutMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	interface ITutorialSectionItem {
	    order: number;
	    section: Nullable<TutorialSectionResourceDescription>;
	}
	/**
	 * .tutorial资源 新手引导文件
	 */
	export default class Tutorial extends BaseResource {
	    get version(): number;
	    set version(version: number);
	    get title(): string;
	    set title(title: string);
	    get subTitle(): string;
	    set subTitle(subTitle: string);
	    get description(): string;
	    set description(description: string);
	    get layout(): IDELayoutResourceDescription;
	    set layout(layout: IDELayoutResourceDescription);
	    get layoutMode(): LoadIDELayoutMode;
	    set layoutMode(layoutMode: LoadIDELayoutMode);
	    get welcomePage(): TutorialWelcomeResourceDescription;
	    set welcomePage(welcomePage: TutorialWelcomeResourceDescription);
	    get sections(): Array<ITutorialSectionItem>;
	    set sections(sections: Array<ITutorialSectionItem>);
	    get autoComplete(): boolean;
	    set autoComplete(autoComplete: boolean);
	    get onEnter(): TutorialHooks;
	    set onEnter(onEnter: TutorialHooks);
	    get onExit(): TutorialHooks;
	    set onExit(onExit: TutorialHooks);
	    addSection(): ITutorialSectionItem[];
	    removeSection(index: number): ITutorialSectionItem[];
	    setSection(index: any, sec: ITutorialSectionItem): ITutorialSectionItem[];
	    static DeserializeResource(resourceDescription: TutorialResourceDescription, loadContext: BaseLoadContext, dependencies: string[] | undefined): BaseResource;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorialPage' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { TextureResourceDescription, TutorialPageResourceDescription, CriteriaPassType, Criteria, PageMediaType, UnmaskedView, SelectType, ControlSelectorMode, ViewControl, EditorTip, MaskType, TutorialHooks } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	/**
	 * .tutorial资源 新手引导文件
	 */
	export default class TutorialPage extends BaseResource {
	    static CriteriaPassTypes: CriteriaPassType;
	    static PageMediaTypes: PageMediaType;
	    static MaskSelectTypes: SelectType;
	    static ControlSelectorTypes: ControlSelectorMode;
	    static MaskTypes: MaskType;
	    get version(): number;
	    set version(version: number);
	    get activeWindow(): string;
	    set activeWindow(activeWindow: string);
	    get narrativeTitle(): string;
	    set narrativeTitle(narrativeTitle: string);
	    get narrativeDescription(): string;
	    set narrativeDescription(narrativeDescription: string);
	    get enableInstruction(): boolean;
	    set enableInstruction(enableInstruction: boolean);
	    get instructionTitle(): string;
	    set instructionTitle(instructionTitle: string);
	    get instructionDescription(): string;
	    set instructionDescription(instructionDescription: string);
	    get criteriaPassType(): CriteriaPassType;
	    set criteriaPassType(passType: CriteriaPassType);
	    get criterias(): Array<Criteria>;
	    set criterias(criterias: Array<Criteria>);
	    get enableMasking(): boolean;
	    set enableMasking(enableMasking: boolean);
	    get unmaskedViews(): Array<UnmaskedView>;
	    set unmaskedViews(unmaskedViews: Array<UnmaskedView>);
	    get nextButton(): string;
	    set nextButton(nextButton: string);
	    get doneButton(): string;
	    set doneButton(doneButton: string);
	    get autoComplete(): boolean;
	    set autoComplete(autoComplete: boolean);
	    get mediaType(): PageMediaType;
	    set mediaType(mediaType: PageMediaType);
	    get image(): Nullable<TextureResourceDescription>;
	    set image(image: Nullable<TextureResourceDescription>);
	    get video(): Nullable<BaseResource>;
	    set video(video: Nullable<BaseResource>);
	    get onEnter(): TutorialHooks;
	    set onEnter(onEnter: TutorialHooks);
	    get onExit(): TutorialHooks;
	    set onExit(onExit: TutorialHooks);
	    addCriteria(): void;
	    removeCriteria(index: number): void;
	    setCriterial(index: number, criteria: string): void;
	    addUnmaskedView(item?: UnmaskedView): void;
	    removeUnmaskedView(index: number): void;
	    addUnmaskedControl(viewIndex: number, item?: ViewControl): void;
	    removeUnmaskedControl(viewIndex: number, index: number): void;
	    addEditorTip(viewIndex: number, item?: EditorTip): void;
	    removeEditorTip(viewIndex: number, index: number): void;
	    static DeserializeResource(resourceDescription: TutorialPageResourceDescription, loadContext: BaseLoadContext, dependencies: string[] | undefined): BaseResource;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorialSection' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { TextureResourceDescription, TutorialSectionResourceDescription, IDELayoutResourceDescription, TutorialWelcomeResourceDescription, TutorialHooks, LoadIDELayoutMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import TutorialPage from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorialPage';
	interface ITutorialPageItem {
	    page: Nullable<TutorialPage>;
	}
	/**
	 * .tutorial资源 新手引导文件
	 */
	export default class TutorialSection extends BaseResource {
	    get version(): number;
	    set version(version: number);
	    get title(): string;
	    set title(title: string);
	    get description(): string;
	    set description(description: string);
	    get image(): Nullable<TextureResourceDescription>;
	    set image(image: Nullable<TextureResourceDescription>);
	    get url(): string;
	    set url(url: string);
	    get layout(): IDELayoutResourceDescription;
	    set layout(layout: IDELayoutResourceDescription);
	    get layoutMode(): LoadIDELayoutMode;
	    set layoutMode(layoutMode: LoadIDELayoutMode);
	    get welcomePage(): TutorialWelcomeResourceDescription;
	    set welcomePage(welcomePage: TutorialWelcomeResourceDescription);
	    get pages(): Array<ITutorialPageItem>;
	    set pages(pages: Array<ITutorialPageItem>);
	    get autoComplete(): boolean;
	    set autoComplete(autoComplete: boolean);
	    get onEnter(): TutorialHooks;
	    set onEnter(onEnter: TutorialHooks);
	    get onExit(): TutorialHooks;
	    set onExit(onExit: TutorialHooks);
	    addPage(): void;
	    removePage(index: number): void;
	    setPage(index: any, pageItem: ITutorialPageItem): void;
	    static DeserializeResource(resourceDescription: TutorialSectionResourceDescription, loadContext: BaseLoadContext, dependencies: string[] | undefined): BaseResource;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorialWelcome' {
	import BaseLoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/base';
	import { TutorialWelcomeButton, TutorialWelcomeResourceDescription, TutorialWelcomeCententMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	/**
	 * .tutorial资源 新手引导 欢迎页
	 */
	export default class TutorialWelcome extends BaseResource {
	    get title(): string;
	    set title(title: string);
	    get mode(): TutorialWelcomeCententMode;
	    set mode(mode: TutorialWelcomeCententMode);
	    get content(): string;
	    set content(content: string);
	    get markdown(): string;
	    set markdown(uuid: string);
	    get image(): HTMLImageElement | ArrayBuffer;
	    set image(image: HTMLImageElement | ArrayBuffer);
	    get buttons(): Array<TutorialWelcomeButton>;
	    set buttons(buttons: Array<TutorialWelcomeButton>);
	    static DeserializeResource(resourceDescription: TutorialWelcomeResourceDescription, loadContext: BaseLoadContext, dependencies: string[] | undefined): BaseResource;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/baseResource' {
	 type BaseResource = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource').default;
	export function SerializeBaseResource(this: BaseResource, resource: BaseResource, context: any): string | null;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/entity' {
	 type Entity = import('!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity').default;
	export function SerializeEntity(entity: Entity,context: any): object;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/gradientColor' {
	 type GradientColor = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/gradientColor').default; type ISerializeData = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/gradientColor').ISerializeData;
	export function SerializeGradientColor(target: GradientColor, context?: {
	    [key: string]: any;
	}): ISerializeData;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/hermiteCurve' {
	 type HermiteCurve = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hermiteCurve').default; type ISerializeData = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hermiteCurve').ISerializeData;
	export function SerializeHermiteCurve(target: HermiteCurve, context?: {
	    [key: string]: any;
	}): ISerializeData;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/transform3D' {
	 type Transform3D = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D').default;
	export function SerializeTransform3D(target: Transform3D, context: any): {
	    position: any;
	    scale: any;
	    rotation: undefined;
	    size: any;
	    anchor: any;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/effect' {
	 type Effect = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect').default;
	export function SerializeEffect(this: Effect, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/material' {
	 type Material = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material').default;
	/**
	 * @export
	 * @param {Material} this
	 * @param {*} context
	 * @returns {{ content?: object; meta?: object }}
	 */
	export function SerializeMaterial(this: Material, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/physicMaterial' {
	 type PhysicMaterial = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/physicMaterial').default;
	export function SerializePhysicMaterial(this: PhysicMaterial, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/mesh' {
	 type Mesh = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh').default;
	export function SerializeMesh(this: Mesh, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/font' {
	 type Font = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/font').default;
	export function SerializeFont(this: Font, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/spriteframe' {
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	export function SerializeSpriteframe(this: SpriteFrame, context: any): {
	    content?: object;
	    meta?: object;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/texture2d' {
	 type Texture2D = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D').default;
	export function SerializeTexture2D(this: Texture2D, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/rendertexture' {
	import rendertexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	export function SerializeRenderTexture(this: rendertexture, context: any): {
	    content?: object;
	    meta?: object;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/animationClip' {
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	export function SerializeAnimationClip(this: AnimationClip, context: any): {
	    meta?: any;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/avatarMask' {
	import AvatarMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatarMask';
	interface IAvatarMaskContent {
	    name: string;
	    paths: {
	        [key: string]: number;
	    };
	}
	export function SerializeAvatarMask(this: AvatarMask, context: any): {
	    content: IAvatarMaskContent;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/animatorController' {
	import AnimatorController from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animatorController';
	import { default as RuntimeAnimatorController } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/AnimatorController';
	/**
	 * 序列化animatorController
	 * @param instance AnimatorController运行时实例
	 * @param fromInstance true:使用instance重新生成资源文件内容；false：只使用instance生成editor相关内容，其他使用this.description
	 */
	export function SerializeAnimatorController(this: AnimatorController, { instance, fromInstance }: {
	    instance: RuntimeAnimatorController;
	    fromInstance: boolean;
	}): {
	    content?: any;
	    meta?: any;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/avatar' {
	import Avatar from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatar';
	export function SerializeAvatar(this: Avatar, context: any): {
	    content?: object;
	    meta?: object;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/audioMixer' {
	import type AudioMixer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixer';
	import type AudioMixerAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/audioMixerAsset';
	export function SerializeAudioMixer(this: AudioMixerAsset, audioMixer: AudioMixer): {
	    content?: any;
	    meta?: any;
	};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/scriptableAsset' {
	 type ScriptableAsset = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/scriptableAsset').default;
	export function SerializeScriptableAsset(this: ScriptableAsset, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/textureCube' {
	 type textureCube = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/textureCube').default;
	export function SerializeTextureCube(this: textureCube, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/timelineAsset' {
	import { ITimelineActivationClipInfo, ITimelineActivationTrackInfo, ITimelineAnimationClipInfo, ITimelineAnimationTrackInfo, ITimelineAudioClipInfo, ITimelineAudioTrackInfo, ITimelineControlClipInfo, ITimelineControlTrackInfo, ITimelineCustomClipInfo, ITimelineCustomTrackInfo, ITimelinePlayableAsset, ITimelinePlayableAssetClipBaseInfo, ITimelinePlayableAssetTrackBaseInfo } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import TimelineClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip'; type TimelineAsset = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineAsset').default;
	export function SerializeTimelineAsset(this: TimelineAsset, context: any): {
	    content?: ITimelinePlayableAsset;
	    meta?: any;
	};
	export function getTrackDataRecursive(trackAsset: TrackAsset, trackList: Array<ITimelinePlayableAssetTrackBaseInfo | ITimelineActivationTrackInfo | ITimelineAudioTrackInfo | ITimelineAnimationTrackInfo | ITimelineControlTrackInfo | ITimelineCustomTrackInfo>, clipList: Array<ITimelinePlayableAssetClipBaseInfo | ITimelineActivationClipInfo | ITimelineAudioClipInfo | ITimelineAnimationClipInfo | ITimelineControlClipInfo | ITimelineCustomClipInfo>): number;
	export function getTimelineClipData(timelineClip: TimelineClip, clipList: Array<ITimelinePlayableAssetClipBaseInfo | ITimelineActivationClipInfo | ITimelineAudioClipInfo | ITimelineAnimationClipInfo | ITimelineControlClipInfo | ITimelineCustomClipInfo>): number;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/meshRenderer' {
	 type MeshRenderer = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer').default;
	export function OnSerializedMeshRenderer(this: MeshRenderer, compJson: any): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/animator' {
	 type Animator = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator').default;
	export function OnSerializedAnimator(this: Animator, compJson: any): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/animation' {
	 type Animation = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animation').default;
	export function OnSerializedAnimation(this: Animation, compJson: any): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/LODGroup' {
	 type LODGroup = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/LODGroup').default;
	export function SerializeLODGroup(target: LODGroup, context: any): {};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/playableDirector' {
	 type PlayableDirector = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableDirector').default;
	export function OnSerializedPlayableDirector(this: PlayableDirector, compJson: any): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/skeleton' {
	import { AnimationUtility } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Utility'; type Skeleton = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skeleton').default;
	export function OnSerializedSkeleton(this: Skeleton, compJson: {
	    configuration: {
	        type: AnimationUtility.AnimationAvatarBindingType.Dynamic;
	        remapping: {
	            [key: string]: string | null;
	        };
	    } | {
	        type: AnimationUtility.AnimationAvatarBindingType.Static;
	        avatar: string;
	        remapping: {
	            [key: string]: {
	                modelPath: string | "=" | "-";
	                bindingTransform: string | null;
	            };
	        };
	    };
	}): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/ideLayout' {
	 type Layout = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/ideLayout').default;
	export function SerializeIDELayout(this: Layout, context: any): {
	    content?: object;
	    meta?: object;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/resources/tutorial' {
	 type Tutorial = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorial').default; type TutorialSection = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorialSection').default; type TutorialPage = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorialPage').default; type TutorialWelcome = import('!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/tutorial/tutorialWelcome').default;
	export const SerializeTutorial: (this: Tutorial, context: any) => {
	    content?: object | undefined;
	    meta?: object | undefined;
	};
	export const SerializeTutorialSection: (this: TutorialSection, context: any) => {
	    content?: object | undefined;
	    meta?: object | undefined;
	};
	export const SerializeTutorialPage: (this: TutorialPage, context: any) => {
	    content?: object | undefined;
	    meta?: object | undefined;
	};
	export const SerializeTutorialWelcome: (this: TutorialWelcome, context: any) => {
	    content?: object | undefined;
	    meta?: object | undefined;
	};
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/streaming-loading' {
	 type StreamingLoadingComponent = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/streaming-loading').default;
	export function OnSerializedStreamingLoadingComponent(this: StreamingLoadingComponent, compJson: any): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/classes/skinnedAnimationrenderer' {
	 type SkinnedAnimationRenderer = import('!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/SkinnedAnimationRenderer').default;
	export function OnSerializedSkinnedAnimationRenderer(this: SkinnedAnimationRenderer, compJson: any): void;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize' {
	export default function installSerializationMethods(): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIAnchor' {
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import { BoundsChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	export enum Side {
	    BottomLeft = "BottomLeft",
	    Left = "Left",
	    TopLeft = "TopLeft",
	    Top = "Top",
	    TopRight = "TopRight",
	    Right = "Right",
	    BottomRight = "BottomRight",
	    Bottom = "Bottom",
	    Center = "Center"
	} enum Execute {
	    onEnable = 0,
	    onUpdate = 1,
	    onAwake = 2
	}
	/**
	 * TODO what if a entity2d is moved to another UI tree from one UI tree.
	 */
	export default class UIAnchor extends Component {
	    /**
	     * 更新运算的时机的枚举值，对应不同的组件生命周期。
	     *
	     * @static
	     * @type {Execute}
	     * @memberof UIAnchor
	     */
	    static Execute: Readonly<typeof Execute>;
	    /**
	     * UIAnchor对齐方式的枚举类型
	     *
	     * @static
	     * @memberof UIAnchor
	     */
	    static Side: Readonly<typeof Side>;
	    readonly entity: Entity2D;
	    readonly priority: number;
	    /**
	     * Side类型，相对于UICanvas的对齐位置
	     *
	     * @type {Side}
	     * @memberof UIAnchor
	     */
	    get side(): Side;
	    set side(val: Side);
	    /**
	     * 默认值为0，水平垂直方向的绝对偏移
	     *
	     * @type {Vector2}
	     * @memberof UIAnchor
	     */
	    get pixelOffset(): Vector2;
	    set pixelOffset(val: Vector2);
	    /**
	     *  默认值Vectotr2.Zero()，相对于组件所在的UICanvas大小，水平垂直方向的相对偏移，每个方向取值范围(0-1)
	     *
	     * @type {Vector2}
	     * @memberof UIAnchor
	     */
	    get relativeOffset(): Vector2;
	    set relativeOffset(val: Vector2);
	    /**
	     * Execute类型，组件属性或目标关联属性发生变化后，具体进行更新运算的时机。
	     *
	     * @type {Execute}
	     * @memberof UIAnchor
	     */
	    get execute(): Execute;
	    set execute(val: Execute);
	    /**
	     * 立即重新进行一次UIAnchor的对齐
	     *
	     * @memberof UIAnchor
	     */
	    updateUIAnchor(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIButton' {
	
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	import { TouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Touchable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import UISprite from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UISprite';
	export enum ButtonState {
	    Normal = 0,
	    Pressed = 1,
	    Disable = 2
	}
	/**
	 * 按钮组件。
	 * @export
	 * @class UIButton
	 * @extends {Touchable}
	 */
	export default class UIButton extends Touchable {
	    /**
	     * 按钮状态类型枚举值
	     *
	     * @static
	     * @type {ButtonState}
	     * @memberof UIButton
	     */
	    static State: typeof ButtonState;
	    readonly priority: number;
	    /**
	     * 当前按钮的状态
	     *
	     * @type {ButtonState}
	     * @memberof UIButton
	     */
	    set state(state: ButtonState);
	    get state(): ButtonState;
	    /**
	     * 普通状态下按钮图像混合的颜色。
	     * @type {Color}
	     * @memberof UIButton
	     */
	    set normalColor(color: Color);
	    get normalColor(): Color;
	    /**
	     * 普通状态下按钮的图片。
	     * @type {Nullable<SpriteFrame>}
	     * @memberof UIButton
	     */
	    set normalSprite(spriteFrame: Nullable<SpriteFrame>);
	    get normalSprite(): Nullable<SpriteFrame>;
	    /**
	     * 点击状态下按钮的图片。
	     * @type {Nullable<SpriteFrame>}
	     * @memberof UIButton
	     */
	    set pressedSprite(pressedSprite: Nullable<SpriteFrame>);
	    get pressedSprite(): Nullable<SpriteFrame>;
	    /**
	     * 点击状态下按钮的图片。
	     * @type {Nullable<SpriteFrame>}
	     * @memberof UIButton
	     */
	    set disabledSprite(disabledSprite: Nullable<SpriteFrame>);
	    get disabledSprite(): Nullable<SpriteFrame>;
	    /**
	     * 不可用状态下按钮的图像混合的颜色。
	     * @type {Color}
	     * @memberof UIButton
	     */
	    set pressedColor(val: Color);
	    get pressedColor(): Color;
	    /**
	     * 不可用状态下按钮的图像混合的颜色。
	     * @readonly
	     * @type {Color}
	     * @memberof UIButton
	     */
	    set disabledColor(val: Color);
	    get disabledColor(): Color;
	    /**
	     * 状态转移动画效果时长。
	     * @type {number}
	     * @memberof UIButton
	     */
	    transition: number;
	    /**
	     * 是否将UIButton设置为不可用
	     *
	     * @type {boolean}
	     * @memberof UIButton
	     */
	    set disable(disable: boolean);
	    get disable(): boolean;
	    /**
	     * disable状态下是否将按钮渲染为灰阶
	     *
	     * @type {boolean}
	     * @memberof UIButton
	     */
	    set grayScaleOnDisable(grayScaleOnDisable: boolean);
	    get grayScaleOnDisable(): boolean;
	    /**
	     * disable状态下是否将按钮渲染为灰阶
	     *
	     * @type {boolean}
	     * @memberof UIButton
	     */
	    set useClickOnDisable(clickOnDisable: boolean);
	    get useClickOnDisable(): boolean;
	    constructor(entity: Entity2D);
	    /**
	     * 设置按钮状态。
	     * @param {ButtonState} state 目标状态。
	     * @param {boolean} [animation=true] 是否使用动画效果。
	     * @param {boolean} [forceUpdate=false] 是否强制更新。
	     * @returns {void}
	     * @memberof UIButton
	     */
	    setState(state: ButtonState, animation?: boolean, forceUpdate?: boolean): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIGrid' {
	import { BoundsChangeEventType, ChildChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	export enum Arrangement {
	    Horizontal = 0,
	    Vertical = 1
	}
	export default class UIGrid extends Component {
	    /**
	     * 列表方向枚举值
	     *
	     * @static
	     * @memberof UIGrid
	     */
	    static Arrangement: Readonly<typeof Arrangement>;
	    readonly entity: Entity2D;
	    readonly priority: number;
	    /**
	     * Arrangement类型，列表布局方向。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get arrangement(): Arrangement;
	    set arrangement(val: Arrangement);
	    /**
	     * 默认值为false，是否根据size进行布局，设定后cloumn将无用
	     *
	     * @type {boolean}
	     * @memberof UIGrid
	     */
	    get layoutBySize(): boolean;
	    set layoutBySize(val: boolean);
	    /**
	     * 默认值为false，是否开启动态尺寸布局，取每个行列取最大的元素，作为当前行列cell的大小进行布局。
	     *
	     * @type {boolean}
	     * @memberof UIGrid
	     */
	    get autoSize(): boolean;
	    set autoSize(val: boolean);
	    /**
	     * 固定尺寸布局使用，每个cell的宽度。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get cellWidth(): number;
	    set cellWidth(val: number);
	    /**
	     * 固定尺寸布局使用，每个cell的高度。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get cellHeight(): number;
	    set cellHeight(val: number);
	    /**
	     * 当前布局方向下的列数，若为0，则以子元素数量作为列数。固定尺寸布局下，列垂直于当前主方向；动态尺寸布局，列平行于的主方向。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get columns(): number;
	    set columns(val: number);
	    /**
	     * 动态尺寸布局使用，默认值为0.5，代表居中，取值范围(0-1)，决定每列所有单元格内部的水平方向对齐规则。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get cellAlignmentX(): number;
	    set cellAlignmentX(val: number);
	    /**
	     * 动态尺寸布局使用，默认值为0.5，代表居中，取值范围(0-1)，决定每行所有单元格内部的垂直方向对齐规则。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get cellAlignmentY(): number;
	    set cellAlignmentY(val: number);
	    /**
	     * 动态尺寸布局使用，默认值为0，每个cell之间的距离水平方向的距离。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get paddingX(): number;
	    set paddingX(val: number);
	    /**
	     * 动态尺寸布局使用，默认值为0，每个cell之间的距离垂直方向的距离。
	     *
	     * @type {number}
	     * @memberof UIGrid
	     */
	    get paddingY(): number;
	    set paddingY(val: number);
	    /**
	     * 立即重新进行一次UIGrid的布局
	     *
	     * @memberof UIGrid
	     */
	    resetContext(): void;
	    /**
	     * 更新置脏（默认将在Update阶段更新）。
	     *
	     * @memberof UIGrid
	     */
	    setResetFlag(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject' {
	/**
	 * KObject.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午5:03:37
	 */
	import { IHandle } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export function getId(type: string): number;
	export default class KObject implements IHandle {
	    static CLASS_NAME: string;
	    name: string;
	    id: number;
	    data: ArrayBuffer;
	    get className(): string;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/math' {
	export function arcTanAngle(x: number, y: number): number;
	export function isPowOf2(num: number): boolean;
	export function nearEqual(a: number, b: number): boolean;
	export function mathClamp(val: number, min: number, max: number): number;
	export const mathHelper: {
	    arcTanAngle: typeof arcTanAngle;
	    isPowOf2: typeof isPowOf2;
	    nearEqual: typeof nearEqual;
	    mathClamp: typeof mathClamp;
	}; type F32A = Float32Array; type F32A_W = Float32Array;
	export const v2Helper: {
	    equal: (a: F32A, ao: number, b: F32A, bo: number) => boolean;
	    add: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    sub: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    length: (a: F32A, ao: number) => number;
	    normalize: (a: F32A, ao: number, dst: F32A_W, dsto: number) => void;
	    scale: (a: F32A, ao: number, f: number, dst: F32A_W, dsto: number) => void;
	    lerp: (a: F32A, ao: number, b: F32A, bo: number, f: number, dst: F32A_W, dsto: number) => void;
	    dot: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    isZero: (a: F32A, ao: number) => boolean;
	    getAngle: (a: F32A, ao: number) => number;
	    distance: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    copy(v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	};
	export const v3Helper: {
	    equal: (a: F32A, ao: number, b: F32A, bo: number) => boolean;
	    add: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    sub: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    mul: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    length: (a: F32A, ao: number) => number;
	    normalize: (a: F32A, ao: number, dst: F32A_W, dsto: number) => void;
	    scale: (a: F32A, ao: number, f: number, dst: F32A_W, dsto: number) => void;
	    lerp: (a: F32A, ao: number, b: F32A, bo: number, f: number, dst: F32A_W, dsto: number) => void;
	    dot: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    isZero: (a: F32A, ao: number) => boolean;
	    cross: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    distance: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    angleTo: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    copy(v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	};
	export const v4Helper: {
	    equal: (a: F32A, ao: number, b: F32A, bo: number) => boolean;
	    add: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    sub: (a: F32A, ao: number, b: F32A, bo: number, dst: F32A_W, dsto: number) => void;
	    scale: (a: F32A, ao: number, f: number, dst: F32A_W, dsto: number) => void;
	    lerp: (a: F32A, ao: number, b: F32A, bo: number, f: number, dst: F32A_W, dsto: number) => void;
	    dot: (a: F32A, ao: number, b: F32A, bo: number) => number;
	    isZero: (a: F32A, ao: number) => boolean;
	    copy(v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    length: (a: F32A, ao: number) => number;
	};
	export const quatHelper: {
	    multiply: (l: F32A, lo: number, r: F32A, ro: number, dst: F32A_W, dsto: number) => void;
	    invert: (a: F32A, ao: number, dst: F32A_W, dsto: number) => void;
	    toMatrix4: (quat: F32A, quato: number, dst: F32A_W, dsto: number) => void;
	    fromMatrix4: (m: F32A, mo: number, dst: F32A_W, dsto: number) => void;
	    fromEulerAngles: (v: F32A, vo: number, dst: F32A_W, dsto: number) => void;
	    fromYawRawPitch: (yaw: number, pitch: number, roll: number, dst: F32A_W, dsto: number) => void;
	    toEulerAngles: (quat: F32A_W, quato: number, dst: F32A_W, dsto: number) => void;
	    toYawRawPitch: (quat: F32A, quato: number, dst: F32A_W, dsto: number) => void;
	    slerp: (l: F32A, lo: number, r: F32A, ro: number, t: number, dst: F32A_W, dsto: number) => Float32Array;
	    transformDirection: (quat: F32A, quato: number, v: F32A, vo: number, dst: F32A_W, dsto: number) => void;
	    normalize: (q: F32A, qo: number, dst: F32A_W, dsto: number) => void;
	};
	export const m2Helper: {
	    transpose(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	};
	export const m3Helper: {
	    transpose(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    translate: (m: F32A, mo: number, tx: number, ty: number, dst: F32A_W, dsto: number) => void;
	    scale: (m: F32A, mo: number, sx: number, sy: number, dst: F32A_W, dsto: number) => void;
	    rotate: (m: F32A, mo: number, rz: number, dst: F32A_W, dsto: number) => void;
	    inverse(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    multiply: (mA: F32A, mAo: number, mB: F32A, mBo: number, dst: F32A_W, dsto: number) => void;
	    transformPoint(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    decomposeScale(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    copy(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	};
	export const m4Helper: {
	    lookAt: (at: F32A, atOffset: number, eye: F32A, eyeOffset: number, up: F32A, upOffset: number, dst: F32A_W, dsto: number) => void;
	    perspective: (fieldOfViewRadians: number, aspect: number, near: number, far: number, dst: F32A_W, dsto: number) => void;
	    orthographic: (left: number, right: number, bottom: number, top: number, near: number, far: number, dst: F32A_W, dsto: number) => void;
	    xRotation(rad: number, dst: F32A_W, dsto: number): void;
	    yRotation(rad: number, dst: F32A_W, dsto: number): void;
	    zRotation(rad: number, dst: F32A_W, dsto: number): void;
	    axisRotation(axis: F32A, axiso: number, angleInRadians: number, dst: F32A_W, dsto: number): Float32Array;
	    composeTRS: (trans: F32A, transo: number, rot: F32A, roto: number, scale: F32A, scaleo: number, dst: F32A_W, dsto: number) => void;
	    composeTQS: (trans: F32A, transo: number, quat: F32A, quato: number, scale: F32A, scaleo: number, dst: F32A_W, dsto: number) => void;
	    translate: (m: F32A, mo: number, tx: number, ty: number, tz: number, dst: F32A_W, dsto: number) => void;
	    scale: (m: F32A, mo: number, sx: number, sy: number, sz: number, dst: F32A_W, dsto: number) => void;
	    xRotate: (m: F32A, mo: number, rx: number, dst: F32A_W, dsto: number) => void;
	    yRotate: (m: F32A, mo: number, ry: number, dst: F32A_W, dsto: number) => void;
	    zRotate: (m: F32A, mo: number, rz: number, dst: F32A_W, dsto: number) => void;
	    axisRotate: (m: F32A, mo: number, axis: F32A, axiso: number, angleInRadians: number, dst: F32A_W, dsto: number) => void;
	    multiply: (mA: F32A, mAo: number, mB: F32A, mBo: number, dst: F32A_W, dsto: number) => void;
	    transformVector(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    transformDirection(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    transformPoint(m: F32A, mo: number, v: F32A, vo: number, dst: F32A_W, dsto: number): void;
	    decomposeTransRotMatScale(m: F32A, mo: number, trans: F32A_W, transo: number, rot: F32A_W, roto: number, scale: F32A_W, scaleo: number): boolean;
	    decomposeTransQuatScale(m: F32A, mo: number, trans: F32A_W, transo: number, quat: F32A_W, quato: number, scale: F32A_W, scaleo: number): boolean;
	    inverse(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    transpose(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    composeRST3toRST4(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	    copy(m: F32A, mo: number, dst: F32A_W, dsto: number): void;
	};
	export function seedrandom(seed?: number): number;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/constants' {
	 const _default: {
	    ACTIVE_ATTRIBUTES: number;
	    ACTIVE_ATTRIBUTE_MAX_LENGTH: number;
	    ACTIVE_TEXTURE: number;
	    ACTIVE_UNIFORMS: number;
	    ACTIVE_UNIFORM_MAX_LENGTH: number;
	    ALIASED_LINE_WIDTH_RANGE: number;
	    ALIASED_POINT_SIZE_RANGE: number;
	    ALPHA: number;
	    ALPHA_BITS: number;
	    ALWAYS: number;
	    ARRAY_BUFFER: number;
	    ARRAY_BUFFER_BINDING: number;
	    ATTACHED_SHADERS: number;
	    BACK: number;
	    BLEND: number;
	    BLEND_COLOR: number;
	    BLEND_DST_ALPHA: number;
	    BLEND_DST_RGB: number;
	    BLEND_EQUATION: number;
	    BLEND_EQUATION_ALPHA: number;
	    BLEND_EQUATION_RGB: number;
	    BLEND_SRC_ALPHA: number;
	    BLEND_SRC_RGB: number;
	    BLUE_BITS: number;
	    BOOL: number;
	    BOOL_VEC2: number;
	    BOOL_VEC3: number;
	    BOOL_VEC4: number;
	    BROWSER_DEFAULT_WEBGL: number;
	    BUFFER_SIZE: number;
	    BUFFER_USAGE: number;
	    BYTE: number;
	    CCW: number;
	    CLAMP_TO_EDGE: number;
	    COLOR_ATTACHMENT0: number;
	    COLOR_BUFFER_BIT: number;
	    COLOR_CLEAR_VALUE: number;
	    COLOR_WRITEMASK: number;
	    COMPILE_STATUS: number;
	    COMPRESSED_TEXTURE_FORMATS: number;
	    CONSTANT_ALPHA: number;
	    CONSTANT_COLOR: number;
	    CONTEXT_LOST_WEBGL: number;
	    CULL_FACE: number;
	    CULL_FACE_MODE: number;
	    CURRENT_PROGRAM: number;
	    CURRENT_VERTEX_ATTRIB: number;
	    CW: number;
	    DECR: number;
	    DECR_WRAP: number;
	    DELETE_STATUS: number;
	    DEPTH_ATTACHMENT: number;
	    DEPTH_BITS: number;
	    DEPTH_BUFFER_BIT: number;
	    DEPTH_CLEAR_VALUE: number;
	    DEPTH_COMPONENT: number;
	    DEPTH_COMPONENT16: number;
	    DEPTH_FUNC: number;
	    DEPTH_RANGE: number;
	    DEPTH_STENCIL: number;
	    DEPTH_STENCIL_ATTACHMENT: number;
	    DEPTH_TEST: number;
	    DEPTH_WRITEMASK: number;
	    DITHER: number;
	    DONT_CARE: number;
	    DST_ALPHA: number;
	    DST_COLOR: number;
	    DYNAMIC_DRAW: number;
	    ELEMENT_ARRAY_BUFFER: number;
	    ELEMENT_ARRAY_BUFFER_BINDING: number;
	    EQUAL: number;
	    FASTEST: number;
	    FLOAT: number;
	    FLOAT_MAT2: number;
	    FLOAT_MAT3: number;
	    FLOAT_MAT4: number;
	    FLOAT_VEC2: number;
	    FLOAT_VEC3: number;
	    FLOAT_VEC4: number;
	    FRAGMENT_SHADER: number;
	    FRAMEBUFFER: number;
	    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;
	    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;
	    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;
	    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;
	    FRAMEBUFFER_BINDING: number;
	    FRAMEBUFFER_COMPLETE: number;
	    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;
	    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;
	    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;
	    FRAMEBUFFER_UNSUPPORTED: number;
	    FRONT: number;
	    FRONT_AND_BACK: number;
	    FRONT_FACE: number;
	    FUNC_ADD: number;
	    FUNC_REVERSE_SUBTRACT: number;
	    FUNC_SUBTRACT: number;
	    GENERATE_MIPMAP_HINT: number;
	    GEQUAL: number;
	    GREATER: number;
	    GREEN_BITS: number;
	    HIGH_FLOAT: number;
	    HIGH_INT: number;
	    INCR: number;
	    INCR_WRAP: number;
	    INFO_LOG_LENGTH: number;
	    INT: number;
	    INT_VEC2: number;
	    INT_VEC3: number;
	    INT_VEC4: number;
	    INVALID_ENUM: number;
	    INVALID_FRAMEBUFFER_OPERATION: number;
	    INVALID_OPERATION: number;
	    INVALID_VALUE: number;
	    INVERT: number;
	    KEEP: number;
	    LEQUAL: number;
	    LESS: number;
	    LINEAR: number;
	    LINEAR_MIPMAP_LINEAR: number;
	    LINEAR_MIPMAP_NEAREST: number;
	    LINES: number;
	    LINE_LOOP: number;
	    LINE_STRIP: number;
	    LINE_WIDTH: number;
	    LINK_STATUS: number;
	    LOW_FLOAT: number;
	    LOW_INT: number;
	    LUMINANCE: number;
	    LUMINANCE_ALPHA: number;
	    MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
	    MAX_CUBE_MAP_TEXTURE_SIZE: number;
	    MAX_FRAGMENT_UNIFORM_VECTORS: number;
	    MAX_RENDERBUFFER_SIZE: number;
	    MAX_TEXTURE_IMAGE_UNITS: number;
	    MAX_TEXTURE_SIZE: number;
	    MAX_VARYING_VECTORS: number;
	    MAX_VERTEX_ATTRIBS: number;
	    MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
	    MAX_VERTEX_UNIFORM_VECTORS: number;
	    MAX_VIEWPORT_DIMS: number;
	    MEDIUM_FLOAT: number;
	    MEDIUM_INT: number;
	    MIRRORED_REPEAT: number;
	    NEAREST: number;
	    NEAREST_MIPMAP_LINEAR: number;
	    NEAREST_MIPMAP_NEAREST: number;
	    NEVER: number;
	    NICEST: number;
	    NONE: number;
	    NOTEQUAL: number;
	    NO_ERROR: number;
	    NUM_COMPRESSED_TEXTURE_FORMATS: number;
	    ONE: number;
	    ONE_MINUS_CONSTANT_ALPHA: number;
	    ONE_MINUS_CONSTANT_COLOR: number;
	    ONE_MINUS_DST_ALPHA: number;
	    ONE_MINUS_DST_COLOR: number;
	    ONE_MINUS_SRC_ALPHA: number;
	    ONE_MINUS_SRC_COLOR: number;
	    OUT_OF_MEMORY: number;
	    PACK_ALIGNMENT: number;
	    POINTS: number;
	    POLYGON_OFFSET_FACTOR: number;
	    POLYGON_OFFSET_FILL: number;
	    POLYGON_OFFSET_UNITS: number;
	    RED_BITS: number;
	    RENDERBUFFER: number;
	    RENDERBUFFER_ALPHA_SIZE: number;
	    RENDERBUFFER_BINDING: number;
	    RENDERBUFFER_BLUE_SIZE: number;
	    RENDERBUFFER_DEPTH_SIZE: number;
	    RENDERBUFFER_GREEN_SIZE: number;
	    RENDERBUFFER_HEIGHT: number;
	    RENDERBUFFER_INTERNAL_FORMAT: number;
	    RENDERBUFFER_RED_SIZE: number;
	    RENDERBUFFER_STENCIL_SIZE: number;
	    RENDERBUFFER_WIDTH: number;
	    RENDERER: number;
	    REPEAT: number;
	    REPLACE: number;
	    RGB: number;
	    RGB5_A1: number;
	    RGB565: number;
	    RGBA: number;
	    RGBA4: number;
	    SAMPLER_2D: number;
	    SAMPLER_CUBE: number;
	    SAMPLES: number;
	    SAMPLE_ALPHA_TO_COVERAGE: number;
	    SAMPLE_BUFFERS: number;
	    SAMPLE_COVERAGE: number;
	    SAMPLE_COVERAGE_INVERT: number;
	    SAMPLE_COVERAGE_VALUE: number;
	    SCISSOR_BOX: number;
	    SCISSOR_TEST: number;
	    SHADER_COMPILER: number;
	    SHADER_SOURCE_LENGTH: number;
	    SHADER_TYPE: number;
	    SHADING_LANGUAGE_VERSION: number;
	    SHORT: number;
	    SRC_ALPHA: number;
	    SRC_ALPHA_SATURATE: number;
	    SRC_COLOR: number;
	    STATIC_DRAW: number;
	    STENCIL_ATTACHMENT: number;
	    STENCIL_BACK_FAIL: number;
	    STENCIL_BACK_FUNC: number;
	    STENCIL_BACK_PASS_DEPTH_FAIL: number;
	    STENCIL_BACK_PASS_DEPTH_PASS: number;
	    STENCIL_BACK_REF: number;
	    STENCIL_BACK_VALUE_MASK: number;
	    STENCIL_BACK_WRITEMASK: number;
	    STENCIL_BITS: number;
	    STENCIL_BUFFER_BIT: number;
	    STENCIL_CLEAR_VALUE: number;
	    STENCIL_FAIL: number;
	    STENCIL_FUNC: number;
	    STENCIL_INDEX: number;
	    STENCIL_INDEX8: number;
	    STENCIL_PASS_DEPTH_FAIL: number;
	    STENCIL_PASS_DEPTH_PASS: number;
	    STENCIL_REF: number;
	    STENCIL_TEST: number;
	    STENCIL_VALUE_MASK: number;
	    STENCIL_WRITEMASK: number;
	    STREAM_DRAW: number;
	    SUBPIXEL_BITS: number;
	    TEXTURE: number;
	    TEXTURE0: number;
	    TEXTURE1: number;
	    TEXTURE2: number;
	    TEXTURE3: number;
	    TEXTURE4: number;
	    TEXTURE5: number;
	    TEXTURE6: number;
	    TEXTURE7: number;
	    TEXTURE8: number;
	    TEXTURE9: number;
	    TEXTURE10: number;
	    TEXTURE11: number;
	    TEXTURE12: number;
	    TEXTURE13: number;
	    TEXTURE14: number;
	    TEXTURE15: number;
	    TEXTURE16: number;
	    TEXTURE17: number;
	    TEXTURE18: number;
	    TEXTURE19: number;
	    TEXTURE20: number;
	    TEXTURE21: number;
	    TEXTURE22: number;
	    TEXTURE23: number;
	    TEXTURE24: number;
	    TEXTURE25: number;
	    TEXTURE26: number;
	    TEXTURE27: number;
	    TEXTURE28: number;
	    TEXTURE29: number;
	    TEXTURE30: number;
	    TEXTURE31: number;
	    TEXTURE_2D: number;
	    TEXTURE_BINDING_2D: number;
	    TEXTURE_BINDING_CUBE_MAP: number;
	    TEXTURE_CUBE_MAP: number;
	    TEXTURE_CUBE_MAP_NEGATIVE_X: number;
	    TEXTURE_CUBE_MAP_NEGATIVE_Y: number;
	    TEXTURE_CUBE_MAP_NEGATIVE_Z: number;
	    TEXTURE_CUBE_MAP_POSITIVE_X: number;
	    TEXTURE_CUBE_MAP_POSITIVE_Y: number;
	    TEXTURE_CUBE_MAP_POSITIVE_Z: number;
	    TEXTURE_MAG_FILTER: number;
	    TEXTURE_MIN_FILTER: number;
	    TEXTURE_WRAP_S: number;
	    TEXTURE_WRAP_T: number;
	    TRIANGLES: number;
	    TRIANGLE_FAN: number;
	    TRIANGLE_STRIP: number;
	    UNPACK_ALIGNMENT: number;
	    UNPACK_COLORSPACE_CONVERSION_WEBGL: number;
	    UNPACK_FLIP_Y_WEBGL: number;
	    UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;
	    UNSIGNED_BYTE: number;
	    UNSIGNED_INT: number;
	    UNSIGNED_SHORT: number;
	    UNSIGNED_SHORT_4_4_4_4: number;
	    UNSIGNED_SHORT_5_5_5_1: number;
	    UNSIGNED_SHORT_5_6_5: number;
	    VALIDATE_STATUS: number;
	    VENDOR: number;
	    VERSION: number;
	    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;
	    VERTEX_ATTRIB_ARRAY_ENABLED: number;
	    VERTEX_ATTRIB_ARRAY_NORMALIZED: number;
	    VERTEX_ATTRIB_ARRAY_POINTER: number;
	    VERTEX_ATTRIB_ARRAY_SIZE: number;
	    VERTEX_ATTRIB_ARRAY_STRIDE: number;
	    VERTEX_ATTRIB_ARRAY_TYPE: number;
	    VERTEX_SHADER: number;
	    VIEWPORT: number;
	    ZERO: number;
	    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: number;
	    UNMASKED_VENDOR_WEBGL: number;
	    UNMASKED_RENDERER_WEBGL: number;
	    MAX_TEXTURE_MAX_ANISOTROPY_EXT: number;
	    TEXTURE_MAX_ANISOTROPY_EXT: number;
	    COMPRESSED_RGB_S3TC_DXT1_EXT: number;
	    COMPRESSED_RGBA_S3TC_DXT1_EXT: number;
	    COMPRESSED_RGBA_S3TC_DXT3_EXT: number;
	    COMPRESSED_RGBA_S3TC_DXT5_EXT: number;
	    COMPRESSED_R11_EAC: number;
	    COMPRESSED_SIGNED_R11_EAC: number;
	    COMPRESSED_RG11_EAC: number;
	    COMPRESSED_SIGNED_RG11_EAC: number;
	    COMPRESSED_RGB8_ETC2: number;
	    COMPRESSED_RGBA8_ETC2_EAC: number;
	    COMPRESSED_SRGB8_ETC2: number;
	    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: number;
	    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: number;
	    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: number;
	    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: number;
	    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: number;
	    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: number;
	    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: number;
	    COMPRESSED_RGB_ETC1_WEBGL: number;
	    COMPRESSED_RGB_ATC_WEBGL: number;
	    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: number;
	    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: number;
	    UNSIGNED_INT_24_8_WEBGL: number;
	    HALF_FLOAT_OES: number;
	    RGBA32F_EXT: number;
	    RGB32F_EXT: number;
	    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: number;
	    UNSIGNED_NORMALIZED_EXT: number;
	    MIN_EXT: number;
	    MAX_EXT: number;
	    SRGB_EXT: number;
	    SRGB_ALPHA_EXT: number;
	    SRGB8_ALPHA8_EXT: number;
	    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: number;
	    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;
	    COLOR_ATTACHMENT0_WEBGL: number;
	    COLOR_ATTACHMENT1_WEBGL: number;
	    COLOR_ATTACHMENT2_WEBGL: number;
	    COLOR_ATTACHMENT3_WEBGL: number;
	    COLOR_ATTACHMENT4_WEBGL: number;
	    COLOR_ATTACHMENT5_WEBGL: number;
	    COLOR_ATTACHMENT6_WEBGL: number;
	    COLOR_ATTACHMENT7_WEBGL: number;
	    COLOR_ATTACHMENT8_WEBGL: number;
	    COLOR_ATTACHMENT9_WEBGL: number;
	    COLOR_ATTACHMENT10_WEBGL: number;
	    COLOR_ATTACHMENT11_WEBGL: number;
	    COLOR_ATTACHMENT12_WEBGL: number;
	    COLOR_ATTACHMENT13_WEBGL: number;
	    COLOR_ATTACHMENT14_WEBGL: number;
	    COLOR_ATTACHMENT15_WEBGL: number;
	    DRAW_BUFFER0_WEBGL: number;
	    DRAW_BUFFER1_WEBGL: number;
	    DRAW_BUFFER2_WEBGL: number;
	    DRAW_BUFFER3_WEBGL: number;
	    DRAW_BUFFER4_WEBGL: number;
	    DRAW_BUFFER5_WEBGL: number;
	    DRAW_BUFFER6_WEBGL: number;
	    DRAW_BUFFER7_WEBGL: number;
	    DRAW_BUFFER8_WEBGL: number;
	    DRAW_BUFFER9_WEBGL: number;
	    DRAW_BUFFER10_WEBGL: number;
	    DRAW_BUFFER11_WEBGL: number;
	    DRAW_BUFFER12_WEBGL: number;
	    DRAW_BUFFER13_WEBGL: number;
	    DRAW_BUFFER14_WEBGL: number;
	    DRAW_BUFFER15_WEBGL: number;
	    MAX_COLOR_ATTACHMENTS_WEBGL: number;
	    MAX_DRAW_BUFFERS_WEBGL: number;
	    VERTEX_ARRAY_BINDING_OES: number;
	    QUERY_COUNTER_BITS_EXT: number;
	    CURRENT_QUERY_EXT: number;
	    QUERY_RESULT_EXT: number;
	    QUERY_RESULT_AVAILABLE_EXT: number;
	    TIME_ELAPSED_EXT: number;
	    TIMESTAMP_EXT: number;
	    GPU_DISJOINT_EXT: number;
	};
	/**
	 * constants.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/18/2020, 7:43:44 PM
	*/
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexBuffer' {
	/**
	 * IndexBuffer.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午7:59:50
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class IndexBuffer extends KObject {
	    static CLASS_NAME: string;
	    glBuffer: WebGLBuffer;
	    size: number;
	    type: GLenum;
	    constructor(buffer?: ArrayBuffer | ArrayBufferView, size?: number,is32bits?: boolean);
	    update(buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	    bind(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexData' {
	/**
	 * IndexData.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午8:00:49
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import IndexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexBuffer';
	export interface IBatchInfo {
	    indexOffset: number;
	    vertexOffset: number;
	    drawIndex: number;
	    drawCount: number;
	}
	export default class IndexData extends KObject {
	    size: number;
	    static CLASS_NAME: string;
	    static get BUFFER(): IndexBuffer;
	    isIndexData: boolean;
	    dataView: Uint16Array;
	    static IS(obj: KObject): obj is IndexData;
	    constructor(size: number);
	    batch(batchInfo: IBatchInfo, numIndices: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/logger' {
	 const logger: {
	    info(...args: any): void;
	    warn(...args: any): void;
	    error(...args: any): void;
	};
	export default logger;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Image' {
	/**
	 Image.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/23/2020, 7:57:32 PM
	 */
	import { IImage } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export default class Image implements IImage {
	    static IS(obj: any): obj is Image;
	    premultiplyAlpha: boolean;
	    src: string;
	    onerror: (error: Error) => void;
	    onload: () => void;
	    width: number;
	    height: number;
	    constructor();
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Texture' {
	/**
	 * Texture.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午8:28:39
	 */
	import { ETextureFormat, ETextureType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import Image from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Image'; type TBufferSource = ArrayBuffer | ArrayBufferView | Image;
	export default class Texture extends KObject {
	    type: ETextureType;
	    width: number;
	    height: number;
	    slices: number;
	    mips: number;
	    format: ETextureFormat;
	    static CLASS_NAME: string;
	    glTexture: WebGLTexture;
	    frameBuffer: WebGLFramebuffer;
	    renderBuffer: WebGLRenderbuffer;
	    dynamicCanvas?: HTMLCanvasElement;
	    get wrapU(): GLenum;
	    get wrapV(): GLenum;
	    get wrapW(): GLenum;
	    get magFilter(): GLenum;
	    get minFilter(): GLenum;
	    get target(): number;
	    get anisoLevel(): number;
	    get sampleCount(): number;
	    get generateMipmaps(): boolean;
	    get isRenderTarget(): boolean;
	    get isWriteOnly(): boolean;
	    get isMSAA(): boolean;
	    get isMSAA2(): boolean;
	    get isMSAA4(): boolean;
	    constructor(type: ETextureType, width: number, height: number, slices: number, mips: number, format: ETextureFormat,flags: number, source?: TBufferSource[], offsets?: Uint32Array);
	    update(level: number, slice: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, buffer?: ArrayBuffer | ArrayBufferView | Image | HTMLCanvasElement | ImageData): void;
	    updateTextureFlags(flags: number): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlockDescriptor' {
	/**
	 * UniformBlockDescriptor.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午5:34:13
	 */
	import { EUniformType, IUniformDescriptorOptions } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class UniformBlockDescriptor extends KObject {
	    static CLASS_NAME: string;
	    get size(): number;
	    get layout(): {
	        [key: string]: [EUniformType, number, number, number, EUniformType, boolean];
	    };
	    get pairs(): {
	        name: string;
	        type: EUniformType;
	        num?: number | undefined;
	        needTranspose?: boolean | undefined;
	    }[];
	    get textureKeys(): string[];
	    constructor(options: IUniformDescriptorOptions);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Font' {
	/**
	 * Font.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/22/2020, 8:56:21 PM
	 */
	import { IFontSetting, IGlyphInfo } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Texture';
	export class FontPacker {
	    static textures: {
	        [id: number]: Texture;
	    };
	    static allocate(charCode: number, font: string, size: number): IGlyphInfo;
	}
	export function loadTTFFont(url: string, callback: (font: string) => void): void;
	export function getGlyphInfo(fontSetting: IFontSetting, charCode: number): IGlyphInfo;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect' {
	/**
	 * Effect.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午4:58:18
	*/
	import { EBlendFactor, EBlendEquation, ECullMode, ECompareFunc, EPrimitiveType, EStencilOp } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import Shader from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Shader';
	export default class Effect extends KObject {
	    name: string;
	    passes: {
	        lightMode: string;
	        variants: {
	            [key: number]: number;
	        };
	        macros: {
	            [key: string]: number;
	        };
	    }[];
	    shaders: string[];
	    variants: number[][];
	    static CLASS_NAME: string;
	    get passCount(): number;
	    constructor(name: string, passCount: number, passes: {
	        lightMode: string;
	        variants: {
	            [key: number]: number;
	        };
	        macros: {
	            [key: string]: number;
	        };
	    }[], shaders: string[], variants: number[][]);
	    getMacroKey(pass: number, macros: {
	        [name: string]: string | number | boolean;
	    }): number;
	    warmUp(): void;
	    getShader(pass: number, macroKey: number): Shader;
	    getPasses(lightMode: string): number[];
	    getSupportInstance(lightMode: string): boolean;
	    getLightMode(pass: number): string;
	    getBlendOn(pass: number): boolean;
	    getBlendSrc(pass: number): EBlendFactor;
	    getBlendDst(pass: number): EBlendFactor;
	    getBlendSrcRGB(pass: number): EBlendFactor;
	    getBlendSrcAlpha(pass: number): EBlendFactor;
	    getBlendDstRGB(pass: number): EBlendFactor;
	    getBlendDstAlpha(pass: number): EBlendFactor;
	    getBlendFunc(pass: number): EBlendEquation;
	    getDepthTestOn(pass: number): boolean;
	    getDepthTestComp(pass: number): ECompareFunc;
	    getDepthWrite(pass: number): boolean;
	    getCullFace(pass: number): ECullMode;
	    getCullOn(pass: number): boolean;
	    getPrimitiveType(pass: number): EPrimitiveType;
	    getStencilTestOn(pass: number): boolean;
	    getStencilComp(pass: number): ECompareFunc;
	    getStencilPass(pass: number): EStencilOp;
	    getStencilFail(pass: number): EStencilOp;
	    getStencilZFail(pass: number): EStencilOp;
	    getStencilWriteMask(pass: number): number;
	    getStencilReadMask(pass: number): number;
	    getStencilRef(pass: number): number;
	    getStencil(pass: number): number;
	    getBlendRGBA(pass: number): number;
	    getUseMaterialStates(pass: number): boolean;
	    getUseMaterialStateBlendOn(pass: number): boolean;
	    getUseMaterialStateBlendSrcRGB(pass: number): boolean;
	    getUseMaterialStateBlendSrcAlpha(pass: number): boolean;
	    getUseMaterialStateBlendDstRGB(pass: number): boolean;
	    getUseMaterialStateBlendDstAlpha(pass: number): boolean;
	    getUseMaterialStateBlendFunc(pass: number): boolean;
	    getUseMaterialStateDepthTestOn(pass: number): boolean;
	    getUseMaterialStateDepthTestComp(pass: number): boolean;
	    getUseMaterialStateDepthWrite(pass: number): boolean;
	    getUseMaterialStateCullOn(pass: number): boolean;
	    getUseMaterialStateCullFace(pass: number): boolean;
	    getUseMaterialStatePrimitiveType(pass: number): boolean;
	    getUseMaterialStateStencilTestOn(pass: number): boolean;
	    getUseMaterialStateStencilTestComp(pass: number): boolean;
	    getUseMaterialStateStencilTestPass(pass: number): boolean;
	    getUseMaterialStateStencilTestFail(pass: number): boolean;
	    getUseMaterialStateStencilTestZFail(pass: number): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/RenderPass' {
	/**
	 * RenderPass.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午9:23:39
	 */
	import { IAttachment, IRenderPassDescriptor } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class RenderPass extends KObject {
	    color: IAttachment;
	    depth: IAttachment;
	    stencil: IAttachment;
	    frameBuffer: WebGLFramebuffer;
	    isValid: boolean;
	    constructor(options: IRenderPassDescriptor);
	    bind(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/ShaderMacroManager' {
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect';
	export default class ShaderMacroManager {
	    constructor(macros: {
	        [name: string]: string | number | boolean;
	    });
	    changeMacros(macros: {
	        [name: string]: string | number | boolean;
	    }, reset?: boolean): void;
	    getMacroKey(effect: Effect, pass: number): number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/View' {
	/**
	 * View.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午9:28:58
	 */
	import { IViewAction, IRect, IView } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class View extends KObject {
	    actions: IViewAction;
	    viewport: IRect;
	    scissor: IRect;
	    constructor(options: IView);
	    bind(): void;
	    clear(): void;
	    changeViewportScaleFactor(rect: IRect): void;
	    submit(): void;
	    updateViewRect(rect: IRect): void;
	    updateViewScissor(rect: IRect): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/CullingComponent' {
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class CullingComponent extends KObject {
	    static CLASS_NAME: string;
	    static COMPONENTS: {
	        [id: number]: CullingComponent;
	    };
	    get active(): boolean;
	    get layer(): number;
	    get radius(): number;
	    get node(): import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node').default | undefined;
	    constructor(id: number);
	    getCenter(center: Float32Array): void;
	}
	export function getCullingComponent(id: number): CullingComponent | null;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexLayout' {
	/**
	 * VertexLayout.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午7:39:57
	 */
	import { EVertexFormat, IVertexLayoutOptions } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class VertexLayout extends KObject {
	    static CLASS_NAME: string;
	    get stride(): number;
	    get attributes(): {
	        [name: string]: IVertexLayoutOptions['attributes'][0];
	    };
	    constructor(options: IVertexLayoutOptions);
	    getConfigByName(name: string): {
	        name: string;
	        format: EVertexFormat;
	        offset: number;
	    };
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexBuffer' {
	/**
	 * VeterxBuffer.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午7:55:48
	 */
	import VertexLayout from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexLayout';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import Shader from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Shader';
	import IndexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexBuffer';
	export default class VertexBuffer extends KObject {
	    static CLASS_NAME: string;
	    glBuffer: WebGLBuffer;
	    set hackLayout(value: VertexLayout);
	    get layout(): VertexLayout;
	    get byteLength(): number;
	    constructor(layout: VertexLayout, buffer?: ArrayBuffer | ArrayBufferView, size?: number);
	    update(buffer: ArrayBuffer | ArrayBufferView, offset: number): void;
	    bind(shader: Shader, indexes: IndexBuffer): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexData' {
	/**
	 * VertexData.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午8:04:22
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import { IBatchInfo } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexData';
	import VertexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexBuffer';
	import VertexLayout from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexLayout';
	export default class VertexData extends KObject {
	    size: number;
	    static CLASS_NAME: string;
	    static get BUFFER(): VertexBuffer;
	    isVertexData: boolean;
	    dataView: Float32Array;
	    static IS(obj: KObject): obj is VertexData;
	    get layout(): VertexLayout;
	    constructor(layout: VertexLayout, batchDesc: any, size: number);
	    requireUploadBuffer(): Float32Array;
	    batch(batchInfo: IBatchInfo): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Material' {
	/**
	 * Material.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午5:14:38
	 */
	import { EBlendFactor, EBlendEquation, ECompareFunc, ECullMode, EStencilOp, EPrimitiveType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect';
	export default class Material extends KObject {
	    macros: {
	        [name: string]: string | number | boolean;
	    };
	    static CLASS_NAME: string;
	    get uniforms(): UniformBlock;
	    get effect(): Effect;
	    get renderQueue(): number;
	    get useInstance(): boolean;
	    constructor(macros: {
	        [name: string]: string | number | boolean;
	    });
	    changeMacros(macros: {
	        [name: string]: string | number | boolean;
	    }, reset?: boolean): void;
	    getMacroKey(effect: Effect, pass: number): number;
	    getPasses(lightMode: string): number[];
	    getBlendOn(pass: number): boolean;
	    getBlendSrcRGB(pass: number): EBlendFactor;
	    getBlendSrcAlpha(pass: number): EBlendFactor;
	    getBlendDstRGB(pass: number): EBlendFactor;
	    getBlendDstAlpha(pass: number): EBlendFactor;
	    getBlendFunc(pass: number): EBlendEquation;
	    getDepthTestOn(pass: number): boolean;
	    getDepthTestComp(pass: number): ECompareFunc;
	    getDepthWrite(pass: number): boolean;
	    getCullFace(pass: number): ECullMode;
	    getCullOn(pass: number): boolean;
	    getPrimitiveType(pass: number): EPrimitiveType;
	    getStencilTestOn(pass: number): boolean;
	    getStencilComp(pass: number): ECompareFunc;
	    getStencilPass(pass: number): EStencilOp;
	    getStencilFail(pass: number): EStencilOp;
	    getStencilZFail(pass: number): EStencilOp;
	    getStencilWriteMask(pass: number): number;
	    getStencilReadMask(pass: number): number;
	    getStencilRef(pass: number): number;
	    getStencil(pass: number): number;
	    getBlendRGBA(pass: number): number;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/SubMesh' {
	import IndexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexBuffer';
	import VertexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexBuffer';
	import IndexData, { IBatchInfo } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexData';
	import VertexData from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexData';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Material';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect';
	import CullingComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/CullingComponent';
	import InstanceBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/render/InstanceBuffer'; type MeshRenderComponent = import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/MeshRenderComponent').default;
	export function getBatchInfo(length: number): {
	    indexOffset: number;
	    vertexOffset: number;
	    drawIndex: number;
	    drawCount: number;
	};
	export default class SubMesh {
	    id: number;
	    static Pool: SubMeshPool;
	    static ALLOCATE(): SubMesh;
	    static RELEASE(mesh: SubMesh): void;
	    index: number;
	    set parent(p: MeshRenderComponent);
	    get _feMRC(): any;
	    get indexes(): IndexBuffer | IndexData;
	    get vertexes(): VertexBuffer | VertexData;
	    get startIndex(): number;
	    get numIndices(): number;
	    get uniforms(): UniformBlock;
	    get material(): Material;
	    get sortZ(): number;
	    get renderQueue(): number;
	    get cullingComp(): CullingComponent;
	    constructor(id: number);
	    render(lightMode: string, batchInfo: IBatchInfo): void;
	} class SubMeshPool {
	    constructor(initSize: number,enlargeSize: number);
	    allocate(): SubMesh;
	    release(mesh: SubMesh): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/SkeletonBoneInverseModel' {
	/**
	 * SkeletonBoneInverseModel.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午9:22:55
	*/
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class SkeletonBoneInverseModel extends KObject {
	    get matrixes(): Float32Array;
	    constructor(buffer: ArrayBuffer);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/SkinnedSkeleton' {
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import SkeletonBoneInverseModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/SkeletonBoneInverseModel';
	export default class SkinnedSkeleton extends KObject {
	    boneCount: number;
	    flag: number;
	    static CLASS_NAME: string;
	    static UPDATE_SKINNINGS(skeletons: {
	    }[], size: number): void;
	    get boneInverseModel(): SkeletonBoneInverseModel;
	    get boneOffsetMatrices(): Float32Array;
	    constructor(boneCount: number, flag?: number);
	    update(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/RenderCameraComponent' {
	/**
	 * RenderCameraComponent.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/8 下午5:27:11
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock';
	import View from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/View';
	import Node from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node';
	import MeshRenderComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/MeshRenderComponent';
	export default class RenderCameraComponent extends KObject {
	    node: Node;
	    isUI: boolean;
	    static CLASS_NAME: string;
	    uiWorldMatrix: Float32Array;
	    matVer: number;
	    get f32View(): Float32Array;
	    get view(): View;
	    get targetTransform(): Node;
	    get fov(): number;
	    get aspect(): number;
	    get near(): number;
	    get far(): number;
	    get orthoSize(): number;
	    get depth(): number;
	    get canvasSizeY(): number;
	    constructor(node: Node, isUI?: boolean);
	    preRender(): void;
	    cull(meshRender: MeshRenderComponent): number;
	    bind(): void;
	    clear(): void;
	    submit(): void;
	    updateMatrices(): void;
	    fillUniforms(uniforms: UniformBlock): void;
	    setSharedDirty(): void;
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/MeshRenderComponent' {
	/**
	 * MeshRenderComponent.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/8 下午5:27:28
	*/
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock';
	import { EMeshRenderType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import Node from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node';
	import CullingComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/CullingComponent';
	import SubMesh from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/SubMesh';
	import SkinnedSkeleton from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/SkinnedSkeleton';
	import VertexData from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexData';
	import IndexData from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexData';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect'; type RenderCameraComponent = import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/RenderCameraComponent').default;
	export default class MeshRenderComponent extends KObject {
	    uniformBlock: UniformBlock;
	    attachedNode: Node;
	    cullingComp: CullingComponent;
	    meshRenderType: EMeshRenderType;
	    static CLASS_NAME: string;
	    static TABLE_2D: {
	        [id: number]: MeshRenderComponent;
	    };
	    static TABLE_3D: {
	        [id: number]: MeshRenderComponent;
	    };
	    subMeshes: SubMesh[];
	    sortZ: number;
	    get castShadow(): boolean;
	    set castShadow(value: boolean);
	    get skinSkeleton(): SkinnedSkeleton;
	    get bindTarget(): Node | null;
	    get vertexesData(): {
	    }[];
	    get indexesData(): {
	    }[];
	    constructor(meshCount: number, uniformBlock: UniformBlock, attachedNode: Node, cullingComp: CullingComponent, meshRenderType: EMeshRenderType, macros: {
	        [name: string]: string | number | boolean;
	    });
	    changeMacros(macros: {
	        [name: string]: string | number | boolean;
	    }, reset?: boolean): void;
	    getMacroKey(effect: Effect, pass: number): number;
	    preRender(camera?: RenderCameraComponent): void;
	    setSharedDirty(): void;
	    destroy(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/render/InstanceBuffer' {
	/**
	 * InstanceBuffer.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 5/12/2021, 3:20:31 PM
	 */
	import { EMeshRenderType, EUniformType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import MeshRenderComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/MeshRenderComponent';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect';
	import IndexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexBuffer';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Material';
	import Shader from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Shader';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock';
	import VertexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexBuffer';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class InstanceBuffer extends KObject {
	    static CLASS_NAME: string;
	    get cache(): {
	        parent?: MeshRenderComponent | undefined;
	        material?: Material | undefined;
	        pass?: number | undefined;
	        effect?: Effect | undefined;
	        startIndex?: number | undefined;
	        numIndices?: number | undefined;
	        vertexes?: VertexBuffer | undefined;
	        indexes?: IndexBuffer | undefined;
	        uniforms?: UniformBlock | undefined;
	        uniformHash?: number | undefined;
	    };
	    get isFull(): boolean;
	    get isEmpty(): boolean;
	    get count(): number;
	    constructor(type: EMeshRenderType,info: {
	        uniformKey: string;
	        attributeName: string;
	        type: EUniformType;
	    }[],ignored: string[]);
	    reset(): void;
	    start(pass: number, vertexes: VertexBuffer, indexes: IndexBuffer, effect: Effect, parent: MeshRenderComponent, material: Material, uniforms: UniformBlock, startIndex: number, numIndices: number, hash: number): void;
	    pack(uniforms: UniformBlock): void;
	    getHash(ub: UniformBlock): number;
	    bind(shader: Shader): void;
	    draw(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/render/renderEnv' {
	/**
	 * renderEnv.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 1/19/2021, 3:54:33 PM
	 */
	import { IFeatures, TCompressTexture, EMeshRenderType, EUniformType } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect';
	import RenderPass from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/RenderPass';
	import ShaderMacroManager from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/ShaderMacroManager';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import InstanceBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/render/InstanceBuffer';
	export class RenderEnv extends KObject {
	    static CLASS_NAME: string;
	    supportCompressTextures: TCompressTexture[];
	    features: IFeatures;
	    virtualMacros: {
	        [key: string]: boolean;
	    };
	    virtualMacrosDirty: boolean;
	    internalInstanceBuffers: {
	        [type: number]: InstanceBuffer;
	    };
	    backendType: string;
	    get renderPass(): RenderPass;
	    get uniforms0(): UniformBlock;
	    get uniforms1(): UniformBlock;
	    get renderToScreen(): boolean;
	    get needReset(): number;
	    set needReset(value: number);
	    get width(): number;
	    get height(): number;
	    get useInstance(): boolean;
	    get neverTranspose(): boolean;
	    constructor();
	    init(): void;
	    clearScreen(): void;
	    registerFallbackEffect(lightMode: string, effect: Effect): void;
	    getFallbackEffect(lightMode: string): Effect;
	    changeMacros(macros: {
	        [name: string]: string | number | boolean;
	    }): void;
	    changeVirtualMacros(macros: {
	        [name: string]: boolean;
	    }): void;
	    getMacroKey(effect: Effect, pass: number): number;
	    setInternalInstanceInfo(type: EMeshRenderType, info: {
	        uniformKey: string;
	        attributeName: string;
	        type: EUniformType;
	    }[], ignored: string[]): void;
	} const _default: RenderEnv;
	export default _default;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock' {
	/**
	 * UniformBlock.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午5:34:03
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import Shader from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Shader';
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Texture';
	import UniformBlockDescriptor from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlockDescriptor';
	export default class UniformBlock extends KObject {
	    static CLASS_NAME: string;
	    valid: boolean;
	    isDirty: boolean;
	    get descriptor(): UniformBlockDescriptor;
	    get f32view(): Float32Array;
	    get textures(): {
	        [key: string]: {
	        };
	    };
	    constructor(descriptor: UniformBlockDescriptor);
	    setUniform(key: string, value: ArrayLike<number>): void;
	    getHash(hash: number, key: string): number;
	    use(shader: Shader, onlyTextures?: boolean): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Shader' {
	/**
	 * Shader.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午7:03:27
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class Shader extends KObject {
	    static CLASS_NAME: string;
	    program: WebGLProgram;
	    attributeLocations: string[];
	    uniformsLocations: {
	        [name: string]: WebGLUniformLocation;
	    };
	    uniformsTextureUnits: {
	        [name: string]: number;
	    };
	    bindAttributeLocations: boolean[];
	    constructor(vs: string, fs: string);
	    use(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/render/renderer' {
	/**
	 * renderer.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/16/2020, 3:27:22 PM
	*/
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import IndexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexBuffer';
	import IndexData from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/IndexData';
	import Shader from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Shader';
	import VertexBuffer from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexBuffer';
	import VertexData from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexData';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Material';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Effect';
	import MeshRenderComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/MeshRenderComponent';
	import VertexLayout from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/VertexLayout';
	import UniformBlock from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/UniformBlock';
	export class Renderer extends KObject {
	    static CLASS_NAME: string;
	    etcExt: any;
	    etc1Ext: any;
	    astcExt: WEBGL_compressed_texture_astc;
	    pvrtcExt: any;
	    s3tcExt: WEBGL_compressed_texture_s3tc;
	    depthExt: WEBGL_depth_texture;
	    vaoExt: OES_vertex_array_object;
	    instanceExt: ANGLE_instanced_arrays;
	    uintIndexExt: OES_element_index_uint;
	    srgbExt: EXT_sRGB;
	    textureAnisotropicExt: EXT_texture_filter_anisotropic;
	    textureFloatExt: OES_texture_float;
	    textureHalfExt: OES_texture_half_float;
	    colorBufferFloatExt: WEBGL_color_buffer_float;
	    fragDepthExt: EXT_frag_depth;
	    cache: {
	        material?: Material;
	        effect?: Effect;
	        parent?: MeshRenderComponent;
	        vertexLayout?: VertexLayout;
	        startIndex?: number;
	        colorWriteMask?: number;
	        stencilWriteMask?: number;
	        shader?: Shader;
	        fstencil?: number;
	        rgba?: number;
	        enableDepthWrite?: boolean;
	        enableDepthTest?: boolean;
	        depthTestComp?: number;
	        enableBlend?: boolean;
	        cull?: boolean;
	        cullFace?: number;
	        vertexes?: VertexBuffer | VertexData;
	        indexes?: IndexBuffer | IndexData;
	        perObjBatchUniforms?: UniformBlock;
	        blendSrcRGB?: number;
	        blendSrcAlpha?: number;
	        blendDstRGB?: number;
	        blendDstAlpha?: number;
	        blendFunc?: number;
	        uniforms: {
	            [shaderId: number]: {
	                global?: UniformBlock;
	                global2?: UniformBlock;
	                perObj?: UniformBlock;
	                mat?: UniformBlock;
	            };
	        };
	    };
	    get gl(): WebGLRenderingContext;
	    get width(): number;
	    get height(): number;
	    constructor();
	    getExtension(name: string): any;
	    init(canvas: HTMLCanvasElement): void;
	    addDebugInfo(info: string): void;
	    update(): void;
	    resetCache(): void;
	} const renderer: Renderer;
	export default renderer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/Tools' {
	/**
	 * Tools.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午5:08:00
	 */
	import { EBlendEquation, EBlendFactor, ECompareFunc, ECullMode, EPrimitiveType, EStencilOp, ETextureFormat, ETextureType, EVertexFormat } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export function extractPoolObjectId(id: number, res: [number, number]): void;
	export function getTextureTarget(type: ETextureType, slice: number): number;
	export function getTextureFormatInfo(format: ETextureFormat, isRenderBuffer?: boolean): number[] | null;
	export function getTextureSizeByFormatAndSize(format: ETextureFormat, width: number, height: number): number;
	export function getCompareFunc(func: ECompareFunc): number;
	export function getStencilOp(op: EStencilOp): number;
	export function getBlendFactor(factor: EBlendFactor): number;
	export function getBlendEquation(eq: EBlendEquation): number;
	export function getCullMode(mode: ECullMode): number;
	export function getPrimitiveType(type: EPrimitiveType): number;
	export function getVertexFormatInfo(vertexFormat: EVertexFormat): [number, number, boolean];

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/Pools' {
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject'; class Pool extends KObject {
	    static CLASS_NAME: string;
	    static POOLS: {
	        [typeName: string]: {
	            [id: number]: Pool;
	        };
	    };
	    constructor(size: number);
	    getF32View(objId: number): Float32Array;
	    getU32View(objId: number): Uint32Array;
	    getF32U32Views(objId: number, res: [Float32Array, Uint32Array]): void;
	}
	export function getPool<T extends Pool = Pool>(typeName: string, objId: number): T;
	export class Node2DPool extends Pool {
	    static CLASS_NAME: string;
	    static IS(pool: Pool): pool is Node2DPool;
	    isNode2DPool: boolean;
	}
	export class Node3DPool extends Pool {
	    static CLASS_NAME: string;
	    static IS(pool: Pool): pool is Node3DPool;
	    isNode3DPool: boolean;
	}
	export class CullingComponentPool extends Pool {
	    static CLASS_NAME: string;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node' {
	/**
	 * Node3D.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/8 下午5:23:24
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import { Node2DPool, Node3DPool } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/Pools';
	export default class Node extends KObject {
	    static CLASS_NAME: string;
	    static NODES: {
	        [id: number]: Node;
	    };
	    static CREATE_TREE(length: number, ids: ArrayBuffer, info: ArrayBuffer, calculateWordMatrix: boolean, is3d?: boolean): boolean;
	    active: boolean;
	    isDirty: boolean;
	    parent: Node;
	    children: Node[];
	    get f32view(): Float32Array;
	    get is2D(): boolean;
	    get version(): number;
	    get useQuat(): boolean;
	    set useQuat(value: boolean);
	    constructor(pool: Node2DPool | Node3DPool, id: number);
	    addChild(node: Node): void;
	    addChildAtIndex(node: Node, index: number): void;
	    removeChild(node: Node): void;
	    removeFromParent(): void;
	    disperseSubTree(): void;
	    updateWorldMatrix(): void;
	    dfs<T extends any>(callback: (node: Node, params?: T) => T, defaultParams?: T): void;
	    updateSubTree(force?: boolean): void;
	    bindToBone(bone: Node): void;
	    unBindFromBone(): void;
	    setTRS(x: number, y: number, z: number, sx: number, sy: number, sz: number, rx: number, ry: number, rz: number, qw: number): void;
	    getTRS3D(data: Float32Array, offset: number): void;
	    setTRSFromData(data: Float32Array, offset: number): void;
	    setTRSFromChannelData(data: Float32Array, offset: number): void;
	    getWorldPos(data: Float32Array, offset: number): void;
	    showDebugInfo(): void;
	}
	export function getNodeByID(id: number): Node | undefined;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/ScalableList' {
	/**
	 * ScalableList.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 1/19/2021, 3:34:43 PM
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class ScalableList extends KObject {
	    static CLASS_NAME: string;
	    size: number;
	    get dataView(): Uint32Array;
	    get usedSize(): number;
	    set usedSize(value: number);
	    constructor(initSize: number,onEnlarged: () => void);
	    enlarge(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/OBB' {
	export default class OBB {
	    intersectSphere(center: Float32Array, radius: number): boolean;
	    setValues(center: Float32Array, forward: Float32Array, w: number, h: number, d: number): void;
	    setForward(forward: Float32Array): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/LightCameraComponent' {
	/**
	 * LightCameraComponent.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/8 下午5:27:20
	*/
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import { EShadowMode } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import RenderCameraComponent from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/RenderCameraComponent';
	import View from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/View';
	import SubMesh from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/SubMesh';
	export default class LightCameraComponent extends KObject {
	    static CLASS_NAME: string;
	    get view(): View;
	    get active(): boolean;
	    get depth(): number;
	    get uniforms(): any;
	    get shadowDistance(): number;
	    get shadowFilterMode(): number;
	    get shadowMode(): EShadowMode;
	    constructor();
	    getLightDir(res: [number, number, number]): void;
	    preRender(camera: RenderCameraComponent): void;
	    drawSubMeshes(lightMode: string, sms: SubMesh[]): void;
	    clear(): void;
	    submit(): void;
	    destroy(): void;
	    setSharedDirty(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/render/Scene' {
	/**
	 * Scene.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/8 下午9:11:27
	 */
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import Node from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node';
	import ScalableList from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/ScalableList'; type RenderCameraComponent = import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/RenderCameraComponent').default; type LightCameraComponent = import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/LightCameraComponent').default;
	export default class Scene extends KObject {
	    static CLASS_NAME: string;
	    addCamera(camera: RenderCameraComponent): void;
	    removeCamera(camera: RenderCameraComponent): void;
	    addLight(light: LightCameraComponent): void;
	    removeLight(light: LightCameraComponent): void;
	    setRootNode(node: Node): void;
	    isRootNode(node: Node): boolean;
	    refreshWorldTransform(): void;
	}
	export class Scene3D extends Scene {
	    static CLASS_NAME: string;
	    cullCamera(camera: RenderCameraComponent, cullResult: ScalableList, lightMode: string): void;
	    drawCamera(camera: RenderCameraComponent, renderList: ScalableList, lightMode: string): void;
	    drawLight(light: LightCameraComponent, camera: RenderCameraComponent, renderList: ScalableList, lightMode: string): void;
	}
	export class Scene2D extends Scene {
	    static CLASS_NAME: string;
	    cullCamera(camera: RenderCameraComponent, cullResult: ScalableList): void;
	    drawCamera(camera: RenderCameraComponent, renderList: ScalableList, lightMode: string): void;
	}
	export const scene3D: Scene3D;
	export const scene2D: Scene2D;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/xmlParser' {
	 type XMLItemType = "root" | "tag" | "text";
	interface IXMLAttr {
	    [attrName: string]: any;
	}
	interface IXMLItem {
	    type: XMLItemType;
	    name?: string;
	    value?: string | string[];
	    parent?: IXMLItem;
	    child?: IXMLItem[];
	}
	export class XMLRoot implements IXMLItem {
	    type: XMLItemType;
	    child: IXMLItem[];
	}
	export class XMLTag implements IXMLItem {
	    type: XMLItemType;
	    name: string;
	    attr: IXMLAttr;
	    parent: IXMLItem;
	    child: IXMLItem[];
	    constructor(name: string);
	}
	export class XMLText implements IXMLItem {
	    type: XMLItemType;
	    value: string;
	    parent: IXMLItem;
	    constructor(value: string);
	}
	/**
	 * 简单粗暴的XML解析器，支持如下格式的文本解析，主要用于UIRichText组件
	 * <style|value=BasicLabel_Blue18>测试文字样式</style>
	 */
	export default class XMLParser {
	    parse(src: string): XMLRoot;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIRichText' {
	import { XMLRoot, XMLTag, XMLText } from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/xmlParser';
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	import { TouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Immutable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import TouchInputComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import { OverflowType, TextVAlign } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/enum';
	import { IBatchGlyph, IGlyph } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/glyph';
	import { EBreakTokenAlign, EBreakTokenVAlign, ENodeType, IBaseTextStyle, IExternNodeData, INodeData } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/typesetting';
	import UILabel from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/UILabel';
	export interface IBlockData extends INodeData {
	    textureStr?: string;
	    spriteFrameStr?: string;
	    spriteFrame?: SpriteFrame;
	    glyph?: IGlyph;
	    loop?: boolean;
	    rate?: number;
	    useResourceSize?: boolean;
	}
	/**
	 * 富文本样式类型接口
	 *
	 * @export
	 * @interface IRichTextStyle
	 */
	export interface IRichTextStyle {
	    font?: string;
	    size?: number;
	    color?: string;
	    bold?: boolean;
	    italic?: boolean;
	    spacing?: number;
	    stroke?: number;
	    strokeColor?: string;
	    underline?: number;
	    underlineColor?: string;
	    shadow?: string;
	    shadowColor?: string;
	    applyGradient?: boolean;
	    gradientTop?: string;
	    gradientBottom?: string;
	} class Style implements IRichTextStyle {
	    id: number;
	    font: string;
	    size: number;
	    color: string;
	    italic: boolean;
	    bold: boolean;
	    stroke: number;
	    strokeColor: string;
	    underline: number;
	    underlineColor: string;
	    shadow?: string;
	    shadowColor: string;
	    applyGradient: boolean;
	    gradientTop: string;
	    gradientBottom: string;
	    spacing: number;
	    lineSpace: number;
	    constructor(id: number);
	    set(data?: {}): void;
	}
	export interface IStyleBlock {
	    style: IBaseTextStyle;
	    blockCount: number;
	    nodeStart?: INodeData;
	    nodeEnd?: INodeData;
	    next?: IStyleBlock;
	}
	export const GetStyleBlock: (style: IBaseTextStyle) => IStyleBlock;
	interface IStyleMap {
	    [styleName: string]: IRichTextStyle;
	}
	export interface IRichTextLayout {
	    id: number;
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	    paddingLeft: number;
	    paddingRight: number;
	    paddingTop: number;
	    paddingBottom: number;
	    lineSpace: number;
	    layoutWidth: number;
	    layoutHeight: number;
	    lineAlign: EBreakTokenAlign;
	    lineVAlign: EBreakTokenVAlign;
	    layoutVAlign: TextVAlign;
	    wordWrap: boolean;
	    rowsNumber: number;
	    nodeStart?: INodeData;
	    nodeEnd?: INodeData;
	    styleBlockStart?: IStyleBlock;
	    styleBlockEnd?: IStyleBlock;
	    next?: IRichTextLayout;
	    child?: IRichTextLayout;
	    offsetX: number;
	    offsetY: number;
	    lineSizeX: number;
	    lineSizeY: number;
	    lineTextHeight: number;
	    baseLineTopHeight: number;
	    baseLineBottomHeight: number;
	    islayoutLined: boolean;
	}
	export const GetNodeData: (type: ENodeType, x: number, y: number, width: number, height: number, batchIndex: number) => INodeData;
	export interface IExternNode {
	    nodeStart?: IExternNodeData;
	    nodeEnd?: IExternNodeData;
	}
	export interface ILinkArea {
	    nodeStart?: INodeData;
	    nodeEnd?: INodeData;
	    linkAreaStart?: ILinkAreaData;
	    linkAreaEnd?: ILinkAreaData;
	}
	export interface ILinkAreaData {
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	    linkid: number;
	    next?: ILinkAreaData;
	}
	export const GetLinkAreaData: (x: number, y: number, width: number, height: number, linkid: number) => ILinkAreaData;
	export default class UIRichText extends UILabel {
	    get fontColor(): Color | string;
	    set fontColor(val: Color | string);
	    get applyGradient(): boolean;
	    set applyGradient(val: boolean);
	    get gradientTop(): Color;
	    set gradientTop(val: Color);
	    get gradientBottom(): Color;
	    set gradientBottom(val: Color);
	    get stroke(): number;
	    set stroke(val: number);
	    get strokeColor(): Color;
	    set strokeColor(val: Color);
	    get shadowOffset(): Vector2;
	    set shadowOffset(val: Vector2);
	    get shadowColor(): Color;
	    set shadowColor(val: Color);
	    get underline(): number;
	    set underline(val: number);
	    get underlineColor(): Color;
	    set underlineColor(val: Color);
	    /**
	     * 获取富文本全局样式表
	     * @static
	     * @type {IStyleMap}
	     * @memberof UIRichText
	     */
	    static get style(): IStyleMap;
	    /**
	     * 富文本全局样式表切换设置(移除原有所有样式)
	     *
	     * @static
	     * @memberof UIRichText
	     */
	    static set style(style: IStyleMap);
	    /**
	     * 获取富文本当前组件样式表（不包含全局）
	     *
	     * @static
	     * @type {IStyleMap}
	     * @memberof UIRichText
	     */
	    get style(): IStyleMap;
	    /**
	     * 设置富文本当前组件样式表(移除原有所有样式)
	     *
	     * @static
	     * @memberof UIRichText
	     */
	    set style(style: IStyleMap);
	    /**
	     * 富文本的xml文本内容
	     *
	     * @type {string}}
	     * @memberof UIRichText
	     */
	    get text(): string;
	    set text(val: string);
	    /**
	     * 是否自动添加Link的触摸组件
	     *
	     * @type {boolean}
	     * @memberof UIRichText
	     */
	    get autoAddLinkTouch(): boolean;
	    set autoAddLinkTouch(val: boolean);
	    /**
	     * 获取行数
	     *
	     * @readonly
	     * @type {number}
	     * @memberof UIRichText
	     */
	    get rowsNumber(): number;
	    /**
	     * 获取超链接区域
	     *
	     * @readonly
	     * @type {number}
	     * @memberof UIRichText
	     */
	    get linkAreas(): Array<{
	        id: number;
	        data: string;
	        x: number;
	        y: number;
	        width: number;
	        height: number;
	    }>;
	    get metrics(): Immutable<{
	        width: number;
	        height: number;
	        innerWidth: number;
	        innerHeight: number;
	        outerWidth: number;
	        outerHeight: number;
	        rowsNumber: number;
	        layoutWidth?: number;
	        layouHeight?: number;
	    }>;
	    /**
	     * 富文本样式类
	     *
	     * @static
	     * @memberof UIRichText
	     */
	    static Style: typeof Style;
	    /**
	     * 富文本越界处理方式枚举类型
	     *
	     * @static
	     * @memberof UIRichText
	     */
	    static overflowType: typeof OverflowType;
	    static OverflowType: typeof OverflowType;
	    /**
	     * 富文本设置的全局样式方法设置(继承并替换原有样式)
	     *
	     * @static
	     * @param {IStyleMap} style
	     * @memberof UIRichText
	     */
	    static setStyle(style: IStyleMap): void;
	    readonly priority: number;
	    /**
	     * 强制重绘。异步操作，下一帧才会重绘。
	     *
	     * @memberof UIRichText
	     */
	    redraw(): void;
	    bindNodeWithTransform(nodeId: number, nodeTransform: Transform2D): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIScrollView' {
	import { TouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import TouchInputComponent, { Touchable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	import { BoundsChangeEventType, ChildChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event'; enum Movement {
	    Horizontal = 0,
	    Vertical = 1
	}
	export default class UIScrollView extends Touchable {
	    readonly entity: Entity2D;
	    /**
	     * UIScrollView具有的滑动方向类型枚举值
	     *
	     * @static
	     * @type {Movement}
	     * @memberof UIScrollView
	     */
	    static Movement: Readonly<typeof Movement>;
	    /** @deprecated */
	    static MovementType: Readonly<typeof Movement>;
	    readonly priority: number;
	    /**
	     * Movement类型，UIScrollView的滑动方向。
	     *
	     * @type {Movement}
	     * @memberof UIScrollView
	     */
	    get movement(): Movement;
	    set movement(val: Movement);
	    /**
	     * 默认值true，内容区域尺寸小于滑动区域(对应Transform2D大小)时，是否禁止滑动。
	     *
	     * @type {boolean}
	     * @memberof UIScrollView
	     */
	    get disableDragIfFits(): boolean;
	    set disableDragIfFits(val: boolean);
	    /**
	     * 默认值为0，在autoFix情况下，内容区域位于滑动区域(对应Transform2D大小)水平方向的相对位置，取值范围(0-1)。
	     *
	     * @type {number}
	     * @memberof UIScrollView
	     */
	    get cellAlignmentX(): number;
	    set cellAlignmentX(val: number);
	    /**
	     * 默认值为1，在autoFix情况下，内容区域位于滑动区域(对应Transform2D大小)垂直方向的相对位置，取值范围(0-1)。
	     *
	     * @type {number}
	     * @memberof UIScrollView
	     */
	    get cellAlignmentY(): number;
	    set cellAlignmentY(val: number);
	    /**
	     * 只读属性，相对于滑动起点，正向的已滑动的距离。
	     *
	     * @type {number}
	     * @memberof UIScrollView
	     */
	    get moveDistance(): number;
	    /**
	     * 相对于滑动起点的，最小滑动距离，若设定，则UIScrollView自动计算最小滑动距离逻辑失效，最小值固定取该值。
	     *
	     * @type {number}
	     * @memberof UIScrollView
	     */
	    get minContextMove(): number;
	    set minContextMove(val: number);
	    /**
	     * 相对于滑动起点的，最大滑动距离，若设定，则UIScrollView自动计算最大滑动距离逻辑失效，最大值固定取该值。
	     *
	     * @type {number}
	     * @memberof UIScrollView
	     */
	    get maxContextMove(): number;
	    set maxContextMove(val: number);
	    /**
	     * 默认值为false，是否开启组件根据内容区域大小与滑动区域大小(对应Transform2D大小)，将内容区域移动到相对于当前组件的对齐位置，内容区域只会根据UIScrollView第一层子元素大小进行位置适配。
	     *
	     * @type {boolean}
	     * @memberof UIScrollView
	     */
	    get autoFix(): boolean;
	    set autoFix(val: boolean);
	    /**
	     * 默认值为false，滑动到顶后(小于minContentMove)，是否允许继续滑动
	     *
	     * @type {boolean}
	     * @memberof UIScrollView
	     */
	    get snapToStart(): boolean;
	    set snapToStart(val: boolean);
	    /**
	     * 默认值为false，滑动到底后(大于maxContentMove)，是否允许继续滑动
	     *
	     * @type {boolean}
	     * @memberof UIScrollView
	     */
	    get snapToEnd(): boolean;
	    set snapToEnd(val: boolean);
	    /**
	     * 返回UIScrollView到顶行为的Delegate，通过add方法添加事件。
	     *
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof UIScrollView
	     */
	    get onReachStart(): Delegate<this, TouchInputEvent>;
	    /**
	     * Delegate<this, TouchInputEvent> | 返回UIScrollView到底行为的Delegate，通过add方法添加事件。
	     *
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof UIScrollView
	     */
	    get onReachEnd(): Delegate<this, TouchInputEvent>;
	    /**
	     * 返回UIScrollView到顶行为的Delegate，通过add方法添加事件。
	     *
	     * @readonly
	     * @type {Delegate<this, TouchInputEvent>}
	     * @memberof UIScrollView
	     */
	    get onScroll(): Delegate<this, TouchInputEvent>;
	    constructor(entity: Entity2D);
	    /**
	     * 设置设定的最大最小滑动距离，若设定则优先使用这两个值。
	     *
	     * @param {number} min
	     * @param {number} max
	     * @memberof UIScrollView
	     */
	    setMinMax(min: number, max: number): void;
	    /**
	     * 清理设定的最大最小，取消后会恢复使用自动生成最大最小距离逻辑。
	     *
	     * @memberof UIScrollView
	     */
	    clearMinMax(): void;
	    /**
	     * 组件滑动到，pos对应的滑动距离
	     *
	     * @param {number} pos
	     * @memberof UIScrollView
	     */
	    scrollTo(pos: number): void;
	    /**
	     * 清空当前滑动了的距离，并重新初始化
	     *
	     * @memberof UIScrollView
	     */
	    refreshMove(): void;
	    /**
	     * 停止UIScrollView滑动
	     *
	     * @memberof UIScrollView
	     */
	    disableScroll(): void;
	    /**
	     * 开启UIScrollView滑动
	     *
	     * @memberof UIScrollView
	     */
	    enableScroll(): void;
	    on(): void;
	    off(): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIToggleGroup' {
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	import UIToggle from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIToggle';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { ChildChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	/**
	 * TODO chidren acttive change need observe !!!
	 */
	export default class UIToggleGroup extends Component {
	    readonly entity: Entity2D;
	    readonly priority: number;
	    /**
	     * 默认值为false，UIToggleGroup下属的UIToggle是否允许取消激活态。
	     *
	     * @type {boolean}
	     * @memberof UIToggleGroup
	     */
	    get allowSwitchOff(): boolean;
	    set allowSwitchOff(val: boolean);
	    /**
	     * UIToggleGroup控制的UIToggle数组
	     *
	     * @readonly
	     * @type {Array<UIToggle>}
	     * @memberof UIToggleGroup
	     */
	    get toggleList(): UIToggle[];
	    /**
	     * 默认值为undefined，UIToggleGroup中默认处于激活态的UIToggle。
	     *
	     * @type {UIToggle}
	     * @memberof UIToggleGroup
	     */
	    get deafaultActiveToggle(): UIToggle | undefined;
	    set deafaultActiveToggle(val: UIToggle | undefined);
	    /**
	     * 默认值为false，UIToggleGroup在onStart初始化index后，后续会不会自动更新index
	     *
	     * @type {boolean}
	     * @memberof UIToggleGroup
	     */
	    get useStaticIndex(): boolean;
	    set useStaticIndex(val: boolean);
	    constructor(entity: Entity2D);
	    /**
	     * 添加UIToggle进入UIToggleGroup
	     *
	     * @param {UIToggle} toggle
	     * @memberof UIToggleGroup
	     */
	    addToggle(toggle: UIToggle): void;
	    /**
	     * 删除UIToggleGroup中的UIToggle
	     *
	     * @param {UIToggle} toggle
	     * @memberof UIToggleGroup
	     */
	    removeToggle(toggle: UIToggle): void;
	    /**
	     * 返回当前ToggleGroup激活状态的Toggle
	     *
	     * @returns {(UIToggle | null)}
	     * @memberof UIToggleGroup
	     */
	    getActiveToggle(): UIToggle | null;
	    /**
	     * 根据index，激活ToggleGroup里面Toggle，返回是否成功激活
	     *
	     * @param {number} index
	     * @returns {boolean}
	     * @memberof UIToggleGroup
	     */
	    setIndex(index: number): boolean;
	    /**
	     * 取消激活ToggleGroup中除toggle外的其他Toggle
	     *
	     * @param {UIToggle} toggle
	     * @memberof UIToggleGroup
	     */
	    checkedChange(toggle: UIToggle): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIToggle' {
	import { TouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import { Touchable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	import ToggleGroup from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIToggleGroup'; enum ToggleState {
	    UnChecked = 0,
	    Checked = 1
	}
	export default class UIToggle extends Touchable {
	    readonly entity: Entity2D;
	    /**
	     * UIToggle的状态枚举值
	     *
	     * @static
	     * @memberof UIToggle
	     */
	    static ToggleState: Readonly<typeof ToggleState>;
	    readonly priority: number;
	    /**
	     * 默认值为undefined，UIToggle关联的UIToggleGroup
	     *
	     * @type {ToggleGroup | undefined}
	     * @memberof UIToggle
	     */
	    toggleGroup?: ToggleGroup;
	    /**
	     * 是否允许取消激活态
	     *
	     * @type {boolean}
	     * @memberof UIToggle
	     */
	    get allowSwitchOff(): boolean;
	    set allowSwitchOff(val: boolean);
	    /**
	     * 位于ToggleGroup的index，若无对应ToggleGroup则为-1
	     *
	     * @type {number}
	     * @memberof UIToggle
	     */
	    get index(): number;
	    set index(val: number);
	    /**
	     * 是否处于激活态
	     *
	     * @type {boolean}
	     * @memberof UIToggle
	     */
	    get isChecked(): boolean;
	    set isChecked(val: boolean);
	    /**
	     * UIToggle激活态影响的渲染组件
	     *
	     * @readonly
	     * @type {(Renderable2D | undefined)}
	     * @memberof UIToggle
	     */
	    get target(): Renderable2D | undefined;
	    set target(val: Renderable2D | undefined);
	    constructor(entity: Entity2D);
	    /**
	     * 返回当前UIToggle状态
	     *
	     * @returns {ToggleState}
	     * @memberof UIToggle
	     */
	    getState(): ToggleState;
	    /**
	     * 设置UIToggle状态
	     *
	     * @param {ToggleState} state
	     * @returns {void}
	     * @memberof UIToggle
	     */
	    setState(state: ToggleState): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIWidget' {
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import { Entity2D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	import { Listener } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/emitter';
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	import { BoundsChangeEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event'; enum Execute {
	    onEnable = 0,
	    onUpdate = 1,
	    onAwake = 2
	}
	export default class UIWidget extends Component {
	    readonly entity: Entity2D;
	    /**
	     * 更新运算的时机的枚举值，对应不同的组件生命周期。
	     *
	     * @static
	     * @type {Execute}
	     * @memberof UIWidget
	     */
	    static Execute: Readonly<typeof Execute>;
	    readonly priority: number;
	    /**
	     * 默认值为undefined，左目标内容包围盒的锚点，作为左方向对齐起点位置（取值范围(0-1)）
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get leftAnchor(): number | undefined;
	    set leftAnchor(val: number | undefined);
	    /**
	     * 默认值为0，根据左方向目标Anchor对齐运算后，再叠加的偏移量
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get leftOffset(): number;
	    set leftOffset(val: number);
	    /**
	     * Transform2D类型，默认值为undefined，左方向对齐目标。
	     *
	     * @type {Transform2D}
	     * @memberof UIWidget
	     */
	    get leftAnchorTarget(): Transform2D | undefined;
	    set leftAnchorTarget(val: Transform2D | undefined);
	    /**
	     * 默认值为undefined，右目标内容包围盒的锚点，作为右方向对齐起点位置（取值范围(0-1)）
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get rightAnchor(): number | undefined;
	    set rightAnchor(val: number | undefined);
	    /**
	     *  默认值为0，根据右方向目标Anchor对齐运算后，再叠加的偏移量
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get rightOffset(): number;
	    set rightOffset(val: number);
	    /**
	     * Transform2D类型，默认值为undefined，右方向对齐目标。
	     *
	     * @type {Transform2D}
	     * @memberof UIWidget
	     */
	    get rightAnchorTarget(): Transform2D | undefined;
	    set rightAnchorTarget(val: Transform2D | undefined);
	    /**
	     * 默认值为undefined，下目标内容包围盒的锚点，作为下方向对齐起点位置（取值范围(0-1)）
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get bottomAnchor(): number | undefined;
	    set bottomAnchor(val: number | undefined);
	    /**
	     * 默认值为0，根据下方向目标Anchor对齐运算后，再叠加的偏移量
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get bottomOffset(): number;
	    set bottomOffset(val: number);
	    /**
	     * Transform2D类型，默认值为undefined，下方向对齐目标。
	     *
	     * @type {Transform2D}
	     * @memberof UIWidget
	     */
	    get bottomAnchorTarget(): Transform2D | undefined;
	    set bottomAnchorTarget(val: Transform2D | undefined);
	    /**
	     * 默认值为undefined，上目标内容包围盒的锚点，作为上方向对齐起点位置（取值范围(0-1)）
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get topAnchor(): number | undefined;
	    set topAnchor(val: number | undefined);
	    /**
	     * 默认值为0，根据上方向目标Anchor对齐运算后，再叠加的偏移量
	     *
	     * @type {number}
	     * @memberof UIWidget
	     */
	    get topOffset(): number;
	    set topOffset(val: number);
	    /**
	     * Transform2D类型，默认值为undefined，上方向对齐目标。
	     *
	     * @type {Transform2D}
	     * @memberof UIWidget
	     */
	    get topAnchorTarget(): Transform2D | undefined;
	    set topAnchorTarget(val: Transform2D | undefined);
	    /**
	     * Execute类型，组件属性或目标关联属性发生变化后，具体进行更新运算的时机。
	     *
	     * @type {Execute}
	     * @memberof UIWidget
	     */
	    get execute(): Execute;
	    set execute(val: Execute);
	    constructor(entity: Entity2D);
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMesh' {
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	import Renderable2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/renderable2D';
	export default class UIMesh extends Renderable2D {
	    /**
	     * 图片资源。
	     * @type {Nullable<SpriteFrame>}
	     * @memberof UISprite
	     */
	    get texture2D(): Nullable<Texture2D>;
	    set texture2D(value: Nullable<Texture2D>);
	    /**
	     * 是否使用顶点色
	     * @type {Nullable<SpriteFrame>}
	     * @memberof UISprite
	     */
	    get useVertexBufferColor(): boolean;
	    set useVertexBufferColor(value: boolean);
	    get verticesBuffer(): Nullable<ArrayBuffer>;
	    get verticesBufferView(): Nullable<Float32Array>;
	    get verticesBufferViewU32(): Nullable<Uint32Array>;
	    get indicesBuffer(): Nullable<ArrayBuffer>;
	    get indicesBufferView(): Nullable<Uint16Array>;
	    setBufferValue(verticesArray: Float32Array, indicesArray: Uint16Array): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/rawResourceCollection' {
	/**
	 * 资源系统可以加载json用的
	 * 是Unity里直接可以弄这个脚本挂RawResource
	 */
	import RawResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/raw';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	export default class RawResourceCollection extends Component {
	    resources: RawResource[];
	    ResourcePaths: RawResource[];
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/raycaster' {
	/**
	 * create by janzen
	 */
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import Camera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera';
	import BoundBall from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall'; class Intersect {
	    entity: Entity;
	    distance: number;
	    closetIntersectPoint: Vector3;
	    constructor(entity: Entity, distance: number, closetIntersectPoint: Vector3);
	}
	export default class Raycaster {
	    get direction(): Vector3;
	    get origin(): Vector3;
	    constructor(origin?: Vector3, direction?: Vector3);
	    /**
	     * 通过相机与齐次裁剪坐标来生成射线
	     * @param {Vector3} clipPos 归一化的位置 -1到1，上方向为正 , 近平面z轴为-1
	     * @param {Camera}  camera 相机
	     */
	    setFromCameraAndClipPos(clipPos: Vector3, camera: Camera): void;
	    intersectEntitySimple(entity: Entity, recursive?: boolean): boolean;
	    /**
	     * 是否与物体相交
	     * @param entity 需要被检测的物体
	     * @param recursive 是否递归判断
	     * @param result 结果的数组 （结果会放进去 主要为了递归用）
	     * @returns 返回相交的entity
	     */
	    intersectEntity(entity: Entity, recursive?: boolean, result?: Intersect[]): Intersect[];
	    /**
	     * 是否与多个物体相交
	     * @param entities 需要被检测的多个物体
	     * @param recursive 是否递归判断
	     * @param result 结果的数组 （结果会放进去 主要为了递归用）
	     * @returns 返回相交的entity,按照包围球的近点到相机的距离排序
	     */
	    intersectEntities(entities: Entity[], recursive?: boolean, result?: Intersect[]): Intersect[];
	    raycastSimple(boundBall: BoundBall): boolean;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/gradient' {
	import Color from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color'; const interpolate: (start: Color, end: Color, offset?: number) => Color; class Gradient {
	} class LinearGradient {
	    constructor(top: Color, bottom: Color);
	    equals(g: LinearGradient): boolean;
	}
	export { LinearGradient, Gradient, interpolate };

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/timer' {
	export default class Timer {
	    constructor(stepTime: number);
	    /**
	     * 模拟客户端
	     *
	     * @param {Function} callback
	     * @param {number} time
	     * @returns {number}
	     * @memberof Timer
	     */
	    setTimeout(callback: (...args: any[]) => any, time: number): number;
	    setInterval(callback: (...args: any[]) => any, time: number): number;
	    clearTimeout(id: number): void;
	    clearInterval(id: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/adaptation' {
	import { Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	export enum AdaptationType {
	    Auto = 0,
	    FillWidth = 1,
	    FillHeight = 2
	}
	export class Adaptation {
	    canvas: Nullable<HTMLCanvasElement>;
	    fillType: AdaptationType;
	    frameWidth: number;
	    frameHeight: number;
	    designWidth: number;
	    designHeight: number;
	    aspect: number;
	    uiScale: number;
	    constructor();
	    setDesignSize(width: number, height: number): void;
	    setRenderSize(width: number, height: number): void;
	} const adaptation: Adaptation;
	export default adaptation;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/wx/commandBuffer' {
	/**
	 * WXAPI指令队列
	 * 分为两块：1. 本地内存，放在_queue中；2. 共享内存，放在_buffer中
	 * 平时输入指令全部进入_queue，仅在job update阶段更新_buffer
	 * 指令格式为
	 * · command type (1 byte)
	 * · worker内object id (2 byte)
	 * · data length (2 byte)
	 * · data
	 * command type = 0 说明指令结束
	 * 如果_queue内下一条指令在_buffer内存不下了，就下一帧再存
	 */
	export default class WXCommandBuffer {
	    constructor(size: number);
	    put(type: number, id: number, data: ArrayBuffer, length?: number): void;
	    clearAndFlush(): void;
	    forEach(callback: (type: number, id: number, data: Uint8Array, length: number) => void): void;
	    get buffer(): engineWX.SharedArrayBuffer;
	    isEmpty(): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/wx/utils' {
	export function encodeJsString(str: string): ArrayBuffer;
	export function decodeJsString(ab: ArrayBuffer): string;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/wx/downloadFile' {
	export default function downloadFile(object: engineWX.DownloadFileOptions): engineWX.DownloadTask;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/wx' {
	export { default as downloadFile } from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/wx/downloadFile';

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/buffer/schema' {
	export enum Primitive {
	    INT8 = 0,
	    INT16 = 1,
	    INT32 = 2,
	    UINT8 = 3,
	    UINT16 = 4,
	    UINT32 = 5,
	    FLOAT32 = 6,
	    FLOAT64 = 7
	}
	export interface Base {
	}
	export type BaseSchema = Base | Primitive;
	export interface ObjSchema extends Base {
	    [key: string]: BaseSchema | undefined;
	}
	export interface ArraySchema extends Base {
	    length: number;
	    element: BaseSchema;
	}
	export interface UnionSchema extends Base {
	    members: ObjSchema;
	}
	export function array(T: BaseSchema, N: number): ArraySchema;
	export function union(T: ObjSchema): UnionSchema;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/buffer/reader' {
	import * as Schema from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/buffer/schema';
	interface DataReader {
	    [key: number]: string;
	}
	interface DataWriter {
	    [key: number]: string;
	}
	export class Reader {
	    baseOffset: number;
	    offset: number;
	    isReader: boolean;
	    size: number;
	    type: number;
	    protected constructor(schema: Schema.Base, offset?: number);
	    setData(data: ArrayBuffer, reader?: DataView): void;
	    static create(schema: Schema.Base, offset?: number): Reader;
	}
	export class ObjReader extends Reader {
	    type: number;
	    constructor(schema: Schema.ObjSchema, offset: number);
	    /**
	     * @override
	     */
	    setData(data: ArrayBuffer, reader?: DataView): void;
	    array(n: string): ArrayReader;
	    obj(n: string): ObjReader;
	    union(n: string): UnionReader;
	    get(n: string): number;
	    set(n: string, v: number): void;
	}
	export class ArrayReader extends Reader {
	    type: number;
	    constructor(schema: Schema.ArraySchema, offset: number);
	    /**
	     * @override
	     */
	    setData(data: ArrayBuffer, reader: DataView): void;
	    array(i: number): ArrayReader;
	    obj(i: number): ObjReader;
	    union(i: number): UnionReader;
	    get(i: number): number;
	    set(i: number, v: number): void;
	}
	export class UnionReader extends Reader {
	    type: number;
	    constructor(schema: Schema.UnionSchema, offset: number);
	    /**
	     * @override
	     */
	    setData(data: ArrayBuffer, reader?: DataView): void;
	    array(n: string): ArrayReader;
	    obj(n: string): ObjReader;
	    union(n: string): UnionReader;
	    get(n: string): number;
	    set(n: string, v: number): void;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/boxCollider' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	/**
	 * 长方体盒状碰撞体。
	 * @category Physics
	 */
	export default class BoxCollider extends Collider {
	    /**
	     * 碰撞体相对于LocalTransform中心点的偏移。
	     * @default (0, 0, 0)
	     */
	    get center(): Vector3;
	    set center(v: Vector3);
	    /**
	     * 长方体的大小（X，Y，Z）。
	     * @default (1, 1, 1)
	     */
	    get size(): Vector3;
	    set size(v: Vector3);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/sphereCollider' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	/**
	 * 球状碰撞体。
	 * @category Physics
	 */
	export default class SphereCollider extends Collider {
	    /**
	     * 碰撞体相对于LocalTransform中心点的偏移。
	     * @default (0, 0, 0)
	     */
	    get center(): Vector3;
	    set center(v: Vector3);
	    /**
	     * 碰撞体球的半径。
	     * @default 1
	     */
	    get radius(): number;
	    set radius(v: number);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/capsuleCollider' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import { CapsuleColliderDirection } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	import Vector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	/**
	 * 胶囊状碰撞体。
	 * @category Physics
	 */
	export default class CapsuleCollider extends Collider {
	    /**
	     * 碰撞体相对于LocalTransform中心点的偏移。
	     * @default (0, 0, 0)
	     */
	    get center(): Vector3;
	    set center(v: Vector3);
	    /**
	     * 碰撞体胶囊两侧半球的半径。
	     * @default 0.5
	     */
	    get radius(): number;
	    set radius(v: number);
	    /**
	     * 碰撞体胶囊的长度（包括两侧半球的半径）。
	     * @default 2
	     */
	    get height(): number;
	    set height(v: number);
	    /**
	     * 碰撞体胶囊的朝向。
	     * @default {@link CapsuleColliderDirection.X-Axis}
	     */
	    get direction(): CapsuleColliderDirection;
	    set direction(v: CapsuleColliderDirection);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/meshCollider' {
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import { ColliderType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	import Mesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh';
	/**
	 * 三维网格碰撞体。
	 * 出于性能考虑，请尽量使用其他类型的碰撞体来模拟形状。如果真的需要更精细的碰撞效果，可以少量使用该碰撞体。
	 * @category Physics
	 */
	export default class MeshCollider extends Collider {
	    /**
	     * @unimplemented
	     * @default 0
	     */
	    get cookingOptions(): number;
	    set cookingOptions(v: number);
	    /**
	     * 碰撞体是否为[凸多面体](https://baike.baidu.com/item/%E5%87%B8%E5%A4%9A%E9%9D%A2%E4%BD%93/2472670)。
	     * 设置`convex = true`了之后，物理系统会自动为该模型烘焙出凸多面体的外壳，以此来提高性能，**并且能让碰撞体与另一个MeshCollider发生碰撞**。
	     * @default false
	     */
	    get convex(): boolean;
	    set convex(v: boolean);
	    /**
	     * \**尽量避免动态更改*
	     * 碰撞体使用的网格模型。
	     * 如果未指定，则会尝试从同节点的MeshRenderer上取。
	     * @default undefined
	     */
	    get mesh(): Mesh | undefined;
	    set mesh(m: Mesh | undefined);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/createFullScreenDebugQuad' {
	/**
	 * createFullScreenDebugQuad.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 10/28/2020, 2:22:26 PM
	 */
	import { Kanata } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import RenderTexture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	export default function createFullScreenDebugQuad(textureLast: Texture2D | RenderTexture): Kanata.MeshRendererComponent;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/DebugRG' {
	import RenderGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph';
	import RenderSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	/**
	 * 用于调试的RenderGraph。
	 * 将会将初始化的纹理绘制在四分之一个屏幕上，若不传纹理，默认将绘制绿色。
	 *
	 * @category Render
	 */
	export default class DebugRG extends RenderGraph<{
	    texture?: Texture2D;
	}> {
	    onActive(context: RenderSystem, options: {
	        texture: Texture2D;
	    }): void;
	    onExecuteBegin(context: RenderSystem): void;
	}

}
declare module 'engine' {
	import renderEnv from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/renderEnv';
	import { NativeBufferReader } from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/nativeBuffer';
	import AnimationClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animationClip';
	import AnimatorController from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/animatorController';
	import Avatar from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatar';
	import AvatarMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/avatarMask';
	import BaseResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/baseResource';
	import BitmapFont from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/bitmapFont';
	import Effect from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/effect';
	import Font from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/font';
	import Material from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/material';
	import Mesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/mesh';
	import Prefab from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/prefab';
	import RawResource from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/raw';
	import Atlas from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/atlas';
	import RenderTexture, { IRenderTextureOptions } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/renderTexture';
	import Scene from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/scene';
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	import Texture2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture2D';
	import TextureCube from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/textureCube';
	import ScriptableAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/scriptableAsset';
	import AudioClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audioClip';
	import TimelineAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineAsset';
	import TimelineClip from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/timelineClip';
	import TrackAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/trackAsset';
	import { TimelineClipAsset } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/playable/interface';
	import Loader from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/loader/base';
	import { TextureFilterMode as TextureFilterModeEnum } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture';
	import { AmbientMode as AmbientModeEnum, FogMode as FogModeEnum, WrapMode as WrapModeEnum } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/resource';
	import { SerializeHelper } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/deserialize';
	import { TypeNames } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/decorators';
	import decorators from '!!Only Export Engine Module, Cant Use Internal Module：engine/decorators';
	import { Serialize } from '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/serialize/shared';
	import * as Debug from '!!Only Export Engine Module, Cant Use Internal Module：engine/debug';
	import { executeInEditMode, executeInGameMode, executeInAllMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/shared/executeMode';
	import KeyboardInputComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/KeyboardInputComponent';
	import TouchInputComponent, { Touchable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/input/TouchInputComponent';
	import { TextAlign, TextRenderMode, TextVAlign } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/enum';
	import Canvas2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/Canvas2D';
	import UILabel from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/label/UILabel';
	import UIAnchor from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIAnchor';
	import UIButton from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIButton';
	import UICamera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICamera';
	import UICanvas from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UICanvas';
	import UIGraphic from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIGraphic';
	import UIGrid from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIGrid';
	import UIMask from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMask';
	import UIRichText from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIRichText';
	import UIScrollView from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIScrollView';
	import UISprite from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UISprite';
	import UITextInput from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UITextInput';
	import UIToggle from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIToggle';
	import UIToggleGroup from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIToggleGroup';
	import UIWidget from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIWidget';
	import UILayer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UILayer';
	import UIMesh from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIMesh';
	import OpenDataContainer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/OpenDataContainer';
	import Animation from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animation';
	import Skeleton from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skeleton';
	import { AnimationUtility } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Utility';
	import Animator from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/Animator';
	import Camera from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/camera';
	import DirectionalLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/directionalLight';
	import PointLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/pointLight';
	import SpotLight from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lights/spotLight';
	import LineRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/lineRenderer';
	import MeshRenderer, { EMeshCullType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/meshRenderer';
	import SkinnedAnimationRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/animator/SkinnedAnimationRenderer';
	import SkinnedMeshRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/skinnedMeshRenderer';
	import TrailRenderer from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/trailRenderer';
	import LODGroup from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/LODGroup';
	import PlayableDirector from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableDirector';
	import AudioSource from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioSource';
	import AudioListener from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/AudioListener';
	import AudioHighPassFilter from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioHighPassFilter';
	import AudioLowPassFilter from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioLowPassFilter';
	import AudioDistortion from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioDistortion';
	import AudioEcho from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/effect/AudioEcho';
	import Audio from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/Audio';
	import { IAudioMixer as AudioMixer } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixer';
	import { IAudioMixerGroup as AudioMixerGroup } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerGroup';
	import { IAudioMixerSnapshot as AudioMixerSnapshot } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/audio/mixer/AudioMixerSnapshot';
	import AudioMixerAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/audio/audioMixerAsset';
	import Component from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/component';
	import Game from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/game';
	import Particle from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/particle';
	import RawResourceCollection from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/rawResourceCollection';
	import Raycaster from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/raycaster';
	import BoundBall from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/boundBall';
	import Script from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/script';
	import Transform2D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform2D';
	import Transform3D from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transform3D';
	import TransformBase from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/transformBase';
	import PostProcessAsset from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/postProcessAsset';
	import { userCrossContextDataBus, ICrossContextDataBus } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/crossContextDataBus';
	import { default as InternalGctx } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Color, { BlendType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/color';
	import HermiteCurve from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/hermiteCurve';
	import GradientColor from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/gradientColor';
	import { LinearGradient } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/gradient';
	import Matrix3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix3';
	import Matrix4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/matrix4';
	import Quaternion from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/quaternion';
	import Rect from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/rect';
	import Vector2 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector2';
	import Vector3, { Vector3_READONLY } from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector3';
	import Vector4 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/vector4';
	import BooleanVector3 from '!!Only Export Engine Module, Cant Use Internal Module：engine/math/booleanVector3';
	import { Delegate } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/delegate';
	import { Delegate as PhysicsDelegate, DelegateHandler as PhysicsDelegateHandler } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/physicevent';
	import Entity from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/entity';
	import Timer from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/timer';
	import device, { Environment as EnvironmentEnum, GroupPlatform as GroupPlatformEnum, Platform as PlatformEnum } from '!!Only Export Engine Module, Cant Use Internal Module：engine/platform/device';
	import settings from '!!Only Export Engine Module, Cant Use Internal Module：engine/settings';
	import adaptation from '!!Only Export Engine Module, Cant Use Internal Module：engine/adaptation';
	import { FrameSystem, FrameSystemMode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/FrameSystem';
	import { CacheManager } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/file/cache';
	import { ILoadTask } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-task';
	import { NumberJSONMap, ComplexJSONMap } from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/util';
	import { buildin2DVertexLayout, buildInVertexLayoutFactory3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/buildinVertexLayout';
	import { MaterialEventType, MeshEventType, BoundsChangeEventType, ChildChangeEventType, LightEventType, Renderable2DEventType, MeshRendererEventType, PipeLineEventType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/event';
	import LitePromise from '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/promise';
	import EngineWorker from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/worker';
	import WorkerJob from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/job';
	import * as wxRemote from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/wx';
	import * as Schema from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/buffer/schema';
	import { ObjReader, ArrayReader, UnionReader } from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/buffer/reader';
	import { StatusEnum as EWorkerStatus } from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/worker';
	import { StatusEnum as EWorkerJobStatus } from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/job';
	import WorkerSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/worker';
	import PhysicsSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/physics';
	import Rigidbody from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/rigidbody';
	import Collider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collider';
	import BoxCollider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/boxCollider';
	import SphereCollider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/sphereCollider';
	import CapsuleCollider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/capsuleCollider';
	import MeshCollider from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/meshCollider';
	import { ICollision, ITriggerCollision } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/collision';
	import { IContactPoint as ContactPoint } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/contactPoint';
	import { Bounds, ReadonlyBounds } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/bounds';
	import { ForceMode, CombineMode, RigidbodyConstraints, CapsuleColliderDirection, CollisionDetectionMode, PhysMeshCookingFlag, QueryTriggerInteraction, CollisionFlags, ColliderType } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/types';
	import PhysicMaterial from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/physicMaterial';
	import RaycastHit from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/raycasthit';
	import CharacterController from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/charactercontroller';
	import { IControllerColliderHit } from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/controllerColliderHit';
	import OpenData from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/open-data';
	import ScriptPlayable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/scriptPlayable';
	import PlayableBehaviour from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableBehaviour';
	import PlayableGraph from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playableGraph';
	import Playable from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/3D/playableDirector/playable';
	import { TouchInputEvent as internalTouchInputEvent } from '!!Only Export Engine Module, Cant Use Internal Module：engine/input/touch';
	import { Entity2D as internalEntity2D, Entity3D as internalEntity3D } from '!!Only Export Engine Module, Cant Use Internal Module：engine/scene/scene';
	import StreamingLoadingComponent from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/streaming-loading';
	import { Gizmos } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/gizmos';
	import { GizmoMaterials } from '!!Only Export Engine Module, Cant Use Internal Module：engine/gizmos/materials/gizmoMaterials';
	import RenderSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render';
	import BuildInTextures from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/buildin-textures';
	import { Kanata, IEngineSettings } from '!!Only Export Engine Module, Cant Use Internal Module：engine/globalContext';
	import Texture from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/texture';
	import StreamingLoadingSystem from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/streaming-loading'; const version: string; const workerVersion = "1.1"; const createNativeUUMap: () => Kanata.INativeMap<number>; const createNativeSUMap: () => Kanata.INativeMap<string>; const createNativeULUMap: () => Kanata.ILongIntNativeMap; const VERSION: string;
	export { EBlendEquation, EBlendFactor, EColorMask, EShadowFitMode, EShadowMode, ECompareFunc, ECullMode, EDataModelType, EEventType, EFaceWinding, EFilterMode, EIndexType, ELoadAction, EMeshRenderType, EPixelType, EPrimitiveType, EStencilOp, ETextureFormat, ETextureType, EUniformType, EVertexFormat, EVertexLayoutUsage, EVertexStep, EWrapMode, VertexLayout, UniformBlock, UniformDescriptor, TCompressTexture, ScalableList, View, Image, IImage, ITextureOptions, IView, IViewAction, IVertexDataDescriptorOptions, IUniformDescriptorOptions, IVertexLayoutOptions, IFeatures, IRect, TTextureSource } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src';
	export { default as RenderSystem } from '!!Only Export Engine Module, Cant Use Internal Module：engine/system/render';
	export { default as Screen } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render/screen';
	export { default as RGNode } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RGNode';
	export { default as RenderGraph } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/RenderGraph';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/buildinRGNodes';
	export { default as ForwardBaseSubGraph, IForwardBaseSubGraphOptions } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/ForwardBaseSubGraph';
	export { default as ForwardBaseRG } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/ForwardBaseRG';
	export { default as DebugRG } from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/DebugRG';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/render-graph/internal/shared';
	export * from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/interface';
	export { version, workerVersion, VERSION as KANATA_VERSION, device, settings, adaptation, userCrossContextDataBus as crossContextDataBus, IEngineSettings, renderEnv, ICrossContextDataBus, Animation, AnimationUtility, AnimationClip, RawResourceCollection, Animator, AnimatorController, Avatar, AvatarMask, BaseResource, BuildInTextures, TimelineAsset, TimelineClip, AudioClip, TrackAsset, TimelineClipAsset, Camera, UICamera, Color, LinearGradient, Component, DirectionalLight, PointLight, SpotLight, Debug, Effect, Entity, FrameSystem, FrameSystemMode, Game, GradientColor, HermiteCurve, KeyboardInputComponent, Material, Matrix3, Matrix4, Mesh, MeshRenderer, EMeshCullType, NativeBufferReader, Particle, Prefab, Quaternion, Raycaster, BoundBall, Rect, IRenderTextureOptions, RenderTexture, Scene, Script, ScriptableAsset, SerializeHelper, Serialize, Skeleton, SkinnedAnimationRenderer, SkinnedMeshRenderer, LineRenderer, TrailRenderer, PlayableDirector, AudioSource, AudioListener, AudioHighPassFilter, AudioLowPassFilter, AudioDistortion, AudioEcho, Audio, AudioMixerAsset, AudioMixer, AudioMixerGroup, AudioMixerSnapshot, LODGroup, SpriteFrame, Texture2D, TextureCube, Font, BitmapFont, RawResource, Atlas, TouchInputComponent, Transform2D, Transform3D, TransformBase, PostProcessAsset, BlendType, Canvas2D, UIAnchor, UIButton, UICanvas, UIGraphic, UIGrid, UILabel, TextAlign, TextVAlign, TextRenderMode, TypeNames, UIMask, UIRichText, UIScrollView, UISprite, UITextInput, UIToggle, UIToggleGroup, UIWidget, UILayer, UIMesh, OpenDataContainer, Vector2, Vector3, Vector3_READONLY, Vector4, BooleanVector3, buildin2DVertexLayout, buildInVertexLayoutFactory3D, decorators, executeInGameMode, executeInEditMode, executeInAllMode, Loader, Gizmos, GizmoMaterials, Touchable, Delegate, ComplexJSONMap, NumberJSONMap, createNativeUUMap, createNativeSUMap, createNativeULUMap, MaterialEventType, MeshEventType, BoundsChangeEventType, ChildChangeEventType, LightEventType, Renderable2DEventType, MeshRendererEventType, OpenData, PipeLineEventType, EngineWorker as Worker, WorkerJob, EWorkerStatus, EWorkerJobStatus, WorkerSystem, Rigidbody, RaycastHit, Collider, BoxCollider, SphereCollider, CapsuleCollider, MeshCollider, ForceMode, CombineMode, RigidbodyConstraints, CollisionDetectionMode, PhysMeshCookingFlag, QueryTriggerInteraction, CollisionFlags, ColliderType, PhysicMaterial, CapsuleColliderDirection, CharacterController, ICollision as Collision, ITriggerCollision as TriggerCollision, IControllerColliderHit as ControllerColliderHit, Bounds, ReadonlyBounds, ContactPoint, PhysicsDelegate, PhysicsDelegateHandler, LitePromise, wxRemote, Schema, ObjReader, ArrayReader, UnionReader, ScriptPlayable, PlayableBehaviour, PlayableGraph, Playable, StreamingLoadingComponent, ILoadTask as LoadTask, PhysicsSystem, StreamingLoadingSystem };
	export let canvas: HTMLCanvasElement;
	export let renderer: RenderSystem;
	export let loader: Loader;
	export let timer: Timer;
	export let cache: CacheManager;
	export const TextureFilterMode: typeof TextureFilterModeEnum;
	export const TextureWrapMode: typeof Kanata.EWrapMode;
	export const Environment: typeof EnvironmentEnum;
	export const Platform: typeof PlatformEnum;
	export const GroupPlatform: typeof GroupPlatformEnum;
	export const AmbientMode: typeof AmbientModeEnum;
	export const FogMode: typeof FogModeEnum;
	export const WrapMode: typeof WrapModeEnum;
	export type TouchInputEvent = internalTouchInputEvent;
	export type Entity2D = internalEntity2D;
	export type Entity3D = internalEntity3D;
	export let game: Game;
	export let gctx: typeof InternalGctx | undefined;
	export let EnumVertexFormat: typeof Kanata.EVertexFormat | undefined;
	export let EnumUniformType: typeof Kanata.EUniformType | undefined;
	export let lanDebugHost: {
	    ip: string;
	    port: number;
	} | undefined;
	export let host: string;
	export function setGlobalFloat(key: string, value: number): void;
	export function getGlobalFloat(key: string): number | undefined;
	export function setGlobalVector(key: string, value: Vector2 | Vector3 | Vector4): void;
	export function getGlobalVector(key: string): Vector2 | Vector3 | Vector4 | undefined;
	export function setGlobalMatrix(key: string, value: Matrix3 | Matrix4): void;
	export function getGlobalMatrix(key: string): Matrix3 | Matrix4 | undefined;
	export function setGlobalTexture(key: string, value: Texture): void;
	export function getGlobalTexture(key: string): Texture | undefined;
	/**
	 * @deprecated
	 */
	export function init(): void;

}
declare module 'engine' {
	import * as engine from 'engine';
	export default engine;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：global' {
	interface Global {
	    WeakRef?: new <T>(arg: T) => {
	        deref(): T | undefined;
	    };
	    FinalizationGroup?: new <S, R>(arg: (arg: IterableIterator<S>) => void) => {
	        register<T, R>(instance: T, held: S, token?: R): void;
	        unregister(token: R): void;
	    };
	    FinalizationRegistry?: new <S, R>(arg: (arg: S) => void) => {
	        register<T, R>(instance: T, held: S, token?: R): void;
	        unregister(token: R): void;
	    };
	    IDE_ENGINEIDE_LOCATION?: string;
	    IDE_SIMULATOR_RECORDING_FLAG?: boolean;
	    engine?: (typeof import('engine').default & {
	        default?: typeof import('engine').default;
	    });
	} const g: Global;
	export default g;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/compile' {
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/deserialize/compiled.editor' {
	export const DeserializeFailFlag: any;
	export default function Deserialize(json: any, result: any, context: any, builtContext: any): any;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/game/inspect' {
	import LoadContext from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/load-context/game';
	export interface LoadContextInspect {
	    files: {
	        [relativePath: string]: {
	            path: string;
	            exist: boolean;
	        };
	    };
	    assets: {
	        [assetID: string]: {
	            exist: boolean;
	            weak: "strong" | "weak";
	        };
	    };
	    error?: string;
	}
	export default function inspect(this: LoadContext): LoadContextInspect;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UIFrameAnimation' {
	import SpriteFrame from '!!Only Export Engine Module, Cant Use Internal Module：engine/assets/classes/spriteFrame';
	import UISprite from '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/UISprite';
	/**
	 * 帧动画
	 * 内部UI组件，暂未对外使用
	 */
	export default class UIFrameAnimation extends UISprite {
	    /**
	     * 帧数组
	     *
	     * @type {SpriteFrame[]}
	     * @memberof UIFrameAnimation
	     */
	    get frames(): SpriteFrame[];
	    set frames(val: SpriteFrame[]);
	    /**
	     * 一秒几帧
	     *
	     * @type {number}
	     * @memberof UIFrameAnimation
	     */
	    get rate(): number;
	    set rate(val: number);
	    /**
	     * 是否循环播放
	     *
	     * @type {boolean}
	     * @memberof UIFrameAnimation
	     */
	    get loop(): boolean;
	    set loop(val: boolean);
	    /**
	     * 载入一批已经加载好的texture
	     *
	     * @param {string[]} ids
	     * @memberof UIFrameAnimation
	     */
	    loadTextures(ids: string[]): void;
	    /**
	     * 载入一批已经加载好的spriteFrame
	     *
	     * @param {string[]} ids
	     * @memberof UIFrameAnimation
	     */
	    loadSpriteFrames(ids: string[]): void;
	    /**
	     * 帧动画开始
	     *
	     * @memberof UIFrameAnimation
	     */
	    start(): void;
	    /**
	     * 帧动画停止
	     *
	     * @memberof UIFrameAnimation
	     */
	    stop(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/2D/base/DataUtility' {
	/**
	 *
	 * 二维渲染数据构造器
	 * @export
	 * @interface DataUtility
	 */
	export interface DataUtility {
	    [key: string]: any;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/particles/libs/bezierCurve' {
	import { SmartArray } from '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/array';
	interface IPoint {
	    x: number;
	    y: number;
	}
	/**
	 * 贝塞尔曲线
	 */
	export default class BezierCurve {
	    /**
	     * @param data data: number[], x1,y1,x2,y2,...
	     */
	    static Deserialize(list: number[], curve: BezierCurve, context: {
	        [key: string]: any[];
	    }, builtContext: {
	        [key: string]: SmartArray<any>;
	    }): BezierCurve;
	    static factorial(num: number): number;
	    points: IPoint[];
	    setPoints(points: IPoint[]): void;
	    addPoint(point: IPoint): void;
	    get(t: number): IPoint;
	}
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/game/physics/PhysPhysicsWord' {
	/**
	 * PhysPhysicsWord.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 5/20/2021, 7:00:45 PM
	*/
	export default class PhysPhysicsWord {
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/helper/common' {
	export const UniqueColorLightMode = "__IDE__ForwardBaseUniqueColor";
	export const IdeUniqueColorNameUniform = "u_ide_unique_mesh_color";

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/math/curve' {
	import { DeepImmutable, Nullable } from '!!Only Export Engine Module, Cant Use Internal Module：engine/type';
	export interface IKeyFrame {
	    index: number;
	    inTangent: number;
	    outTangent: number;
	    value: number;
	}
	export enum CurveMode {
	    Hermite = 0
	}
	export class Curve {
	    readonly keyFrames: IKeyFrame[];
	    fps: number;
	    frameCount: number;
	    mode: CurveMode;
	    readonly precision: number;
	    constructor(keyFrames: IKeyFrame[], fps: number, frameCount: number, mode?: CurveMode, precision?: number);
	    evaluate(index: number, blendForLoop?: boolean): Nullable<number>;
	    get keyCount(): number;
	    addKeyFraem(keyFrame: IKeyFrame): void;
	}
	export interface ITransformCurveEvaluateValue {
	    tx: Nullable<number>;
	    ty: Nullable<number>;
	    tz: Nullable<number>;
	    sx: Nullable<number>;
	    sy: Nullable<number>;
	    sz: Nullable<number>;
	    rx: Nullable<number>;
	    ry: Nullable<number>;
	    rz: Nullable<number>;
	    rw: Nullable<number>;
	}
	export enum TransformCurveType {
	    TranslateX = 1,
	    TranslateY = 2,
	    TranslateZ = 3,
	    ScaleX = 4,
	    ScaleY = 5,
	    ScaleZ = 6,
	    QuaternionX = 7,
	    QuaternionY = 8,
	    QuaternionZ = 9,
	    QuaternionW = 10,
	    EulerX = 11,
	    EulerY = 12,
	    EulerZ = 13
	}
	export enum TransformCurveRotationMode {
	    None = 0,
	    Euler = 1,
	    Quaternion = 2
	}
	export class TransformCurve {
	    readonly fps: number;
	    frameLength: number;
	    mode: CurveMode;
	    readonly precision: number;
	    static TransformCurveRotationMode: typeof TransformCurveRotationMode;
	    static TransformCurveType: typeof TransformCurveType;
	    get rotationMode(): TransformCurveRotationMode;
	    constructor(fps: number, frameLength: number, mode?: CurveMode, precision?: number);
	    addKeyFrame(value: IKeyFrame, type: TransformCurveType): void;
	    evaluate(frameIndex: number): DeepImmutable<ITransformCurveEvaluateValue>;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/collisionMatrixUtils' {
	/**
	 * @file 从settings里读取物理collision matrix
	 */
	export function decodeCollisionMatrixString(str: string): ArrayBuffer;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/finalizationRegistry' {
	export class EngineFinalizationRegistry<S, T> {
	    constructor(onGC: (info: T) => void);
	    register(instance: S, info: T): void;
	    unregister(instance: S): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/hash' {
	export function strToHashTime33(str: string): number;
	export function arrayToHashTime33(arr: ArrayLike<number>): number;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/list' {
	export interface ILinkedListNode<T> {
	    element: T;
	    next: ILinkedListNode<T> | null;
	}
	/**
	 * Function signature for comparing
	 * <0 means a is smaller
	 * = 0 means they are equal
	 * >0 means a is larger
	 */
	export interface ICompareFunction<T> {
	    (a: T, b: T): number;
	}
	/**
	 * Function signature for checking equality
	 */
	export interface IEqualsFunction<T> {
	    (a: T, b: T): boolean;
	}
	/**
	 * Function signature for Iterations. Return false to break from loop
	 */
	export interface ILoopFunction<T> {
	    (a: T): boolean | void;
	}
	/**
	 * Default function to compare element order.
	 * @function
	 */
	export function defaultCompare<T>(a: T, b: T): number;
	/**
	 * Default function to test equality.
	 * @function
	 */
	export function defaultEquals<T>(a: T, b: T): boolean;
	export class LinkedList<T> {
	    /**
	     * First node in the list
	     * @type {Object}
	     * @private
	     */
	    firstNode: ILinkedListNode<T> | null;
	    /**
	     * Creates an empty Linked List.
	     * @class A linked list is a data structure consisting of a group of nodes
	     * which together represent a sequence.
	     * @constructor
	     */
	    constructor();
	    /**
	     * Adds an element to this list.
	     * @param {Object} item element to be added.
	     * @param {number=} index optional index to add the element. If no index is specified
	     * the element is added to the end of this list.
	     * @return {boolean} true if the element was added or false if the index is invalid
	     * or if the element is undefined.
	     */
	    add(item: T, index?: number): boolean;
	    /**
	     * Returns the first element in this list.
	     * @return {*} the first element of the list or undefined if the list is
	     * empty.
	     */
	    first(): T | undefined;
	    /**
	     * Returns the last element in this list.
	     * @return {*} the last element in the list or undefined if the list is
	     * empty.
	     */
	    last(): T | undefined;
	    /**
	     * Returns the element at the specified position in this list.
	     * @param {number} index desired index.
	     * @return {*} the element at the given index or undefined if the index is
	     * out of bounds.
	     */
	    elementAtIndex(index: number): T | undefined;
	    /**
	     * Returns the index in this list of the first occurrence of the
	     * specified element, or -1 if the List does not contain this element.
	     * <p>If the elements inside this list are
	     * not comparable with the === operator a custom equals function should be
	     * provided to perform searches, the function must receive two arguments and
	     * return true if they are equal, false otherwise. Example:</p>
	     *
	     * <pre>
	     * const petsAreEqualByName = function(pet1, pet2) {
	     *  return pet1.name === pet2.name;
	     * }
	     * </pre>
	     * @param {Object} item element to search for.
	     * @param {function(Object,Object):boolean=} equalsFunction Optional
	     * function used to check if two elements are equal.
	     * @return {number} the index in this list of the first occurrence
	     * of the specified element, or -1 if this list does not contain the
	     * element.
	     */
	    indexOf(item: T, equalsFunction?: IEqualsFunction<T>): number;
	    /**
	     * Returns true if this list contains the specified element.
	     * <p>If the elements inside the list are
	     * not comparable with the === operator a custom equals function should be
	     * provided to perform searches, the function must receive two arguments and
	     * return true if they are equal, false otherwise. Example:</p>
	     *
	     * <pre>
	     * const petsAreEqualByName = function(pet1, pet2) {
	     *  return pet1.name === pet2.name;
	     * }
	     * </pre>
	     * @param {Object} item element to search for.
	     * @param {function(Object,Object):boolean=} equalsFunction Optional
	     * function used to check if two elements are equal.
	     * @return {boolean} true if this list contains the specified element, false
	     * otherwise.
	     */
	    contains(item: T, equalsFunction?: IEqualsFunction<T>): boolean;
	    /**
	     * Removes the first occurrence of the specified element in this list.
	     * <p>If the elements inside the list are
	     * not comparable with the === operator a custom equals function should be
	     * provided to perform searches, the function must receive two arguments and
	     * return true if they are equal, false otherwise. Example:</p>
	     *
	     * <pre>
	     * const petsAreEqualByName = function(pet1, pet2) {
	     *  return pet1.name === pet2.name;
	     * }
	     * </pre>
	     * @param {Object} item element to be removed from this list, if present.
	     * @return {boolean} true if the list contained the specified element.
	     */
	    remove(item: T, equalsFunction?: IEqualsFunction<T>): boolean;
	    /**
	     * Removes all of the elements from this list.
	     */
	    clear(): void;
	    /**
	     * Returns true if this list is equal to the given list.
	     * Two lists are equal if they have the same elements in the same order.
	     * @param {LinkedList} other the other list.
	     * @param {function(Object,Object):boolean=} equalsFunction optional
	     * function used to check if two elements are equal. If the elements in the lists
	     * are custom objects you should provide a function, otherwise
	     * the === operator is used to check equality between elements.
	     * @return {boolean} true if this list is equal to the given list.
	     */
	    equals(other: any, equalsFunction?: IEqualsFunction<T>): boolean;
	    /**
	     * Removes the element at the specified position in this list.
	     * @param {number} index given index.
	     * @return {*} removed element or undefined if the index is out of bounds.
	     */
	    removeElementAtIndex(index: number): T | undefined;
	    /**
	     * Executes the provided function once for each element present in this list in order.
	     * @param {function(Object):*} callback function to execute, it is
	     * invoked with one argument: the element value, to break the iteration you can
	     * optionally return false.
	     */
	    forEach(callback: ILoopFunction<T>): void;
	    /**
	     * Reverses the order of the elements in this linked list (makes the last
	     * element first, and the first element last).
	     */
	    reverse(): void;
	    /**
	     * Returns an array containing all of the elements in this list in proper
	     * sequence.
	     * @return {Array.<*>} an array containing all of the elements in this list,
	     * in proper sequence.
	     */
	    toArray(): T[];
	    /**
	     * Returns the number of elements in this list.
	     * @return {number} the number of elements in this list.
	     */
	    size(): number;
	    /**
	     * Returns true if this list contains no elements.
	     * @return {boolean} true if this list contains no elements.
	     */
	    isEmpty(): boolean;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/misc/string' {
	export function upperFirst(s: string): string;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/buffer/debugPrinter' {
	import { Reader } from '!!Only Export Engine Module, Cant Use Internal Module：engine/worker/buffer/reader';
	export function debugPrint(r: Reader, indent?: number): void;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/bufferAllocator' {
	export default class BufferAllocator {
	    get buffer(): ArrayBuffer;
	    constructor(buffer: ArrayBuffer);
	    allocate(acLength: number): {
	        offset: number;
	        bufferName: string;
	    } | null;
	    dispose(offset: number, acLength: number): true | null;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：lib/utils/internalGetter' {
	export default class InternalGetter<T_KEY extends object, T_VAL extends object> {
	    constructor(defaultFactory: (key: T_KEY) => T_VAL);
	    get(key: T_KEY): T_VAL;
	    setInternalFactory(key: T_KEY, factory: () => T_VAL): void;
	    delete(key: T_KEY): void;
	}

}
interface Window {
	  WeakRef?: new (arg: any) => any;
	  FinalizationGroup?: new <S, R>(arg: (arg: IterableIterator<S>) => void) => { register<T, R>(instance: T, held: S, token?: R): void; unregister(token: R): void };
	  FinalizationRegistry?: new <S, R>(arg: (arg: S) => void) => { register<T, R>(instance: T, held: S, token?: R): void; unregister(token: R): void };
	  IDE_ENGINEIDE_LOCATION?: string;
		IDE_SIMULATOR_RECORDING_FLAG?: boolean,
		IDE_HTTP2_PORT: number;
	}

	declare function requireScript(path: string): any;
	declare const engine: (
	  typeof import('engine').default &
	  { default?: typeof import('engine').default }
	);
declare namespace phys3D {
	  // pvd调试配置
	  export interface physicsDebugConfig {
	    isNetwork: boolean; // 采用网络的方式
	    ip?: string; // 如果isNetwork为true，调试信息会通过tcp转发的方式转发到打开了pvd调试软件的电脑，需要注意的是，防火墙要对pvd打开
	    port?: 5425; // pvd默认接口
	    timeout?: 1000; // 默认耗时
	    path?: string; // 如果isNetwork为false，调试信息会通过写本地文件的方式落地，文件名建议为xxx.pxd2，导入pvd调试即可
	}

	  export enum QueryTriggerInteraction {
	    UseGlobal = 0,
	    Ignore =  1,
	    Collide =  2
	  }

	  export class PhysSystem {
	    constructor(config?: physicsDebugConfig);
	    gravity: RawVec3f;
	    bounceThreshold: number;
	    defaultMaxAngularSpeed: number;
	    defaultSolverIterations: number;
	    defaultSolverVelocityIterations: number;
	    sleepThreshold: number;
	    defaultContactOffset: number;
	    destroyScene: () => void;
	    createScene: () => number;
	    Simulate: (step: number) => void;
	    SyncFromTransforms: (() => void) | undefined; // added in 2021.06
	    SetCollisionMask: (mask: ArrayBuffer) => void;
	    Raycast: (origin: RawVec3f, unitDir: RawVec3f, distance: number, hit: RaycastHit, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction) => boolean;
	    RaycastAll: (origin: RawVec3f, unitDir: RawVec3f, distance: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction) => RaycastHit[];
	    CapsuleCast(p1: RawVec3f, p2: RawVec3f, radius: number, direction: RawVec3f, hit: RaycastHit, maxDistance: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction);
	    CapsuleCastAll: (p1: RawVec3f, p2: RawVec3f, radius: number, direction: RawVec3f, maxDistance: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction) => RaycastHit[];
	    BoxCast(center: RawVec3f, halfExt: RawVec3f, direction: RawVec3f, hit: RaycastHit, orientation: RawQuaternion, maxDistance: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction);
	    BoxCastAll: (center: RawVec3f, halfExt: RawVec3f, direction: RawVec3f, orientation: RawQuaternion, maxDistance: number, layerMask?: number, queryTriggerInteraction?: QueryTriggerInteraction) => RaycastHit[];
	    OverlapBox: (center: RawVec3f, halfExt: RawVec3f, orientation: RawQuaternion, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction) => Collider[];
	    OverlapCapsule: (p1: RawVec3f, p2: RawVec3f, radius: number, layermask?: number, queryTriggerInteraction?: QueryTriggerInteraction) => Collider[];
	  }

	  export class Rigidbody {
	    constructor(system: PhysSystem);
	    enabled?: boolean; // since 2021.06
	    position: RawVec3f;
	    rotation: RawQuaternion;
	    AttachToEntity: (pollObj: any, id: number) => void;
	    Remove();
	    Detach();
	    IsAttached(): boolean;
	  }

	  export enum CollisionDetectionMode {
	    Discrete = 0,
	    Continuous = 1,
	    ContinuousDynamic = 2,
	    ContinuousSpeculative = 3
	  }

	  export enum RigidbodyConstraints {
	    None = 0,
	    FreezePositionX = (1 << 0),
	    FreezePositionY = (1 << 1),
	    FreezePositionZ = (1 << 2),
	    FreezeRotationX = (1 << 3),
	    FreezeRotationY = (1 << 4),
	    FreezeRotationZ = (1 << 5),
	    FreezePosition = (FreezePositionX | FreezePositionY | FreezePositionZ),
	    FreezeRotation = (FreezeRotationX | FreezeRotationY | FreezeRotationZ),
	    FreezeAll = (FreezePosition | FreezeRotation)
	  }

	  export enum ForceMode {
	    kForceModeForce = 0,
	    kForceModeImpulse = (1 << 0),
	    kForceModeVelocityChange = (1 << 1),
	    kForceModeAcceleration = (1 << 2)
	  }

	  export enum CombineMode {
	    eAverage = 0,
	    eMin,
	    eMultiply,
	    eMax
	  }

	  export enum CookingFlag {
	    None = 0,
	    CookForFasterSimulation = 1 << 0,
	    EnableMeshCleaning = 1 << 1,
	    WeldColocatedVertices = 1 << 2
	  }

	  export enum CollisionFlags {
	    None = 0,
	    Sides = 1 << 0,
	    Above = 1 << 1,
	    Below = 1 << 2
	  }

	  export class RawVec3f {
	    constructor();
	    constructor(x: number, y: number, z: number);
	    x: number;
	    y: number;
	    z: number;
	  }

	  export class RawQuaternion {
	    constructor();
	    constructor(x: number, y: number, z: number, w: number);
	    x: number;
	    y: number;
	    z: number;
	    w: number;
	  }

	  export class Collider {
	    attachedRigidbody: Rigidbody;
	    bounds: Bounds;
	    name: string;
	    contactOffset: number;
	    enabled: boolean;
	    isTrigger: boolean;
	    scale    : RawVec3f;
	    material?: Material;
	    sharedMateiral?: Material;
	    ClosestPoint: (RawVec3f) => RawVec3f;
	    ClosestPointOnBounds: (RawVec3f) => RawVec3f;

	    onCollisionEnter?: (collision: Collision) => void;
	    onCollisionExit?: (collision: Collision) => void;
	    onCollisionStay?: (collision: Collision) => void;
	    onTriggerEnter?: (collision: Collision) => void;
	    onTriggerExit?: (collision: Collision) => void;
	    onTriggerStay?: (collision: Collision) => void;

	    dettachRigidbody?: () => void;

	    userData?: Object | null;
	    layer: number;
	  }

	  export class BoxCollider extends Collider {
	    constructor(system: PhysSystem, center: RawVec3f, size: RawVec3f);
	    center: RawVec3f;
	    size: RawVec3f;
	  }

	  export class SphereCollider extends Collider {
	    constructor(system: PhysSystem, center: RawVec3f, radius: number);
	    center: RawVec3f;
	    radius: number;
	  }

	  export class CapsuleCollider extends Collider {
	    constructor(system: PhysSystem, center: RawVec3f, height: number, radius: number);
	    center: RawVec3f;
	    height: number;
	    radius: number;
	  }

	  export class MeshCollider extends Collider {
	    constructor(system: PhysSystem, convex: boolean, cookingOptions: number, sharedMesh: PhysMesh);
	    cookingOptions: number;
	    sharedMesh: PhysMesh | null;
	    convex: boolean;
	  }

	      
	  export class CharacterController extends Collider {
	    constructor(system: PhysSystem);
	    position: RawVec3f;
	    center: RawVec3f;
	    collisionFlags: CollisionFlags;
	    detectCollisions: boolean;
	    enableOverlapRecovery: boolean;
	    height: number;
	    isGrounded: boolean;
	    minMoveDistance: number;
	    radius: number;
	    skinWidth: number;
	    slopeLimit: number;
	    stepOffset: number;
	    velocity: RawVec3f;

	    Move: (movement: RawVec3f) => CollisionFlags;
	    SimpleMove: (speed: RawVec3f) => boolean;
	    AttachToEntity: (pollObj: any, id: number) => void;

	    OnControllerColliderHit?: (hit: ControllerColliderHit) => void;
	  }

	  export interface ContactPoint {
	    normal: RawVec3f;
	    this_collider: Collider;
	    other_collider: Collider;
	    point: RawVec3f;
	    separation: number;
	  }

	  export interface Collision {
	    collider: Collider;
	    contacts: Array<ContactPoint>;
	    impulse: RawVec3f;
	    relative_velocity: RawVec3f;
	  }

	  export interface ControllerColliderHit {
	    collider: Collider;
	    controller: CharacterController;
	    moveDirection: RawVec3f;
	    normal: RawVec3f;
	    moveLength: number;
	    point: RawVec3f;
	  }

	  export class Bounds {
	    constructor(center: RawVec3f, size: RawVec3f);

	    center: RawVec3f;
	    extents: RawVec3f;
	    max: RawVec3f;
	    min: RawVec3f;
	    size: RawVec3f;

	    ClosestPoint: (point: RawVec3f) => RawVec3f;
	    Contains: (point: RawVec3f) => boolean;
	    Expand: (amount: number) => void;
	    Intersects: (bounds: Bounds) => boolean;
	    SetMinMax: (min: RawVec3f, max: RawVec3f) => void;
	    SqrDistance: (point: RawVec3f) => number;
	  }

	  export class Material {
	    constructor(system: PhysSystem);
	    dynamicFriction: number;
	    staticFriction: number;
	    bounciness: number;
	    frictionCombine: CombineMode;
	    bounceCombine: CombineMode;
	    id: Number;
	  }

	  export class DynamicRigidbody extends Rigidbody {
	    mass: number;
	    angularDamping: number;
	    angularVelocity: RawVec3f;
	    centerOfMass: RawVec3f;
	    collisionDetectionMode: CollisionDetectionMode;
	    constraints: number;
	    detectCollisions: boolean;
	    linearDamping: number;
	    freezeRotation: boolean;
	    inertiaTensor: number;
	    // inertiaTensorRotation
	    // interpolation
	    isKinematic: boolean;
	    maxAngularVelocity: number;
	    maxDepenetrationVelocity: number;
	    sleepThreshold: number;
	    solverIterations: number;
	    solverVelocityIterations: number;
	    useGravity: boolean;
	    velocity: RawVec3f;
	    userData?: Object | null;

	    GetWorldCenterOfMass: () => RawVec3f;
	    AddForce: (force: RawVec3f, mode: ForceMode) => void;
	    AddTorque: (torque: RawVec3f, mode: ForceMode) => void;
	    IsSleeping: () => boolean;
	    Sleep: () => void;
	    WakeUp: () => void;
	    AddExplosionForce: (explosionForce: number, explosionPosition: RawVec3f,
	        explosionRadius: number, upwardsModifier: number, mode: ForceMode) => void;
	    AddForceAtPosition: (force: RawVec3f, position: RawVec3f, mode: ForceMode) => void;
	    AddRelativeForce: (force: RawVec3f, mode: ForceMode) => void;
	    AddRelativeTorque: (torque: RawVec3f, mode: ForceMode) => void;
	    ClosestPointOnBounds: (position: RawVec3f) => RawVec3f;
	    GetPointVelocity: (worldPoint: RawVec3f) => RawVec3f;
	    GetRelativePointVelocity: (relativePoint: RawVec3f) => RawVec3f;
	    MovePosition: (position: RawVec3f) => void;
	    MoveRotation: (rotation: RawQuaternion) => void;
	    ResetCenterOfMass: () => void;
	    ResetInertiaTensor: () => void;
	    SetDensity: (density: number) => void;
	    // SweepTest: () => void;
	    // SweepTestAll: () => void;
	  }

	  export class PhysMesh {
	    constructor(system: PhysSystem);
	    // set vertices
	    SetVertices: (buffer: Float32Array, count: number) => void;
	    // set indices
	    SetTriangles: (buffer: Uint16Array | Uint32Array, count: number, useUint16: boolean) => void;
	  }

	  export class RaycastHit {
	    constructor();
	    collider: Collider;
	    distance: number;
	    normal: RawVec3f;
	    point: RawVec3f;
	    rigidbody: Rigidbody;
	  }
	}declare namespace pluginEnv {
	  class XLogManager {
	    log: (message?: any, ...optionalParams: any[]) => void;
	    info: (message?: any, ...optionalParams: any[]) => void;
	    warn: (message?: any, ...optionalParams: any[]) => void;
	    error: (message?: any, ...optionalParams: any[]) => void;
	  }
	  function getXLogManager(): XLogManager;
	  type PlainCallback = (response: { errMsg: string }) => void; 
	  interface KVData {
	    key: string;
	    value: string;
	  }
	  interface UserGameData {
	    avatarUrl: string;
	    nickname: string;
	    openid: string;
	    KVDataList: KVData[];
	  }
	  function getUserInfo(argument: {
	    openIdList: string[];
	    lang: "en" | "zh_CN" | "zh_TW";
	    success?: (response: {
	      data: {
	        avatarUrl: string;
	        city: string;
	        country: string;
	        gender: number;
	        language: string;
	        nickName: string;
	        openId: string;
	        province: string;
	      }[];
	    }) => void;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  });
	  function getUserCloudStorage(argument: {
	    keyList: string[];
	    success?: (response: { KVDataList: KVData[] }) => void;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }): void;
	  function getFriendCloudStorage(argument: {
	    keyList: string[];
	    success?: (response: { data: UserGameData[] }) => void;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }): void;
	  function getGroupCloudStorage(argument: {
	    shareTicket: string;
	    keyList: string[];
	    success?: (response: { data: UserGameData[] }) => void;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }): void;
	  function getPotentialFriendList(argument: {
	    success?: (response: {
	      list: {
	        openid: string;
	        nickname: string;
	        avatarUrl: string;
	      }[];
	    }) => void;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }): void;
	  function getGroupInfo(argument: {
	    openGId: string;
	    success?: (response: {
	      name: string;
	    }) => void;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }): void;
	  function shareMessageToFriend(argument: {
	    openId: string;
	    title?: string;
	    imageUrl?: string;
	    imageUrlId?: string;
	    success?: PlainCallback;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }): void;
	  function getUserCloudStorageKeys(argument: {
	    success?: (response: {
	      keys: string[];
	    }) => void;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }): void;
	  function modifyFriendInteractiveStorage(argument: {
	    key: string;
	    opNum: number;
	    operation: "add";
	    toUser: string;
	    title: string;
	    imageUrl: string;
	    imageUrlId: string;
	    quiet: boolean;
	    success?: PlainCallback;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  })
	  export const platform: "devtools" | "android" | "ios" | "windows";
	  export const envVersion: "develop" | "trial" | "release";

	  //------since 2.17.0---------
	  function encode(argument: {
	    data: string;
	    format: "utf-8" | "gbk";
	  }): ArrayBuffer;
	  function decode(argument: {
	    data: ArrayBuffer;
	    format: "utf-8" | "gbk";
	  }): string;
	}/* eslint-disable @typescript-eslint/member-ordering */

	declare namespace wgfx {
	  export enum EnumFeature {
	    INSTANCING = 0,
	    TEXTURE_COMPRESSION_DXT = 1,
	    TEXTURE_COMPRESSION_PVRTC = 2,
	    TEXTURE_COMPRESSION_ATC = 3,
	    TEXTURE_COMPRESSION_ETC2 = 4,
	    TEXTURE_FLOAT = 5,
	    TEXTURE_HALF_FLOAT = 6,
	    ORIGIN_BOTTOM_LEFT = 7,
	    ORIGIN_TOP_LEFT = 8,
	    MSAA_RENDER_TARGETS = 9,
	    PACKED_VERTEX_FORMAT_10_2 = 10,
	    MULTIPLE_RENDER_TARGET = 11,
	    IMAGETYPE_3D = 12,
	    IMAGETYPE_ARRAY = 13,
	    TEXTURE_COMPRESSION_ETC1 = 14,
	    TEXTURE_COMPRESSION_ASTC_8x8 = 15,
	  }
	  // sg_usage
	  export enum EnumUsage {
	    IMMUTABLE = 1,
	    DYNAMIC = 2,
	    STREAM = 3
	  }

	  // sg_buffer_type
	  export enum EnumBufferType {
	    VERTEXBUFFER = 1,
	    INDEXBUFFER = 2
	  }
	  // sg_index_type
	  export enum EnumIndexType {
	    NONE = 1,
	    UINT16 = 2,
	    UINT32 = 3
	  }
	  // sg_image_type
	  export enum EnumImageType {
	    IMAGETYPE_2D = 1,
	    IMAGETYPE_CUBE = 2,
	    IMAGETYPE_3D = 3,
	    IMAGETYPE_ARRAY = 4
	  }
	  // sg_cube_face
	  export enum EnumCubeFace {
	    POS_X = 0,
	    NEG_X = 1,
	    POS_Y = 2,
	    NEG_Y = 3,
	    POS_Z = 4,
	    NEG_Z = 5,
	    NUM = 6
	  }
	  // sg_shader_stage
	  export enum EnumShaderStage {
	    VS = 0,
	    FS = 1
	  }

	  // sg_pixel_format
	  export enum EnumPixelFormat {
	    NONE = 1,
	    RGBA8 = 2,
	    RGB8 = 3,
	    RGBA4 = 4,
	    R5G6B5 = 5,
	    R5G5B5A1 = 6,
	    R10G10B10A2 = 7,
	    RGBA32F = 8,
	    RGBA16F = 9,
	    R32F = 10,
	    R16F = 11,
	    L8 = 12,
	    DXT1 = 13,
	    DXT3 = 14,
	    DXT5 = 15,
	    DEPTH = 16,
	    DEPTHSTENCIL = 17,
	    PVRTC2_RGB = 18,
	    PVRTC4_RGB = 19,
	    PVRTC2_RGBA = 20,
	    PVRTC4_RGBA = 21,
	    ETC2_RGB8 = 22,
	    ETC2_SRGB8 = 23,
	    ETC1_RGB8 = 24,
	    PIXELFORMAT_PVR_CCZ = 25,
	    PIXELFORMAT_PVR_GZ = 26,
	    PIXELFORMAT_ETC2_RGBA8 = 27,
	    ASTC = 28,
	  }
	  // sg_primitive_type
	  export enum EnumPrimitiveType {
	    POINTS = 1,
	    LINES = 2,
	    LINE_STRIP = 3,
	    TRIANGLES = 4,
	    TRIANGLE_STRIP = 5
	  }
	  // sg_filter
	  export enum EnumFilter {
	    NEAREST = 1,
	    LINEAR = 2,
	    NEAREST_MIPMAP_NEAREST = 3,
	    NEAREST_MIPMAP_LINEAR = 4,
	    LINEAR_MIPMAP_NEAREST = 5,
	    LINEAR_MIPMAP_LINEAR = 6
	  }
	  // sg_wrap
	  export enum EnumWrap {
	    REPEAT = 1,
	    CLAMP_TO_EDGE = 2,
	    MIRRORED_REPEAT = 3
	  }
	  // sg_vertex_format
	  export enum EnumVertexFormat {
	    INVALID = 0,
	    FLOAT = 1,
	    FLOAT2 = 2,
	    FLOAT3 = 3,
	    FLOAT4 = 4,
	    BYTE4 = 5,
	    BYTE4N = 6,
	    UBYTE4 = 7,
	    UBYTE4N = 8,
	    SHORT2 = 9,
	    SHORT2N = 10,
	    SHORT4 = 11,
	    SHORT4N = 12,
	    UINT10_N2 = 13
	  }
	  // sg_vertex_step
	  export enum EnumVertexStep {
	    PER_VERTEX = 1,
	    PER_INSTANCE = 2
	  }
	  // sg_uniform_type
	  export enum EnumUniformType {
	    INVALID = 0,
	    FLOAT = 1,
	    FLOAT2 = 2,
	    FLOAT3 = 3,
	    FLOAT4 = 4,
	    MAT4 = 5
	  }
	  // sg_cull_mode
	  export enum EnumCullMode {
	    NONE = 1,
	    FRONT = 2,
	    BACK = 3
	  }
	  // sg_face_winding
	  export enum EnumFaceWinding {
	    CCW = 1,
	    CW = 2
	  }
	  // sg_compare_func
	  export enum EnumCompareFunc {
	    NEVER = 1,
	    LESS = 2,
	    EQUAL = 3,
	    LESS_EQUAL = 4,
	    GREATER = 5,
	    NOT_EQUAL = 6,
	    GREATER_EQUAL = 7,
	    ALWAYS = 8
	  }
	  // sg_stencil_op
	  export enum EnumStencilOp {
	    KEEP = 1,
	    ZERO = 2,
	    REPLACE = 3,
	    INCR_CLAMP = 4,
	    DECR_CLAMP = 5,
	    INVERT = 6,
	    INCR_WRAP = 7,
	    DECR_WRAP = 8
	  }
	  // sg_blend_factor
	  export enum EnumBlendFactor {
	    ZERO = 1,
	    ONE = 2,
	    SRC_COLOR = 3,
	    ONE_MINUS_SRC_COLOR = 4,
	    SRC_ALPHA = 5,
	    ONE_MINUS_SRC_ALPHA = 6,
	    DST_COLOR = 7,
	    ONE_MINUS_DST_COLOR = 8,
	    DST_ALPHA = 9,
	    ONE_MINUS_DST_ALPHA = 10,
	    SRC_ALPHA_SATURATED = 11,
	    BLEND_COLOR = 12,
	    ONE_MINUS_BLEND_COLOR = 13,
	    BLEND_ALPHA = 14,
	    ONE_MINUS_BLEND_ALPHA = 15
	  }
	  // sg_blend_op
	  export enum EnumBlendOp {
	    ADD = 1,
	    SUBTRACT = 2,
	    REVERSE_SUBTRACT = 3
	  }
	  // sg_color_mask
	  export enum EnumColorMask {
	    NONE = 0x10 /* special value for 'all channels disabled */,
	    R = 1 << 0,
	    G = 1 << 1,
	    B = 1 << 2,
	    A = 1 << 3,
	    RGB = 0x7,
	    RGBA = 0xf
	  }

	  // sg_action
	  export enum EnumAction {
	    CLEAR = 1,
	    LOAD = 2,
	    DONTCARE = 3
	  }

	  export enum EnumPixelType {
	    UNSIGNED_BYTE = 0x1401,
	    FLOAT = 0x1406,
	    UNSIGNED_SHORT_5_6_5 = 0x8363,
	    UNSIGNED_SHORT_4_4_4_4 = 0x8033,
	    UNSIGNED_SHORT_5_5_5_1 = 0x8034,
	  }

	  export enum EnumResourceState {
	    INITIAL = 0,
	    ALLOC = 1,
	    VALID = 2,
	    FAILED = 3,
	    INVALID = 4,
	  }

	  /*
	    Buffer
	  */
	  interface BufferDesc {
	    type: EnumBufferType;
	    content?: ArrayBufferView;
	    usage?: EnumUsage;
	    size?: number;
	  }

	  /*
	    PassAction
	  */
	  interface ColorAttachmentAction {
	    action: EnumAction;
	    val: number[]/* float[4]*/;
	  }
	  interface DepthAttachmentAction {
	    action: EnumAction;
	    val: number/* float*/;
	  }
	  interface StencilAttachmentAction {
	    action: EnumAction;
	    val: number/* uint8*/;
	  }
	  interface PassActionDesc {
	    colors?: ColorAttachmentAction[];
	    depth?: DepthAttachmentAction;
	    stencil?: StencilAttachmentAction;
	  }

	  /*
	    Pass
	  */
	  interface AttachmentDesc {
	    image: Image;
	    slice?: number;
	  }
	  interface PassDesc {
	    color_attachments: AttachmentDesc[];
	    depth_stencil_attachment: AttachmentDesc;
	  }
	  /*
	    Image
	  */

	  interface ImageUpdateDesc {
	    content: {
	      subimage: (HTMLCanvasElement | HTMLImageElement | ArrayBufferView) /* CUBEFACE_NUM*/[] /* MAX_MIPMAPS*/[];
	    };
	    x?: number;
	    y?: number;
	    width?: number;
	    height?: number;
	    // add additional
	    unpack_premultiply_alpha?: boolean;
	  }
	  interface ImageDesc {
	    type?: EnumImageType;
	    render_target?: boolean;
	    width?: number;
	    height?: number;
	    num_mipmaps?: number;
	    usage?: EnumUsage;
	    pixel_format?: EnumPixelFormat;
	    sample_count?: number;
	    min_filter?: EnumFilter;
	    mag_filter?: EnumFilter;
	    wrap_u?: EnumWrap;
	    wrap_v?: EnumWrap;
	    wrap_w?: EnumWrap;
	    max_anisotropy?: number;
	    min_lod?: number;
	    max_lod?: number;
	    content?: {
	      subimage: (HTMLImageElement | HTMLCanvasElement | ArrayBufferView) /* CUBEFACE_NUM*/[] /* MAX_MIPMAPS*/[];
	    };
	    // add additional
	    unpack_premultiply_alpha?: boolean;
	    generate_mipmaps?: boolean;
	  }

	  /*
	    Shader
	  */
	  interface ShaderImageDesc {
	    name: string;
	    type: EnumImageType;
	  }
	  interface ShaderUniformDesc {
	    name: string;
	    type: EnumUniformType;
	    array_count?: number;
	  }
	  interface ShaderUniformBlockDesc {
	    size: number;
	    uniforms: ShaderUniformDesc[];
	  }
	  interface ShaderStageDesc {
	    uniform_blocks?: ShaderUniformBlockDesc[];
	    source: string;
	    images?: ShaderImageDesc[];
	  }
	  interface ShaderDesc {
	    binary?: GfxNativeBuffer;
	    vs: ShaderStageDesc;
	    fs: ShaderStageDesc;
	  }
	  type PipelineDesc = any;
	  type BindingsDesc = any;
	  interface GfxNativeBuffer {
	    data: ArrayBuffer;
	    id: number;
	  }

	  interface FontTextureInfo {
	    image: Image;
	    w: number;
	    h: number;
	    tx: number;
	    ty: number;
	    tw: number;
	    th: number;
	  }

	  class RenderingContext {
	    createNativeBuffer(sizeOrContent: (number | ArrayBufferView)): GfxNativeBuffer;
	    makeBuffer(desc: BufferDesc): Buffer;
	    makePassAction(desc: PassActionDesc): PassAction;
	    makePass(desc: PassDesc): Pass;
	    makeImage(desc: ImageDesc): Image;
	    makeShader(desc: ShaderDesc): Shader;
	    makePipeline(desc: PipelineDesc): Pipeline;
	    makeBindings(desc: BindingsDesc): Bindings;

	    // 这里和sokol_gfx原来的接口比有改动，为实现局部更新Buffer和Image
	    updateBuffer(buffer: Buffer, dstOffset: number, content: ArrayBufferView | GfxNativeBuffer, srcOffset?: number, srcLength?: number): void;
	    updateImage(image: Image, desc: ImageUpdateDesc): void;

	    beginPass(pass: Pass, action: PassAction): void;
	    beginDefaultPass(action: PassAction, width: number, height: number): void;
	    applyPipeline(pipeline: Pipeline): void;
	    applyBindings(bindings: Bindings): void;
	    applyUniforms(shaderStage: EnumShaderStage, index: number, data: any): void;
	    draw(baseElement: number, numElements: number, numInstances: number): void;
	    endPass(): void;
	    commit(): void;
	    getPixels(x: number, y: number, width: number, height: number, format: EnumPixelFormat.RGBA8, type: EnumPixelType.UNSIGNED_BYTE): ArrayBuffer;
	    queryGlyphBitmapInfo?(text: string, font: string): FontTextureInfo | Array<FontTextureInfo>;
	    decodeImage?(image: string | ArrayBuffer, callback: (result: ArrayBuffer | number | undefined) => void, resultArrayBuffer?: ArrayBuffer);
	    queryFeature(feature: number): number;

	    queryPassState(pass: Pass): EnumResourceState;
	    queryBufferState(buffer: Buffer): EnumResourceState;
	    queryImageState(image: Image): EnumResourceState;
	    queryShaderState(shader: Shader): EnumResourceState;
	    queryPipelineState(pipeline: Pipeline): EnumResourceState;
	    queryShaderBinary?(shader: Shader): GfxNativeBuffer;

	    waitFenceSync?(type: number): void;

	    FENCE_SYNC_CLIENT_WAIT: number;
	  }
	  function setup(canvas: HTMLCanvasElement): void;
	  /*
	  bufferPoolSize?:number,
	  shaderPoolSize?:number,
	  imagePoolSize?:number,
	  pipelinePoolSize?:number,
	  passPoolSize?:number
	  */
	  class Pass {
	    id: number;
	    destroy(): void;
	  }
	  class PassAction { }
	  class Pipeline {
	    id: number;
	    destroy(): void;
	  }
	  class Buffer {
	    id: number;
	    destroy(): void;
	  }
	  class Shader {
	    id: number;
	    destroy(): void;
	  }
	  class Image {
	    id: number;
	    destroy(): void;
	  }
	  class Bindings { }
	}
declare module engineWX {
	  class Image extends HTMLImageElement {
	    premultiplyAlpha: boolean;
	  }
	  class Stats {
	    mode: string;
	    size: number;
	    lastAccessedTime: number;
	    lastModifiedTime: number;
	    isDirectory(): boolean;
	    isFile(): boolean;
	  }
	  class XLogManager {
	    log: (message?: any, ...optionalParams: any[]) => void;
	    info: (message?: any, ...optionalParams: any[]) => void;
	    warn: (message?: any, ...optionalParams: any[]) => void;
	    error: (message?: any, ...optionalParams: any[]) => void;
	  }
	  type DownloadTaskProgressCallback = (res: { progress: number; totalBytesWritten: number; totalBytesExpectedToWrite: number }) => void;
	  class DownloadTask {
	    onProgressUpdate(callback: DownloadTaskProgressCallback);
	    offProgressUpdate(callback: DownloadTaskProgressCallback);
	    abort(): void;
	  }

	  type StatsArray = { path: string, stats: Stats }[]
	  type PlainCallback = (response: { errMsg: string }) => void;
	  type FileSystemManager = {
	    mkdir(argument: {
	      dirPath: string;
	      recursive?: boolean;
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    rmdir(argument: {
	      dirPath: string;
	      recursive?: boolean;
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    saveFile(argument: {
	      tempFilePath: string;
	      filePath: string;
	      success?: (response: { savedFilePath: string }) => void;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    copyFile(argument: {
	      srcPath: string;
	      destPath: string;
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    readFile(argument: {
	      filePath: string;
	      encoding?: "binary" | "utf-8";
	      position?: number;
	      length?: number;
	      success?: (response: { data: string | ArrayBuffer }) => void;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    readFileSync(filePath: string, encoding?: "binary" | "utf-8"): string | ArrayBuffer;
	    writeFile(argument: {
	      filePath: string;
	      data: string | ArrayBuffer;
	      encoding?: "binary" | "utf-8";
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    writeFileSync(filePath: string, data: string | ArrayBuffer, encoding?: "binary" | "utf-8");
	    unlink(argument: {
	      filePath: string;
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    stat(argument: {
	      path: string;
	      recursive?: boolean;
	      success?: (response: { stats: Stats | StatsArray }) => void;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	  }

	  export const env: {
	    USER_DATA_PATH: string;
	  };

	  function getFileSystemManager(): FileSystemManager;
	  function getSystemInfoSync(): {
	    platform: "ios" | "android" | "devtools" | "windows";
	    screenWidth: number;
	    screenHeight: number;
	    pixelRatio: number;
	  };
	  function loadFont(path: string): string | null;
	  function encode(argument: {
	    data: string;
	    format: "utf-8" | "gbk";
	  }): ArrayBuffer;
	  function decode(argument: {
	    data: ArrayBuffer;
	    format: "utf-8" | "gbk";
	  }): string;
	  function createImage(): Image;
	  function createCanvas(): HTMLCanvasElement;
	  function createOffScreenCanvas(): HTMLCanvasElement;
	  function getXLogManager(): XLogManager;

	  type DownloadFileSuccCallback = (res: {
	    dataLength?: number;
	    errMsg: string;
	    header: { [key: string]: string };
	    statusCode: number;
	    tempFilePath?: string;
	    filePath?: string;
	  }) => void;
	  type DownloadFileOptions = {
	    url: string;
	    filePath?: string;
	    enableHttp2?: boolean;
	    success?: DownloadFileSuccCallback;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  };
	  function downloadFile(argument: DownloadFileOptions): DownloadTask;

	  type KeyboardEvent = {
	    value: string;
	  }

	  type ShowKeyboardArgument = {
	    defaultValue: string;
	    maxLength: number;
	    multiple: boolean;
	    confirmHold: boolean;
	    confirmType: "done" | "next" | "search" | "go" | "send";
	    success?: PlainCallback;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }

	  type UpdateKeyboardArgument = {
	    value: string;
	    success?: PlainCallback;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }

	  type HideKeyboardArgument = {
	    success?: PlainCallback;
	    fail?: PlainCallback;
	    complete?: PlainCallback;
	  }

	  type Worker = {
	    postMessage: (message: any) => void;
	    onMessage: (callback: (message: any) => void) => void;
	    terminate();
	  };

	  type SharedArrayBuffer = {
	    buffer: ArrayBuffer;
	    lock(callback: () => void): void;
	    unlock(): void;
	  };

	  class InnerAudioContext {
	    autoplay: boolean;
	    loop: boolean;
	    obeyMuteSwitch: boolean;
	    startTime: number;
	    volume: number;
	    playbackRate: number;
	    readonly duration: number;
	    readonly currentTime: number;
	    readonly paused: boolean;
	    readonly buffered: number;
	    src: string;
	    play(): void;
	    pause(): void;
	    stop(): void;
	    destroy(): void;
	    seek(v: number): void;
	    onCanplay(cb: Function): void;
	    offCanplay(cb: Function): void;
	    onPlay(cb: Function): void;
	    offPlay(cb: Function): void;
	    onPause(cb: Function): void;
	    offPause(cb: Function): void;
	    onStop(cb: Function): void;
	    offStop(cb: Function): void;
	    onEnded(cb: Function): void;
	    offEnded(cb: Function): void;
	    onTimeUpdate(cb: Function): void;
	    offTimeUpdate(cb: Function): void;
	    onError(cb: Function): void;
	    offError(cb: Function): void;
	    onWaiting(cb: Function): void;
	    offWaiting(cb: Function): void;
	    onSeeking(cb: Function): void;
	    offSeeking(cb: Function): void;
	    onSeeked(cb: Function): void;
	    offSeeked(cb: Function): void;
	  }

	  type SocketProfile = {
	    fetchStart: number
	    domainLookupStart: number
	    domainLookupEnd: number
	    connectStart: number
	    connectEnd: number
	    rtt: number
	    handshakeCost: number
	    cost: number
	  }

	  type SocketTask = {
	    send(argument: {
	      data: string | ArrayBuffer;
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    })
	    close(argument: {
	      code?: number;
	      reason?: string;
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    })
	    onClose: (callback: ({
	      code,
	      reason
	    }: {
	      code: number;
	      reason: string;
	    }) => void) => void;
	    onError: PlainCallback;
	    onMessage: (callback: (message: any) => void) => void;
	    onOpen: (callback: ({
	      header,
	      profile
	    }: {
	      header: any;
	      profile: SocketProfile;
	    }) => void) => void;
	  }

	  type CPUProfile = {
	    nodes: any[];
	    startTime: number;
	    endTime: number;
	    samples: number[];
	    timeDeltas: number[];
	  }

	  class WX {
	    env: {
	      USER_DATA_PATH: string;
	    };

	    getFileSystemManager(): FileSystemManager;
	    getSystemInfoSync(): {
	      platform: "ios" | "android" | "devtools" | "windows";
	      screenWidth: number;
	      screenHeight: number;
	      pixelRatio: number;
	      system: string;
	      model: string;
	      version: string;
	    };
	    getLaunchOptionsSync(): {
	      lanDebugInfo?: {
	        ip: string;
	        port: number;
	      }
	    };
	    getLaunchOptionsSync(): {
	      lanDebugInfo?: {
	        ip: string;
	        port: number;
	      }
	    };
	    loadFont(path: string): string | null;
	    encode(argument: {
	      data: string;
	      format: "utf-8" | "gbk";
	    }): ArrayBuffer;
	    decode(argument: {
	      data: ArrayBuffer;
	      format: "utf-8" | "gbk";
	    }): string;
	    createImage(): Image;
	    getImageInfo(argument: {
	      src: string;
	      success?: (response: {
	        width: number;
	        height: number;
	        path: string;
	        orientation: "up" | "down" | "left" | "right" | "up-mirrored" | "down-mirrored" | "left-mirrored" | "right-mirrored";
	        type: string;
	      }) => void;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    createCanvas(): HTMLCanvasElement;
	    createOffScreenCanvas(): HTMLCanvasElement;
	    getXLogManager(): XLogManager;
	    downloadFile(argument: {
	      url: string;
	      filePath?: string;
	      enableHttp2?: boolean;
	      success?: (res: {
	        dataLength?: number;
	        errMsg: string;
	        header: { [key: string]: string };
	        statusCode: number;
	        tempFilePath?: string;
	        filePath?: string;
	      }) => void;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): DownloadTask;

	    setPreferredFramesPerSecond(fps: number): void;
	  
	    showKeyboard(argument: ShowKeyboardArgument): void;
	    updateKeyboard(argument: UpdateKeyboardArgument): void;
	    hideKeyboard(argument?: HideKeyboardArgument): void;
	    onKeyboardInput(callback: (response: KeyboardEvent) => void): void;
	    onKeyboardConfirm(callback: (response: KeyboardEvent) => void): void;
	    onKeyboardComplete(callback: (response: KeyboardEvent) => void): void;

	    onTouchStart(callback: (event: TouchEvent) => void);
	    onTouchMove(callback: (event: TouchEvent) => void);
	    onTouchEnd(callback: (event: TouchEvent) => void);
	    onTouchCancel(callback: (event: TouchEvent) => void);

	    onRemoteDebug(event: string, callback: (res: { command: string, data: any }) => void): void;
	    sendRemoteDebug(debugMessage: { category: string, command: string, data: any }): void;

	    createWorker(path: string): Worker;
	    createSharedArrayBuffer(size: number): SharedArrayBuffer;
	    createInnerAudioContext(): InnerAudioContext;
	    createWebAudioContext(): AudioContext;
	    onAudioInterruptionBegin(cb: Function): void;
	    onAudioInterruptionEnd(cb: Function): void;
	    showModal(argument: {
	      title?: string;
	      content?: string;
	      showCancel?: boolean;
	      success?: (response: { confirm: boolean; cancel: boolean; }) => void;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): void;
	    connectSocket(argument: {
	      url: string;
	      header?: any;
	      protocols?: string[];
	      tcpNoDelay?: boolean;
	      perMessageDeflate?: boolean;
	      timeout?: number;
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    }): SocketTask;
	    startCPUProfiling?(): void;
	    stopCPUProfiling?(): CPUProfile;
	    showToast(argument: {
	      title: string;
	      duration?: number;
	      icon?: "success" | "loading" | "none";
	      success?: PlainCallback;
	      fail?: PlainCallback;
	      complete?: PlainCallback;
	    });
	    postMessage(data: any): void;
	    onMessage(callback: (data: any) => void): void;
	    cloud: {
	      downloadFile(options: {
	        fileID: string;
	        config?: { env: string };
	        success?: (res: {
	          errMsg: string;
	          statusCode: number;
	          tempFilePath: string;
	        }) => void;
	        fail?: (res: {
	          errMsg: string;
	          errCode: number;
	        }) => void;
	        complete?: PlainCallback;
	      }): DownloadTask;
	      init(options: {
	        traceUser?: boolean;
	        env: string | {
	          database?: string;
	          storage: string;
	          functions: string;
	        };
	      }): void;
	    }
	  }
	}

	declare const _wx: engineWX.WX;declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/bufferManager' {
	 class BufferManager {
	    constructor(delay: number);
	    add(res: ArrayBuffer | ArrayBufferView): void;
	    step(): void;
	} const bufferManager: BufferManager;
	export default bufferManager;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/downloader' {
	/**
	 * downloader.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/3/2020, 5:28:51 PM
	 */
	import { IDownloader } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface'; const downloader: IDownloader;
	export default downloader;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/Image' {
	/**
	 * Image.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 12/3/2020, 5:16:25 PM
	 */
	import { IImage } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export default class Image implements IImage {
	    static IS(obj: any): obj is Image;
	    isKanataImage: boolean;
	    premultiplyAlpha: boolean;
	    onload: (() => void) | null;
	    onerror: ((error: Error) => void) | null;
	    get data(): ArrayBuffer;
	    get src(): string;
	    get width(): number;
	    get height(): number;
	    set src(value: string);
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/commandArrays' {
	 class CommandArray {
	    get commandOffset(): number;
	    get commandOffsetUint32(): number;
	    buffer: ArrayBuffer;
	    constructor(buffer?: ArrayBuffer);
	    setCommandSize(val: number): void;
	} class SkinningMatrixCommand extends CommandArray {
	    updateSkinningMatrices(feObjects: {
	        id: number;
	    }[], length: number): Uint32Array;
	} class AnimatorCommand extends CommandArray {
	    updateAnimators(feObjects: {
	        id: number;
	    }[], length: number): Uint32Array;
	} class AnimatorControllerCommand extends CommandArray {
	    updateAnimatorControllers(feObjects: {
	        id: number;
	    }[], length: number): Uint32Array;
	}
	export const skeletonCommand: SkinningMatrixCommand;
	export const animatorCommand: AnimatorCommand;
	export const animatorControllerCommand: AnimatorControllerCommand;
	export {};

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/event-bridge/EventBase' {
	export const SIZE_UINT32 = 4;
	export const OFFSET_COMMAND_LENGTH = 0;
	export default class EventBase {
	    buffer: ArrayBuffer;
	    get commandOffset(): number;
	    get commandOffsetUint32(): number;
	    constructor(buffer: ArrayBuffer);
	    setCommandSize(val: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/event-bridge/MainEventBridge' {
	import EventBase from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/event-bridge/EventBase';
	export default class MainEventBridge extends EventBase {
	    constructor();
	    setRootEntity(entityId: number): void;
	    addChild(entityId: number, childEntityId: number): void;
	    addChildAtIndex(entityId: number, childEntityId: number, index: number): void;
	    removeFromParent(entityId: number): void;
	    disperseSubTree(entityId: number): void;
	    bindToBone(entityId: number, boneId: number): void;
	    unbindFromBone(entityId: number): void;
	    entityCommandActive(entityId: number): void;
	    entityCommandInActive(entityId: number): void;
	    bindToBones(entities: Array<{
	        id: number;
	    }>, bones: Array<{
	        id: number;
	    }>): void;
	    unBindFromBones(entities: Array<{
	        id: number;
	    }>): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/event-bridge/DirtyEntitiesEventBridge' {
	/**
	 * DirtyEntitiesEventBridge.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 1:25:56 PM
	*/
	import EventBase from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/event-bridge/EventBase';
	export default class DirtyEntitiesEventBridge extends EventBase {
	    constructor();
	    addDirtyEntity(entity: number): void;
	    addDirtyEntityId(entityId: number): void;
	    addDirtyEntities(entities: Array<number>, entitiesLength: number): void;
	    addDirtyEntitiesById(entityIds: Array<number>, entitiesLength: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/event-bridge' {
	/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 9/4/2020, 1:44:03 PM
	*/
	import { IEventBridge } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export class EventBridge implements IEventBridge {
	    entityAddChild(entity: number, child: number): void;
	    entityAddChildAtIndex(entity: number, child: number, index: number): void;
	    entityRemoveFromParent(entity: number): void;
	    entityClear(entity: number): void;
	    entitySetActive(entity: number, active: boolean): void;
	    entitySetLocalMatrixDirty(entity: number): void;
	    setRootEntity(entity: number): void;
	    refreshWorldTransform(): void;
	    bindEntityToBone(entity: {
	        id: number;
	    }, boneEntity: {
	        id: number;
	    }): void;
	    unbindEntityFromBone(entity: {
	        id: number;
	    }): void;
	    bindEntitiesToBones(entities: Array<{
	        id: number;
	    }>, boneEntities: Array<{
	        id: number;
	    }>): void;
	    unbindEntitiesFromBones(entities: Array<{
	        id: number;
	    }>): void;
	} const eventBridge: EventBridge;
	export default eventBridge;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native' {
	/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/8/18 下午4:48:36
	*/
	import { IS_VALID, GET_MAIN_CANVAS } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/worker';
	import { IWorker } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface/IWorker';
	export { IS_VALID, GET_MAIN_CANVAS };
	export const worker: IWorker;
	export { default as Image } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/native/Image';

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimationClipModel' {
	/**
	 * AnimationClipModel.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/7 下午9:19:25
	*/
	import Node from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node';
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export default class AnimationClipModel extends KObject {
	    static CLASS_NAME: string;
	    get fps(): number;
	    get totalFrame(): number;
	    get totalSampleGroup(): number;
	    get nodesCount(): number;
	    constructor(buffer: ArrayBuffer);
	    interpolate(frameIndex: number): [number, InterpolationNode][];
	    interpolateNew(frameIndex: number, defaultValues: {
	        data: Float32Array;
	        indexes: {
	            [nodeId: number]: number;
	        };
	    }, clipBinding: number[], layerIndex: number, writeMasks: {
	        [nodeId: number]: number;
	    }, useDefault: boolean): {
	        map: [number, InterpolationNode][];
	        mapKeys: {
	            [nodeId: number]: number;
	        };
	    };
	    cloneNodes(nodes: [number, InterpolationNode][]): [number, InterpolationNode][];
	}
	export class InterpolationNode {
	    percent: number;
	    useQuat: boolean;
	    get data(): Float32Array;
	    get tx(): number;
	    set tx(value: number);
	    get txActive(): boolean;
	    set txActive(value: boolean);
	    get txWeight(): number;
	    set txWeight(value: number);
	    get ty(): number;
	    set ty(value: number);
	    get tyActive(): boolean;
	    set tyActive(value: boolean);
	    get tyWeight(): number;
	    set tyWeight(value: number);
	    get tz(): number;
	    set tz(value: number);
	    get tzActive(): boolean;
	    set tzActive(value: boolean);
	    get tzWeight(): number;
	    set tzWeight(value: number);
	    get sx(): number;
	    set sx(value: number);
	    get sxActive(): boolean;
	    set sxActive(value: boolean);
	    get sxWeight(): number;
	    set sxWeight(value: number);
	    get sy(): number;
	    set sy(value: number);
	    get syActive(): boolean;
	    set syActive(value: boolean);
	    get syWeight(): number;
	    set syWeight(value: number);
	    get sz(): number;
	    set sz(value: number);
	    get szActive(): boolean;
	    set szActive(value: boolean);
	    get szWeight(): number;
	    set szWeight(value: number);
	    get rx(): number;
	    set rx(value: number);
	    get ry(): number;
	    set ry(value: number);
	    get rz(): number;
	    set rz(value: number);
	    get qw(): number;
	    set qw(value: number);
	    get quatActive(): boolean;
	    set quatActive(value: boolean);
	    get quatWeight(): number;
	    set quatWeight(value: number);
	    sub(node: InterpolationNode): void;
	    clone(cacheIndex: number): InterpolationNode;
	    disableAll(): void;
	    blend(other: InterpolationNode, percent: number): void;
	    syncValuesToNode(node: Node): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Animator' {
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import AnimationClipModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimationClipModel';
	export default class Animator extends KObject {
	    clipCount: number;
	    nodeCount: number;
	    static CLASS_NAME: string;
	    static UPDATE_ANIMATORS(animators: {
	    }[], size: number): void;
	    entityIdsOffsets: number;
	    get animationClipModels(): {
	    }[];
	    constructor(clipCount: number, nodeCount: number);
	    update(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/eventBridge' {
	/**
	 * eventBridge.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/8 下午5:28:13
	 */
	import { IEventBridge } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	export class EventBridge implements IEventBridge {
	    entityAddChild(entity: number, child: number): void;
	    entityAddChildAtIndex(entity: number, child: number, index: number): void;
	    entityRemoveFromParent(entity: number): void;
	    entityClear(entity: number): void;
	    entitySetActive(entity: number, active: boolean): void;
	    entitySetLocalMatrixDirty(entity: number): void;
	    setRootEntity(entity: number): void;
	    refreshWorldTransform(): void;
	    bindEntityToBone(entity: {
	        id: number;
	    }, boneEntity: {
	        id: number;
	    }): void;
	    unbindEntityFromBone(entity: {
	        id: number;
	    }): void;
	    bindEntitiesToBones(entities: Array<{
	        id: number;
	    }>, boneEntities: Array<{
	        id: number;
	    }>): void;
	    unbindEntitiesFromBones(entities: Array<{
	        id: number;
	    }>): void;
	} const eventBridge: EventBridge;
	export default eventBridge;

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/NativeMap' {
	/**
	 * NativeMap.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/8 下午9:35:06
	 */
	export class NativeMap<T> {
	    set(key: T, value: number): void;
	    get(key: T): number | undefined;
	    del(key: T): void;
	}
	export class LongIntToIntMap {
	    set(key1: number, key2: number, value: number): void;
	    get(key1: number, key2: number): number | undefined;
	    del(key1: number, key2: number): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimatorControllerStateModel' {
	/**
	 * AnimatorControllerStateModel.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 4/21/2021, 6:24:33 PM
	*/
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	export interface IAnimatorControllerStateBlend {
	    clipModelId: number;
	    frameIndex: number;
	    weight: number;
	    additiveClipModelId: number;
	    additiveClipFrameIndex: number;
	}
	export default class AnimatorControllerStateModel extends KObject {
	    static CLASS_NAME: string;
	    get blendCount(): number;
	    get weight(): number;
	    get useDefault(): number;
	    get nextState(): AnimatorControllerStateModel;
	    constructor(blendCount: number);
	    getBlend(index: number, res: IAnimatorControllerStateBlend): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimationClipBinding' {
	/**
	 * AnimationClipBinding.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 4/21/2021, 6:23:50 PM
	*/
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import { EUseDefaultAddedAction, EUseDefaultRemovedAction, EUseDefaultRetainedAction } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface';
	import Node from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node';
	import AnimationClipModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimationClipModel';
	export class AnimationBlendResult {
	    static MAX_NODE_COUNT: number;
	    data: Float32Array;
	    indexes: {
	        [nodeId: number]: number;
	    };
	    last: number;
	    length: number;
	    constructor(nodesCount: number);
	    reset(): void;
	    showDebugInfo(nId?: string): string;
	}
	export default class AnimationClipBinding extends KObject {
	    static CLASS_NAME: string;
	    get root(): Node;
	    get defaultValues(): {
	        indexes: {
	            [nodeId: number]: number;
	        };
	        data: Float32Array;
	        endNodeId: number;
	        nodesCount: number;
	    };
	    get clipBinding(): {
	        [clipId: number]: number[];
	    };
	    constructor(clipArray: {
	        id: number;
	    }[], clipOffset: number, clipLength: number, entityArray: Array<number | {
	        id: number;
	    } | null>, entityOffset: number, entityLength: number, useDefaultAddAction: EUseDefaultAddedAction, rootEntityId: number);
	    isValidClipModel(id: number): boolean;
	    createBlendResult(cacheKey: number): AnimationBlendResult;
	    rebind(clipArray: {
	        id: number;
	    }[], clipOffset: number, clipLength: number, entityArray: Array<number | {
	        id: number;
	    } | null>, entityOffset: number, entityLength: number, removeAction: EUseDefaultRemovedAction, retainedAction: EUseDefaultRetainedAction, addedAction: EUseDefaultAddedAction, rootEntityId: number): boolean;
	    update(clipArray: {
	        id: number;
	    }[], clipOffset: number, clipLength: number, entityArray: Array<number | {
	        id: number;
	    } | null>, entityOffset: number, entityLength: number, removeAction: EUseDefaultRemovedAction, retainedAction: EUseDefaultRetainedAction, addedAction: EUseDefaultAddedAction): boolean;
	    getClipBindingInfo(clipModelId: number): AnimationClipModel | null;
	    writeDefaultValues(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimatorControllerModel' {
	import KObject from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/shared/KObject';
	import AnimationClipBinding from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimationClipBinding';
	import AnimatorControllerStateModel from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/AnimatorControllerStateModel';
	export default class AnimatorControllerModel extends KObject {
	    static CLASS_NAME: string;
	    static UPDATE_ANIMATOR_CONTROLLERS(animators: {
	    }[], size: number): void;
	    get layerCount(): number;
	    get binding(): AnimationClipBinding;
	    get blendStates(): {
	    }[];
	    get bindingRoot(): import('!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/logic/Node').default;
	    constructor(layerCount: number);
	    setMaskAtIndex(layerIndex: number, content: ArrayBuffer, offset: number, length: number): boolean | undefined;
	    update(): void;
	    destroy(): void;
	}

}
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl' {
	/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/8/18 下午4:48:36
	*/
	import '../kanata/src/backend/webgl/shared/adapters';
	import { IWorker } from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/interface/IWorker';
	import Image from '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/backend/webgl/resource/Image';
	export const worker: IWorker;
	export function IS_VALID(): boolean;
	export { Image };
	export function GET_MAIN_CANVAS(): HTMLCanvasElement;

}
/**
	 * index.ts
	 *
	 * @Author  : hikaridai(hikaridai@tencent.com)
	 * @Date    : 2020/12/02 下午4:48:36
	*/
declare module '!!Only Export Engine Module, Cant Use Internal Module：../kanata/src/frontend/shared/crossContext' {
	 class CrossContext {
	    constructor();
	    postMessage(data: any): void;
	    onMessage(callback: (data: any) => void): void;
	    flush(): void;
	} let crossContext: CrossContext;
	export default crossContext;

}
